{"meta":{"title":"TobyShiの博客","subtitle":"TobyShiの博客","description":null,"author":"TobyShi","url":"https://toby-shi-cloud.github.io","root":"/"},"pages":[{"title":"","date":"2023-01-02T07:19:23.066Z","updated":"2022-06-14T07:18:32.138Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://toby-shi-cloud.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2022-06-14T07:18:32.141Z","updated":"2022-06-14T07:18:32.141Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://toby-shi-cloud.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-14T07:18:32.014Z","comments":true,"path":"404.html","permalink":"https://toby-shi-cloud.github.io/404.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-06-14T07:18:32.139Z","comments":true,"path":"census/index.html","permalink":"https://toby-shi-cloud.github.io/census/index.html","excerpt":"","text":""},{"title":"Object Oriented","date":"2023-03-30T16:00:00.000Z","updated":"2023-04-08T09:17:02.456Z","comments":true,"path":"oocheck/index.html","permalink":"https://toby-shi-cloud.github.io/oocheck/index.html","excerpt":"","text":"重要说明已经更新至 Homework 7测试点可能不符合强测或互测要求，仅供参考（比如有的测试点数据量极大）使用说明点击右侧目录选择测试点编号，然后将测试点输入拷贝到本地运行，将运行结果粘贴到下方的输入框中，点击提交即可。 提交后，系统会自动判断正确与否，判题结果会显示在提交按钮下方。 历史提交在首次提交后，系统会自动保存你的提交记录，并生成 UserID。 此后的提交，可通过输入 UserID 在同一个账号下提交。 通过键入 UserID 你可以点击此处查看历史提交记录。 测试点欢迎提供有强度的测试点，若有好的测试点，请发邮件至 toby283901@outlook.com. 免责声明测试点仅供参考，测试成绩仅供参考，与你的最终强测成绩无关。"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-14T07:18:32.136Z","comments":true,"path":"about/index.html","permalink":"https://toby-shi-cloud.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-14T07:18:32.138Z","comments":true,"path":"categories/index.html","permalink":"https://toby-shi-cloud.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2023-01-02T08:19:18.032Z","comments":true,"path":"friends/index.html","permalink":"https://toby-shi-cloud.github.io/friends/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-14T07:18:32.137Z","comments":true,"path":"archives/index.html","permalink":"https://toby-shi-cloud.github.io/archives/index.html","excerpt":"","text":""},{"title":"第零次作业指导书","date":"2022-12-31T16:00:00.000Z","updated":"2023-01-02T09:38:19.363Z","comments":true,"path":"oopre/hw0.html","permalink":"https://toby-shi-cloud.github.io/oopre/hw0.html","excerpt":"","text":"第零次作业训练目标 学习使用 git以及 gitlab相关操作 学习使用课程网站提交 任务一：git 学习step 0 git 安装与配置git 的安装Linuxsudo apt-get install git Mac OS X从 AppStore 安装 Xcode，运行 Xcode，选择菜单 “Xcode” -&gt; “Preferences”，在弹出窗口中找到 “Downloads”，选择 “Command Line Tools”，点 “Install” 即可完成安装。 Windows在官网上选择最新版本进行下载安装。 git 的配置git config --global user.name \"你的名字\" git config --global user.email \"21xxxxxx@buaa.edu.cn\" 利用上述指令配置 git，注意将 “你的名字” 和 “21xxxxxx@buaa.edu.cn” 分别替换成你真实姓名和北航邮箱。 配置 ssh key参考官网上给出的介绍说明进行 ssh key 的配置 step 1 新建仓库在本地新建一个空文件夹，在此目录下打开终端（bash/git bash/powershell/…） 输入 git clone 你的个人第零次作业的远程仓库链接 （其中个人作业 0 仓库的名字为 cpphomework_2022_你的学号_hw0，个人第零次作业的远程仓库链接进入仓库后可以看见） step 2 尝试一次提交下面两种方式均可，建议刚上手的同学使用IDEA提交 命令行提交在你的仓库目录下 git add 你要提交的文件 git commit -m \"Init commit\" git push IDEA提交用IDEA打开你git clone下来的仓库使用内置的git工具提交即可。参考资料 至此，任务一的内容已全部介绍完毕，如果按照上述步骤操作后得到预期结果（例如可以正常 pull 和 push），即可开始进行任务二。 任务二：课程网站提交问题描述:输入两个整数 a, b 输出它们的和（保证结果在int范围内） 输入格式:两个以空格分开的整数。 输出格式:一个整数。 样例:stdin: 2 3 stdout: 5 参考资料 Git 使用心得 &amp; 常见问题整理 Git 廖雪峰教程文档中可以找到相关内容。 其他本次作业没有强测，仅为练习，不计入作业成绩。","author":"OOpre"},{"title":"第二次作业指导书","date":"2022-12-31T16:00:00.000Z","updated":"2023-01-02T10:01:35.486Z","comments":true,"path":"oopre/hw2.html","permalink":"https://toby-shi-cloud.github.io/oopre/hw2.html","excerpt":"","text":"第二次作业指导书第一部分：训练目标 学习继承，了解设计模式中的工厂模式。 学习方法的重写、Java 的多态机制以及 Java 的异常处理机制。 学习 Git 工具中的远程仓库、打标签、重置的相关知识。 第二部分：预备知识一、继承继承就是定义子类继承父类的特征和行为，使得子类可以拥有父类的属性和方法，从而起到代码复用的目的。 举个例子，假设我们有一个类 Hero 表示英雄，其包含生命值，保护盾值与魔法值这三个属性，并包含“徒手攻击”这一方法： public class Hero { int healthPoint; int defensePoint; int magicalPoint; public void attackWithHand() { /**/ } } 假设我们还想设计一个类，比如“骑士”类 Knight ，他是英雄的一种，其也拥有生命，保护盾和魔法值，也拥有“徒手攻击”方法，除此之外其还拥有“手枪攻击”这个方法。如果从头开始实现这个类的话，需要编写如下代码： public class Knight { int healthPoint; int defensePoint; int magicalPoint; public void attackWithHand() { /**/ } public void attackWithPistol() { /**/ } } 注意到骑士相比较英雄只多了一个使用手枪攻击的方法，其他部分都一样，所以我们可以认为骑士是一种特殊的英雄。其实我们还可能要设计“牧师“、“游侠”等类，其也拥有英雄类拥有的那些属性和方法，除此之外它们各自可能还有一些其他方法，则我们也可以将两个类也认为是特殊的英雄。倘若我们仍然直接编写代码，则又要写很多重复代码。如果直接复制粘贴，还要修改类名以及构造方法等地方，且假如第一个版本的方法写错了，后面复制粘贴的都会出错，修改时要处处做修改，非常麻烦。 这个时候，继承就登场了。使用继承，我们可以让类 A 去得到类 B 已有的属性和方法，接下来类 A 就只需要专注于编写其特有部分的代码了。 使用继承来编写骑士类的例子如下： public class Knight extends Hero { // 公共的属性和方法不需要重复编写 // 只需要编写Knight特有的手枪攻击方法 public void attackWithPistol() { /**/ } } 在Java中，我们使用 extends 关键字表示继承，A extends B 意味着 A 继承了 B ，A 是 B 的子类， A 得到了 B 的属性和方法。 从语义上来说，在 A 和 B 类型满足 is-a 关系（A is a B），即A 类型是 B 类型的一种时，可以使用继承来在程序表述。在本例中可以说 Knigh is a Hero，因此我们使用继承关系。 二、向上转型在建立了继承关系之后，可以使用父类型去引用通过子类型创建的对象。这里涉及两个重要的概念，对象与对象引用。一般而言，对象是一个类的实例化结果，对应内存中的一个数据结构。对象引用则是使用一个变量来指向内存中的这个数据结构（即对象）。 如我们可以使用上面的 Knight 类来构造一个对象：new Knight()，这条语句返回一个创建的对象。我们同时需要声明一个对象引用来指向返回的对象，否则可能就找不到这个对象了。所以，一般代码都会这么写：Knight knt = new Knight() 。 在建立了继承关系之后，我们也可以使用 Hero 类来声明一个对象引用，并指向类型为 Knight 的对象：Hero h = new Knight()。从程序类型的角度，这个表达方式称为向上的类型转换，简称向上转型 (up cast)。向上转型的例子如下： public class Main { public static void main(String[] args) { Hero hero1 = new Knight(); hero1.attackWithHand(); } } 因为 Knight 类提供了 attackWithPistol() 方法，因此通过 new Knight() 创建的对象是拥有手枪攻击这个能力。这里同学们可能会马上想到：能否通过上面例子中的 hero1 来调用这个方法呢？ 如下面的代码所示： public class Main { public static void main(String[] args) { Hero hero1 = new Knight(); // 编译错误 hero1.attackWithPistol(); } } 很不幸，上面的代码会出现编译错误，编译器认为 Hero 类中没有定义 attackWithPistol() 方法。这就带来了一个问题，明明所指向的对象拥有相应的方法，但是却不能调用。其原因是我们进行了向上转型，使用 Hero 类型的变量来引用它，这往往表明程序设计者此时只关心在 Hero 类这个层次能够看到的方法（否则就应该使用 Knight 来声明一个引用）。 三、向下转型Java 语言提供了一个特殊的关键词 instanceof 用来判断一个对象引用所指向的对象的创建类型是否为特定的某个类，一般写为 obj instanceof A，其中 obj 为一个对象引用，A 为一个类型（类或接口），这个表达式的取值结果为布尔型，如果 obj 的创建类型为 A，则结果为 true，否则为 false。在这个表达式取值为 true 的情况下，可以使用向下转型 (down cast) 来使用一个 A 类型的对象来引用obj： A ao = (A)obj 。注意，实际上 obj 所指向对象的创建类型永远不会发生变化，转型的只是对象引用类型。下面例子给出了相应的向下转型场景： public class Main { public static void main(String[] args) { A[] list = new A[20]; Scanner input = new Scanner(System.in); int cnt = 0; // 先构造10个对象，放到数组list中 for (int i = 0; i &lt; 10; i++) { int t = input.nextInt(); if (t % 3 == 0) { list[cnt] = new A(); } else if (t % 3 == 1) { list[cnt] = new B(); } else { list[cnt] = new C(); } cnt++; } // 我们想调用list中所有C类型对象的c()方法 for (int i = 0; i &lt; cnt; i++) { // 先判断是不是C类型的对象，A instanceof B会返回true 或者 false if (list[i] instanceof C) { // 如果是，就向下转型，使用这个对象原本的类型的引用去指向它 // 如果不是却还强行向下转型，则会出现错误 C ref = (C) list[i]; // 然后调用其c()方法 ref.c(); } } } } 值得注意的是，在 instanceof 返回真的时候使用向下转型，才能保证向下转型的安全性，否则运行时会触发错误。 四、对象方法的重写和复用有时候，你会发现具有继承关系的类的某些行为具有递进关系，比如在下方代码中 Course类 和 OOCourse类 之间具有继承关系，OOCourse与Course有部分相同行为（即Course中定义且被OOCourse继承的行为），但OOCourse也会有自己的特有行为。 为了确保不论是使用Course对象引用，或者OOCourse对象引用来访问OOCourse对象时都能够顺利调用相应的方法，我们期望这两个类中实现的特定方法同名。这种让子类重新实现一个在父类中已经实现的方法是面向对象的一个重要机制，称为方法重写。方法重写获得的直接好处是让子类与父类在相应方法的调用上保持了一致性。 更通俗的说，重写方法与父类方法在行为上具有相似功能，但子类重写的方法一般额外增加一些行为。举例而言，设Course中实现了一个显示课程信息的方法(displayInfo)，我们希望OOCourse重新实现这个方法，从而能够多显示一些特有的信息。在程序编写方面，一般会为重写方法标上一个@Override标签。看下面的例子： class Course { void displayInfo() { System.out.println(\"老师上课，同学完成作业，最终老师会给一个成绩\"); } } class OOCourse extends Course { @Override void displayInfo() { System.out.println(\"老师上课，同学完成作业，最终老师会给一个成绩\"); System.out.println(\"还有研讨课，强测互测等任务，学期结束还会有颁奖典礼\"); } } 我们可以看到OOCourse重写的displayInfo方法中的第一句话与Course中displayInfo方法的语句完全相同。通常，我们不希望出现重复编写代码（又称为代码拷贝）的现象。Java语言提供了一个重要的关键词super，它实际指代的是当前对象从父类继承得到的内容，因此通过super.displayInfo()可以确保调用的是Course实现的displayInfo方法。请看下面的例子： class OOCourseAlpha extends Course { @Override void displayInfo() { super.displayInfo(); // 调用了类Course中定义的方法 System.out.println(\"还有研讨课，强测互测等任务，学期结束还会有颁奖典礼\"); } } 五、多态前面提到，如何判断实际调用的是子类重写的方法，还是父类实现的方法。其实，这与对象引用的类型无关，而是取决于被引用对象的创建类型。请看下面的代码示例： Course c1 = new Course(); Course c2 = new OOCourseAlpha(); c1.displayInfo(); c2.displayInfo(); 其中通过c1调用的实际是Course类实现的displayInfo方法，而通过c2调用的则是OOCourseAlpla类重写的displayInfo方法，但实际上c1和c2的引用类型都是Course。 上面我们提到的这个特性，就叫做多态。 六、异常处理程序运行时，发生了不被期望的事件，它阻止了程序按照程序员的预期正常执行，这就是异常。运行出错后，Java 提供了一种优秀的解决办法：异常处理机制。 异常处理机制采取显式的方式来处理异常，包括两个方面： 引入了专门的表达和处理方式，代码上一目了然就能看出是异常处理； 一旦发生异常，会强迫程序执行进入异常处理分支。 在Java语言中，每个异常都被封装为Exception，异常有抛出和捕捉两种处理方式。所谓抛出，就是使用Java提供的throw关键词来产生一个Exception或者其某个子类的对象；而捕捉则是通过catch关键词来捕捉在一段代码的执行过程中所抛出的相关异常对象。 课程推荐使用异常处理机制来区分处理显著不同于一般情况下的数据状态。使用异常处理可以让你的代码更加清晰易于理解，降低出现 bug 的可能性。请阅读《Core Java》的第七章相关内容了解异常处理机制的使用方法，并参照本章最后 Tips 部分来使用异常处理优化你的代码。 第三部分：题目描述本次作业需要在上次作业的基础上进行增量开发。 建立 Equipment 装备类。我们将 Task1 中的 Bottle 以及下面增加的所有药水类、武器类统称为 “装备类”，使所有装备类均继承自 Equipment 类（该类因而可称为基类， base class），请将所有装备都具有的属性定义在这个类里。同时，Task1 中每位冒险者拥有承载多个 Bottle 的容器，这里将承载 Bottle 的容器改为承载所有装备类的容器。 为冒险者新增一些属性如下：生命值 （health, 浮点数，默认值 100.0）、经验值（ exp, 浮点数，默认 0.0）、金钱数（ money, 浮点数，默认 0.0）。 增加药水 HealingPotion 和 ExpBottle 并继承 Bottle 的全部属性；添加“武器类” Sword 以及 RareSword 和 EpicSword，他们继承 Sword 全部属性。见下表： 药水类型 属性 属性类型 HealingPotion 包括 Bottle 的全部属性，新增加属性 efficiency，代表药水的治疗效果 Bottle 原有属性不变，efficiency 为浮点数类型 ExpBottle 包括 Bottle 的全部属性，新增加属性 expRatio，代表水瓶对于经验值的增强效果 Bottle 原有属性不变，expRatio为浮点数类型 武器类型 属性 属性类型 Sword id, name, price, sharpness。其中 id, name, price 与 Task1 中 Bottle 类的定义相同，sharpness 表示武器的锋利程度 id, name, price 与 Bottle 类中相应属性类型相同，sharpness 为浮点数类型 RareSword 包括 Sword 的全部属性，新增加属性 extraExpBonus，代表使用武器的附加效果 Sword 原有属性不变，extraExpBonus 为浮点数类型 EpicSword 包括 Sword 的全部属性，新增加属性 evolveRatio，代表使用武器的附加效果 Sword 原有属性不变，evolveRatio 为浮点数类型 为每一种装备设置一个使用方法，定义如下，设冒险者A使用了装备B： 装备B的类型 使用效果 输出文本 Bottle（若 filled 为 true） A的生命值增加[B的 capacity 属性]的十分之一，之后 B 的 filled 变为 false，price 变为原来的十分之一（向下取整）。 {A 的 name} drank {B 的 name} and recovered {生命值增加量}. HealingPotion（若 filled为true） A的生命值增加[B的 capacity 属性]的十分之一，之后 B 的 filled 变为 false，price 变为原来的十分之一（向下取整）。然后A的生命值再额外增加[B的capacity属性]乘以[B的efficiency属性]的量。 {A 的 name} drank {B 的 name} and recovered {生命值增加量}.{A 的 name} recovered extra {生命值额外增加量}. ExpBottle（若 filled 为 true） A的生命值增加[B的 capacity 属性]的十分之一，之后 B 的 filled 变为 false，price 变为原来的十分之一（向下取整）。然后A的经验值变为原来的[B的expRatio属性]倍。 {A 的 name} drank {B 的 name} and recovered {生命值增加量}.{A 的 name}’s exp became {A 变化后的经验}. Bottle/HealingPotion/ExpBottle（若filled为false） 无任何作用效果。 Failed to use {B 的 name} because it is empty. Sword 使用后A的生命值减少 10.0、经验值增加 10.0，金钱数增加相当于[B 的 sharpness属性]一倍的量。 {A 的 name} used {B 的 name} and earned {增加的金钱数}. RareSword 使用后A的生命值减少 10.0、经验值增加 10.0，金钱数增加相当于[B 的 sharpness属性]一倍的量。然后 A 的经验值额外增加[B 的 extraExpBonus 属性]。 {A 的name} used {B 的name} and earned {增加的金钱数}.{A 的name} got extra exp {额外获得的经验}. EpicSword 使用后A的生命值减少 10.0、经验值增加 10.0，金钱数增加相当于[B 的 sharpness属性]一倍的量。然后B的sharpness 属性变为原来的 evolveRatio倍。 {A 的 name} used {B 的 name} and earned {增加的金钱数}.{B 的 name}’s sharpness became {B 变化后的sharpness}. 实现各项装备的查询和增删指令，设置如下操作： 加入一个冒险者 给某个冒险者添加某件装备（装备包括药水和武器） 删除某个冒险者拥有的某个装备 查询某个冒险者所拥有装备的价格之和 查询某个冒险者所拥有装备的价格最大值 查询某个冒险者拥有的装备总数 打印一个装备的全部属性，属性的输出顺序与输入创建该装备时给定的各参数顺序一致，具体格式详见下方 属性打印方式 某个冒险者使用其拥有的某个装备 打印某个冒险者的所有状态 第四部分：输入输出第一行一个整数 mm，表示操作的个数。 接下来的 mm 行，每行一个形如 {type} {attribute} 的操作，{type} 和 {attribute} 间、若干个 {attribute} 间使用若干个空格分割，操作输入形式及其含义如下： type attribute 意义 输出文本 1 {adv_id} {name} 加入一个 ID 为 {adv_id}、名字为 {name} 的冒险者，且未持有任何装备 无 2 {adv_id} {equipment_type} {vars}（equipment_type和vars的含义见下表） 给予某个人某件装备，装备类型由 {equipment_type} 定义，属性由 {vars} 定义，所有的瓶子初始默认装满 无 3 {adv_id} {equipment_id} 删除 ID 为 {adv_id} 的冒险者的 ID 为 {equipment_id} 的装备 无 4 {adv_id} 查询 ID 为 {adv_id} 的冒险者所持有装备的价格之和 一个整数，表示该冒险者所有装备的价格总和 5 {adv_id} 查询 ID 为 {adv_id} 的冒险者所持有装备价格的最大值 一个整数，表示该冒险者所有装备价格的最大值 6 {adv_id} 查询 ID 为 {adv_id} 的冒险者的装备总数 一个整数，表示该冒险者所有装备的数量之和 7 {adv_id} {equipment_id} 打印 ID 为 {equipment_id} 的装备的全部属性 该装备的全部属性，格式见下文“属性打印方式” 8 {adv_id}{equipment_id} ID为 {adv_id} 的冒险者使用其 ID 为 {equipment_id} 的装备 装备在使用时会产生输出，除此之外无额外输出。 9 {adv_id} 打印ID为 {adv_id} 的冒险者的所有状态。 一个字符串表示冒险者的状态：The adventurer's id is {adv_id}, name is {name}, health is {health}, exp is {exp}, money is {money}. 装备类型 equipment_type vars Bottle 1 id name price capacity HealingPotion 2 id name price capacity efficiency ExpBottle 3 id name price capacity expRatio Sword 4 id name price sharpness RareSword 5 id name price sharpness extraExpBonus EpicSword 6 id name price sharpness evolveRatio 装备类型 属性打印方式 Bottle The bottle's id is {id}, name is {name}, capacity is {capacity}, filled is {filled}. HealingPotion The healingPotion's id is {id}, name is {name}, capacity is {capacity}, filled is {filled}, efficiency is {efficiency}. ExpBottle The expBottle's id is {id}, name is {name}, capacity is {capacity}, filled is {filled}, expRatio is {expRatio}. Sword The sword's id is {id}, name is {name}, sharpness is {sharpness}. RareSword The rareSword's id is {id}, name is {name}, sharpness is {sharpness}, extraExpBonus is {extraExpBonus}. EpicSword The epicSword's id is {id}, name is {name}, sharpness is {sharpness}, evolveRatio is {evolveRatio}. 数据范围与操作限制变量约束 变量 类型 说明 id 整数 取值范围：0 - 2147483647 name 字符串 保证不会出现空白字符 price 长整数 在 long 精度范围内，且保证不小于 0 capacity, efficiency, expRatio, sharpness, extraExpBonus, evolveRatio, health, exp, money 浮点数 在 double 精度范围内 操作约束 操作数满足 $1 \\leq m \\leq 2000$。 保证所有冒险者与装备的 ID 两两不同。 操作2-9：冒险者 ID 一定存在。 操作 3,7,8：冒险者一定持有该 ID 的装备。 操作 4：若冒险者不持有任何装备，则输出 0。 操作 5：冒险者一定持有至少一个装备。 测评方法输出数值时，你的输出数值需要和正确数值相等。 假设你的输出值 $x_{out}$ 和正确数值 $x_{std}$ 之间的绝对或相对误差小于等于 $10 ^ {-5}$，则认为是相等的，即满足$$\\dfrac {|x_{std} - x_{out}|}{\\max(1, |x_{std}|)} \\leq 10^{-5}$$ 输入样例17 1 2 Co20ocvblT 1 30 Al8QnWnkS7 1 91 pqWY5UNcm4 2 91 1 26 6DlfOJGzfY 74 96.3964 2 2 6 35 yv58Ec49pK 2 65.161 68.6988 2 2 1 71 FEw7siBqbW 64 66.534 2 91 2 44 OLy4CqtmrO 45 60.135 13.2503 2 30 1 56 H2EvYaqUXD 0 64.7676 2 91 6 65 Wjsn3jVy6E 60 20.1061 23.1743 2 2 2 28 0WnMAYPzUH 37 27.0554 10.4833 3 30 56 4 30 5 91 6 91 7 91 65 8 2 35 9 91 输出样例0 74 3 The epicSword's id is 65, name is Wjsn3jVy6E, sharpness is 20.1061, evolveRatio is 23.1743. Co20ocvblT used yv58Ec49pK and earned 65.161. yv58Ec49pK's sharpness became 4476.4825068. The adventurer's id is 91, name is pqWY5UNcm4, health is 100.0, exp is 0.0, money is 0.0. 第五部分：补充 “装备类”包括 Bottle, HealingPotion 等 6 个不同的类，而冒险者需要拥有一个可以承载这 6 个装备类的容器。为了避免为 6 个装备类分别维护容器的麻烦，我们可以使用“向上转型”，在 Adventurer 类中统一维护一个承载 Equipment 的容器，并让 6 个装备类全部继承自 Equipment 类。由于“多态”的特性，在向上转型后对象仍然不会失去其原先的装备性质。 建议在Equipment类中定义一个used方法，该方法的代码用于描述这个装备被使用时会发生的效果，在所有的装备子类中都去重写这个used方法，另外还应该为所有需要打印描述字符串的类重写toString方法。在Adventurer类中定义HashMap&lt;Integer, Equipment&gt;类型的equipments属性（也可使用其他容器），表示冒险者拥有的全部装备，在执行操作8时，直接调用该装备对象的used方法（因为有多态机制，这里不需要强制转型，直接调用就可以保证行为正确）。 冒险者使用装备的过程中，是对冒险者属性和装备自身属性的读取，运算和修改。如何才能让装备类的方法可以读取并修改他的使用者的属性呢？为used方法传递一个冒险者作为参数是一个好主意。既然加了冒险者作为参数，那不妨把方法名从used改为usedBy，这会让你的代码看起来就像是英文句子一样，写出self-documenting code（自我解释型代码）。 在 Bottle 和它的子类在 filled 为 false 时被使用就可以看作是一种异常行为。于是你可以在 Bottle.usedBy 方法中抛出一个异常（使用 throw 语句），在 HealingPotion.usedBy 调用 super.usedBy 时，不处理这个异常而是将其继续抛出到上层，而在冒险者循环使用装备的代码中将其捕获并打印出错误信息。以下代码是 Bottle 类中推荐的 usedBy 实现方法： @Override public void usedBy(Adventurer user) throws Exception { // 因为有一个 Adventurer 参数，所以方法名写作 \"usedBy\" 会比 \"used\" 更加易于理解。 if (!isFilled()) { throw new Exception(\"Failed to use \" + getName() + \" because it is empty.\"); } user.setHealth(user.getHealth() + capacity / 10); setFilled(false); setPrice(getPrice().divide(BigInteger.TEN)); System.out.println(user.getName() + \" drank \" + getName() + \" and recovered \" + capacity / 10 + \".\"); } 以下代码是 Adventurer 类中用于完成操作 8 所推荐的 use 实现方法。 public void use(Equipment equipment) { try { equipment.usedBy(this); } catch (Exception e) { System.out.println(e.getMessage()); } } 设计模式是软件开发人员经过相当长的实践总结出来的最佳设计方案，在面向对象设计与构造课程中，你将逐步了解和掌握几种基本的设计模式，包括工厂模式、单例模式、生产者-消费者模式等。 现在，希望大家可以了解工厂模式，这是在继承和接口实现中常用的设计模式。 大家可以参考链接中的介绍，也可以自行查阅资料。这将帮助你更轻松的完成日后的作业 :) 本次作业的“测验”部分仍然是与 Git 相关的题目，均可在 Git Pro 中找到答案。测验题回答正误均没有影响，不计入成绩，我们将在提交正确或提交机会用尽时给出题目的详细解析，希望同学们阅读后能有所收获。 第二次实验数据点击下载","author":"OOpre"},{"title":"第一次作业指导书","date":"2022-12-31T16:00:00.000Z","updated":"2023-01-02T09:49:28.585Z","comments":true,"path":"oopre/hw1.html","permalink":"https://toby-shi-cloud.github.io/oopre/hw1.html","excerpt":"","text":"第一次作业指导书欢迎大家来到本课程的第一次正式作业！ 本课程共有7次作业，他们被分为三个单元，每个单元有独立的题目背景，单元内部的若干次作业以迭代的形式展开，即后一次作业是在前一次作业的基础上迭代完成的，这意味着大家需要在保证代码正确性的同时，尽量提高可扩展性，以便于后续迭代开发。不过，请同学们不必担心，在第一单元中，我们不会对代码的可扩展性提出过高的要求，代码架构也将会有足够的提示。 前三次作业 (homework1 - homework3) 为第一单元，在本单元中大家将学习基本的 Java 知识、面向对象知识，同时也会进一步学习 git 的基础知识。以下是第一单元三次作业的基本内容： Homework1 引导同学们实现一系列基础的类，并且熟悉类、属性和方法的使用，引导大家向面向对象的思维方式转变。 Homework2 涉及方法的重写和复用，并引入异常处理机制，希望同学们可以感性地体会到层次化设计的好处，了解并简单应用异常处理（异常处理在之后也常会用到）。 Homework3 涉及接口，需要同学们在之前 Task 的基础上完成更加复杂的操作。如果此时仍然使用原来的编码习惯，会在这个 Task 中遇到巨大困难，而严格按照我们的提示去做的同学会体会到好处。同时，为了顺利的完成本次作业，同学们也需要了解 git 分支的相关知识。 在本单元中，同学们还将继续学习 git 版本管理工具的相关知识，每次作业中均将有所体现。请大家在本单元持续的三周时间内，至少完成 Git Pro 前三章内容的阅读（起步、Git 基础、Git 分支）。 这不仅会让大家更顺利的完成本单元的代码作业，同时也可以真正基本掌握 git 这一强大工具的用法，而并不仅仅是使用 git 上传代码进行评测。 本单元每一次作业的指导书，将先为大家简要地介绍本次作业所需的知识，之后给出本次作业的具体要求以及示例，最后还会给出架构和编码方面的一些提示，以辅助同学们完成代码架构，增加代码的扩展性。为了更加严谨地描述题目要求，以及为大家提供更详细的指导，指导书可能较长，希望同学们可以耐心读完。如果在阅读指导书的过程出遇到疑问，欢迎大家在讨论区中提出。 本单元每一次作业中，同学们需要完成测验题目和代码任务。为了增加同学们对 git 版本管理工具的理解，同时也为了帮助同学们完成 Homework3，每次作业均设置了一些测验题，以帮助大家更好的掌握 git 用法、理解 git 原理。题目形式可能包括选择、填空等，有多次提交机会，回答正误均没有影响，不计入成绩，我们将在提交正确或提交机会用尽时给出题目的详细解析，希望同学们阅读后能有所收获。测验题目均可以在上述的 Git Pro 中找到答案，因此希望大家认真阅读。完成全部测验题目后，大家便可根据指导书的要求编写代码并提交评测。 为了更高效的答疑，我们鼓励大家使用讨论区进行提问交流，助教也将在讨论区回答相关问题。课程的其他详细说明见gitlab 公共发布区。 第一部分：训练目标 学会构建构造方法 Java 类使用变量定义数据状态，使用方法定义行为。除此之外，类还提供了一种称为构造方法(constructor)的特殊方法，用于创建新对象。作为类的方法，构造方法虽然可以完成任何动作，但是构造方法的目标是为了完成初始化，因此构造方法的实现代码具有显著的特征，即对类中定义的成员变量进行初始化。按照变量的类型要区分两种情况： 原子类型的成员变量：一般是直接使用编程语言内置的数据类型所声明的变量，如 int ，boolean 等。这种成员变量一般可以直接赋值，如 int price = 10。 复合类型的成员变量：一般是使用编程语言类库或用户自定义的类(class)来声明的成员变量，如 ArrayList myList 。这种成员变量无法直接指定一个赋值结果，通常需要调用相应类型的构造方法来获得相应的初始值，如 myList = new ArrayList() 。 对类进行封装，理解封装的作用 封装是面向对象方法的一个重要特征，强调对外隐藏对象的内部属性和实现细节，仅对外提供公共访问方式。这样做的优点是提高类的可复用性、安全性。 关键字 private 、protected 和 public 可以进一步对类的成员（包括变量和方法）的可见范围，被 private 修饰的成员只能在本类中使用；protected修饰的成员可以在本类及其直接子类使用；public修饰的成员可以在任意类中直接使用。一般而言，根据封装原则，如果没有特别的针对性考虑，建议对所有的成员变量使用private进行限定。 建立一个对象的集合，实现向集合中增加对象和访问集合中对象的操作，学习容器的使用和选择，熟悉对容器的操作 学习 git 版本管理工具的基础知识 Git Pro 是 Git 官方推荐的资料，其中介绍了 git 工具的基本用法和原理。本单元要求大家阅读前三章（起步、Git 基础、Git 分支），并根据从中学到的知识完成测验题目。 本次作业中，我们希望大家可以阅读 Git 基础 - 撤销操作 一节及其之前的内容，以及 Git 工具 - 重置揭秘 一节，并完成测试题目。 阅读官方文档 JDK 提供了官方文档 JDK Document，大家可以从中找到所有 Java 提供的类的详细介绍。该文档右上角提供了搜索框，输入想要查询的类或方法名，即可找到相关介绍。 第二部分：预备知识关于 Java： Java 是一门十分强大的语言，具有跨平台、安全等特点。Java语言得到广泛使用的一个重要原因是提供了丰富的类库，作为初学者你要养成多查阅和使用 Java 所提供的类的习惯，不要重复造轮子。在 pre 训练中，大家可以使用 Java 提供的相关容器，如 ArrayList、HashMap 等，会取得事半功倍的效果。 关于面向对象： 面向对象是一种主流的软件开发方法，也是一种思维方式，其核心是识别类，并在类之间建立层次式的协作关系。面向对象思维需要逐步养成，是本课程的核心目标。作为 pre ，主要还是通过一些小的迭代式练习来初步感受面向对象方法。因为 pre 训练题目相对比较简单，通过传统上的结构化程序开发方法也可以实现代码，甚至可以只写一个函数就能完成任务，但希望大家不要这样做。千里之行，始于足下，希望大家从一开始就体会面向对象开发的特点，这也是 pre 训练的重要目标。 关于容器： 在 Java 中，我们有更强大的“数组”——容器，它提供了更多管理多个对象的方法。和数组相比，容器可以动态控制容量、方便地增加或删除元素、方便地对元素进行进一步的管理（以 ArrayList 为例，更多操作可以参考 ArrayList - JDK Documentation） 在开始前，你需要先了解 java 的基础语法，包括表达式、for 循环、if 语句、输入输出、类，并学会编译运行 java 程序，Java 语言的很多成分都和 C 语言相似。 在任务迭代的开发过程中，会不可避免的涉及到变量名更改的问题，请尽量利用 IDEA 提供的重命名工具(Shift + F6)，不要自己手动一个个改。 第三部分：基本概念一、从 C 到 Java其实无论是 while、for 还是 if， switch，Java 与 C 基本上都是相同的，在你的简单预习中相信也发现了这个现象。在我们正式开始完成任务之前，再在 Java 与 C 关联的方面做一些简单介绍。 如下例子所示，Java 中的方法 public static void main(String[] argv)，就相当于C语言的入口函数main() 。这个 main 是你 Java 主程序的执行入口，当运行 Java 程序时，你可以理解成将会从此处开始执行。事实上，可以有多个类中包含 main 方法，我们可以手动制定一个类中的 main 方法作为程序入口。因此，main方法所在类的类名称也可以不是例子中的 MainClass。 为了方便评测，在 OO 课程中，请你保证 main 方法出现且只出现在一个类中。 import java.util.Scanner; public class MainClass { public static void main(String[] argv) { Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(); double b = scanner.nextDouble(); String c = scanner.next(); System.out.println(\"Hello world!\"); System.out.println(c + b + a); } } 现在我们可以运行一下这个程序，程序中已经包含了 Java 程序的输入输出方式，你也可以换一些组合方式，来进一步体会 Java 的输入输出。 二、构造一个类现在我们要正式开始本次任务了，在本次任务中我们希望构造一个 Bottle 类，来表示冒险者需要的物品，要求 Bottle 类包含以下属性：标识(id: 整数)，名字(name: 字符串)，价格(price: 整数)，容量(capacity: 浮点数)，和表达瓶子是否装满的标志量(filled: 布尔值)。 从某种意义上来说，只包含属性的类其实与 C 语言的结构体是很相似的。 以 Bottle 举例，构造一个类，代码如下： class Bottle { private int id; private String name; private long price; private double capacity; private boolean filled; public int getId(){ return this.id; } public void setId(int id){ this.id=id; } } 我们会发现，所有属性均是私有的，外部完全看不到它们，这时，如果在主类中声明了一个 Bottle 的实例 bottle ，无法对 name 进行 bottle.name 的操作。如前所述，面向对象开发强调封装和私有保护，我们一般不允许把属性定义成 public 的。面向对象方法的基本特点是私有化保护内部数据，暴露对数据的必要操作接口，多数情况下可以提供 setter-getter 方法。但是需要注意，如果某个属性的取值不能允许外部进行无限制的修改，就不能提供公开的 setter 方法。 那么现在就是练习时间啦，请你把所有属性都私有化，将 Bottle 封装起来！并配置好相应的方法让他们能够被外部更改和访问。 小 tips：在之后的作业中，如果你对很多变量都需要重复实现 get 和 set 方法，挨个输入比较麻烦，有兴趣搜索一下 IDEA 的一键生成方法（generate) 功能，高效编码 三、实例化我们现在拥有了一个 Bottle 类，那么问题来了，怎么在 MainClass 里引用他呢？我们可以把 Bottle 想像成一个像 int、char 一样的变量类型。那么我们就可以使用这条语句：Bottle bottle; 来声明一个Bottle变量了。在Java中，声明的对象变量就像是C语言中的一个结构体指针，如果你不对其初始化那么这个变量就会指向一个 null 量，代表这是一个空指针，此时还没有任何内存空间被分配用于存储一个Bottle的信息，你还需要使用构造函数实例化一个对象。 代码如下： public class MainClass { public static void main(String[] argv) { Bottle bottle = new Bottle(); //new Bottle() 即构造函数 bottle.setName(\"Cola\"); bottle.setPrice(3); bottle.setId(1); bottle.setCapacity(100.0); bottle.setFilled(true); } } 构造函数的用途是在你需要创建一个对象的时候完成一些初始化工作，并给对象的所有属性赋予初始值。 虽然 Java 语言默认为每个类提供一个缺省的构造方法，但是你并不确定这个缺省构造方法把每个属性设置成什么初值。对于上述的 Bottle 缺省构造方法而言，把 id 初始化为 0，把 price 初始化为 0，把 name 初始化为 null，把 capacity 初始化为0.0，把 filled 初始化为 false。我们建议显式方式来实现自己所需的合适的构造方法，确保得到的对象初始状态直观可见且可控。 在类中以“public 类名(参数列表)”的方式定义的函数就是构造函数。 这里举一个长方体类的例子： public class CuboidBox { private double length; private double width; private double height; // 构造函数 public CuboidBox(double length, double width, double height) { this.length = length; this.width = width; this.height = height; } } 那么现在就是练习时间啦，请你为 Bottle 写一个构造函数，要求该构造函数可以传入四个参数为 Bottle 赋值，同时需要初始化是否装满变量 filled 为 true。 四、容器既然我们拥有了装满药水的瓶子对象，那么自然也要拥有能够持有与使用它的人，这就是我们的冒险者。然而冒险者从来都得准备充分：在怪物面前若只有一瓶恢复药水，难免会疲于招架。因此冒险者可能会携带多个瓶子。那么，应当如何管理这些瓶子对象呢？ 能够想到，数组可以完成这样的管理。不过在 Java 中，我们有更强大的“数组”——容器，它提供了更多管理多个对象的方法。以 ArrayList 为例，一个冒险者身上的瓶子可以以如下方式管理： public class MainClass { public static void main(String[] args) { // 以 ArrayList 为例，展示容器的用法 // 1. 创建容器。大部分容器都会随着元素的加入自动扩容。 ArrayList&lt;Bottle&gt; bottles = new ArrayList&lt;&gt;(); // 2. 加入一个元素 Bottle bottle = new Bottle(); bottles.add(bottle); // 3. 判断元素是否在容器内 if (bottles.contains(bottle)) { System.out.println(\"We have such a bottle!\"); } // 4. 遍历容器中的所有元素 for (Bottle item : bottles) { System.out.println(item.getName()); } // 5. 输出容器规模 System.out.println(bottles.size()); // 6. 删除一个元素 bottles.remove(bottle); } } 对于经常需要使用或添加药水瓶子的冒险者来说，使用容器是不二之选。注意到冒险者和瓶子同样是对象，并拥有一个 ID 与名字，因此我们可以将冒险者也封装为一个类： class Adventurer { private int id; private String name; private ArrayList&lt;Bottle&gt; bottles; } 除了 ArrayList 外，还有 HashMap、TreeMap、HashSet、TreeSet等常用容器。 第四部分：题目描述先介绍 pre1的背景故事。 想象你是一个冒险者，现在正在一个新的星球上进行探险，这个过程中你需要努力收集各种物品来不断增强自身能力值。在第一个 task 中你需要完成两个任务： 对基本物品 Bottle 和冒险者 Adventurer 进行建模 利用容器的知识，管理多个冒险者 首先，你需要构造一个 Bottle 类，来表示冒险者需要用到的瓶子类，要求 Bottle 类包含属性：ID，名字，价格，容量，和表达瓶子是否装满的标志量。 接着，再构造一个Adventurer类，用来表示冒险者类，要求Adventurer类包含属性：ID，名字，承载多个Bottle的容器。 在这个问题中，你需要管理多个冒险者。初始时，你没有需要管理的冒险者。接下来会有 1212 个操作： 加入一个需要管理的冒险者 给某个冒险者增加一个瓶子 删除某个冒险者的某个瓶子 更新某个冒险者所持有的某个瓶子的价格 更新某个冒险者所持有的某个瓶子是否装满 查询某个冒险者所持有的某个瓶子的名字 查询某个冒险者所持有的某个瓶子的价格 查询某个冒险者所持有的某个瓶子的容量 查询某个冒险者所持有的某个瓶子是否装满 输出某个冒险者所持有的某个瓶子的字符串描述 查询某个冒险者所持有瓶子的价格之和 查询某个冒险者所持有瓶子价格的最大值 操作1-5不需要任何输出，只需要对操作 6-12 进行输出回答。 第五部分：输入/输出格式第一行一个整数 mm，表示操作的个数。 接下来的 mm 行，每行一个形如 {type} {attribute} 的操作，{type} 和 {attribute} 间、若干个 {attribute} 间使用若干个空格分割，操作输入形式及其含义如下： type attribute 意义 输出文本 1 {adv_id} {name} 加入一个 ID 为 {adv_id}、名字为 {name} 的冒险者，且未持有任何瓶子 无 2 {adv_id} {bot_id} {name} {price} {capacity} 给 ID 为 {adv_id} 的冒险者增加一个瓶子，瓶子的 ID、名字、价格、容量分别为 {bot_id}、{name}、{price}、{capacity}，且默认为已装满 无 3 {adv_id} {bot_id} 将 ID 为 {adv_id} 的冒险者的 id 为 {bot_id} 的瓶子删除 无 4 {adv_id} {bot_id}{price} 将 ID 为 {adv_id} 的冒险者的 id 为 {bot_id} 的瓶子的价格更改为 {price} 无 5 {adv_id} {bot_id}{filled} 将 ID 为 {adv_id} 的冒险者的 id 为 {bot_id} 的瓶子的装满的状态更改为 {filled} 无 6 {adv_id} {bot_id} 查询ID 为 {adv_id} 的冒险者的 id 为 {bot_id} 的瓶子的名字 一个字符串，表示瓶子名字 7 {adv_id} {bot_id} 查询ID 为 {adv_id} 的冒险者的 id 为 {bot_id} 的瓶子的价格 一个整数，表示瓶子价格 8 {adv_id} {bot_id} 查询ID 为 {adv_id} 的冒险者的 id 为 {bot_id} 的瓶子的容量 一个浮点数，表示瓶子容量 9 {adv_id} {bot_id} 查询ID 为 {adv_id} 的冒险者的 id 为 {bot_id} 的瓶子是否装满 一个字符串，表示瓶子是否装满（输出true表示装满，false表示没有装满） 10 {adv_id} {bot_id} 查询ID 为 {adv_id} 的冒险者的 id 为 {bot_id} 的瓶子的字符串描述 以The bottle's id is {id}, name is {name}, capacity is {capacity}, filled is {filled}.的形式打印状态。 11 {adv_id} 查询 ID 为 {adv_id} 的冒险者所持有瓶子的价格之和 一个整数，表示瓶子价格之和 12 {adv_id} 查询 ID 为 {adv_id} 的冒险者所持有瓶子价格的最大值 一个整数，表示瓶子价格的最大值 一、数据范围与操作限制变量约束 变量 类型 说明 id (adv_id, bot_id) 整数 取值范围：0 - 2147483647 name 字符串 保证不会出现空白字符 price 长整数 在 long 精度范围内，且保证不小于 0 capacity 浮点数 在 double 精度范围内 操作约束 保证所有冒险者与瓶子的 ID 两两不同。 操作 2-12：保证冒险者 ID 一定存在。 操作 3-10：冒险者一定持有该 ID 的瓶子。 操作 11：若冒险者不持有任何瓶子，则输出 0。 操作 12：冒险者持有至少一个瓶子。 操作数满足 $1 \\leq m \\leq 2000$。 二、测评方法输出数值时，你的输出数值需要和正确数值相等。 假设你的输出值 $x_{out}$ 和正确数值 $x_{std}$ 之间的绝对或相对误差小于等于 $10 ^ {-5}$，则认为是相等的，即满足$$\\dfrac {|x_{std} - x_{out}|}{\\max(1, |x_{std}|)} \\leq 10^{-5}$$ 三、输入样例与输出样例样例输入 17 1 2 Co20ocvblT 1 30 Al8QnWnkS7 1 91 pqWY5UNcm4 2 91 7 q6DlfOJGzf 82 48.5801 2 30 8 0vyv58Ec49 25 12.1451 2 30 56 OdcdRFEw7s 13 34.3745 2 91 64 jMZ9uBOLy4 45 38.1122 2 2 65 COIecJNdIH 89 41.7995 2 2 26 UXDaKL9P1O 79 36.1887 2 91 15 Vy6EKNgojP 10 35.5545 3 91 7 4 30 56 67 5 91 15 true 6 2 65 7 91 15 8 2 26 9 91 15 样例输出 COIecJNdIH 10 36.1887 true 第六部分：提示 容器部分大家需要熟悉对容器的操作，题目中限制了所有对象（冒险者、瓶子）的 ID 不会相同，思考一下，哪种容器会更加适合本次任务？或者说哪些容器呢？ 在本次作业中我们有求和操作，尽管我们将输入数据限制在 long 的范围内，但是在求和时可能会超出精度范围。请你查阅 Java 相关资料，来看看在 Java 中是如何解决超过普通数据类型数据范围的精度问题的。 Java 中有些特别的类用于处理大数运算，如 BigInteger，BigDecimal。 数据类型的边界可以使用类中的常量，例如Long.MIN_VALUE表示long类型（或Long类型）的最小值。 操作10要求输出特定的Bottle类型实例的属性，建议在 Bottle 类中重写toString 方法，示例如下： class Bottle { private int id; // ... @Override public String toString() { return \"The bottle's id is \" + id + \".\"; } } class Main { public static void main(String[] argv) { Bottle bottle = new Bottle(); // ... System.out.println(bottle); } } /** * 输出: * The bottle's id is 1. */ java.io.PrintStream.println(Object x)函数将调用String.valueOf(x)以获得实例x的字符串描述，而java.lang.String.valueOf(Object x)函数将在x不为null时返回x.toString()，因此我们可以通过重写toString方法使println函数输出自定义格式的“实例属性”。详见 println() - JDK Documentation 和 valueOf() - JDK Documentation 。 第一次实验数据点击下载","author":"OOpre"},{"title":"第五次作业指导书","date":"2022-12-31T16:00:00.000Z","updated":"2023-01-02T10:03:53.418Z","comments":true,"path":"oopre/hw5.html","permalink":"https://toby-shi-cloud.github.io/oopre/hw5.html","excerpt":"","text":"第五次作业指导书第一部分：训练目标 学习正则表达式捕获组和模糊匹配，非贪婪匹配等知识，并依此实现更加高级的检索功能。 第二部分：预备知识 本次作业的完成可能需要用到的知识如下。 捕获组 关于正则表达式的捕获：当我们想要获取正则表达式里的某些指定的内容时，可以利用捕获组来进行操作，通过group()方法捕获想要的内容。 详细内容可以参考 贪婪匹配和非贪婪匹配 关于模糊匹配和非贪婪匹配模式：对于表达式中间可能出现的无关紧要的部分，我们通常采用模糊匹配来进行处理。同时，由于性能原因，我们建议大家使用非贪婪模式进行匹配。 我们通常使用.*?来表示非贪婪模式，其中.表示任意字符，*?表示重复任意次，但尽可能少重复。顾名思义，非贪婪模式就是在能使整个匹配成功的前提下匹配最少的字符，比如如果将a.*?b应用在aabab中，我们匹配到的会是aab和ab。 关于非贪婪匹配模式还有一些其他表示方式可供参考： 代码 说明 *？ 重复任意次，但尽可能少重复 +？ 重复1次或更多次，但尽可能少重复 ？？ 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 相关详细内容可以参考 参考资料1 参考资料2 第三部分：基本概念 概念 定义 子序列 将字符串中零个或多个字符去掉后所得结果，一个字符串 abc 的子序列有 a, b, c, ab, ac, bc, abc 子串 字符串中任意个连续的字符组成的子序列 前缀 包含第0个字符的子串 后缀 包含最后一个字符的子串 第四部分：题目描述 形式化来说，消息可能被表现成以下三种模式： 给个人的消息：yyyy/MM/dd-sender@receiver :\"message_content\"; 2021/07/12-student@teacher :\"can i pass the exam?\"; 本消息为发送给个人的消息，指定了接收者teacher。 群聊中的消息，指定了接收者：yyyy/MM/dd-sender:\"message_content\";，其中message_content内包含@receiver 2021/07/12-student:\"can i pass the exam?@teacher \"; 本消息为在群聊中发送的消息，指定了接收者teacher。 群聊中的消息，未指定接收者：yyyy/MM/dd-sender:\"message_content\"; 2021/07/12-student:\"can i pass the exam?\"; 本消息为在群聊中发送的消息，未指定接收者。 有些用户喜欢在群聊或聊天中使用昵称，比如名为 “小枫”的用户可以有昵称 “小小枫”、“小枫枫”。 用户名或备注的前缀或后缀可能含有一些特殊含义，比如“2006 张一一”、“2006 刘一一”、“王一一 19级”、“陈一一 20级”，其中的数字代表着年，隐含着当年入学或入职等信息。 在查询时，我们同样不可能每次都能精准地记得所需消息的日期，接收方以及发送方的姓名，因此在这里我们需要实现模糊查询的功能。 请编写程序读入消息，并根据输入的查询找出对应的消息。 查询指令将在原有基础上作如下调整。 qdate指令输入的日期可能不是完整的日期，具体地，所有可能的日期格式有yyyy/MM/dd, yyyy/MM/, yyyy//dd, /MM/dd, //dd, /MM/, yyyy//，你需要输出所有符合输入日期的消息。例如若输入qdate /07/03，则你需要输出所有在07/03发布的消息，无论消息在哪一年发出。其余格式同理。 qsend和qrecv将加入参数-v表示模糊搜索，类似于我们的命令行，当输入qsend -v和qrecv -v时表示对后面输入的内容进行模糊搜索，该次作业中，我们规定，输入 qsend -v \"str\"或qrecv -v \"str\"，表示检索以str为子串的名称，具体详见样例。当-v缺省时表示含义与第一次作业相同，即”精确匹配“。 第五部分：输入/输出说明输入格式 前若干行为消息内容，以一行END_OF_MESSAGE结尾。其中一行内可能有多条消息，每条消息之间和每行末尾可能存在若干空白字符（空格和制表符\\t）。 其后为多条查询语句，每行一条。 查询指令有且仅有qdate,qrecv,qsend，格式参照上述。 输出格式 对于每一条询问，输出指定消息（输入数据中可能存在多条消息符合条件，此时按照原顺序、原格式输出全部符合条件的消息）。 输出中每条消息均单独占据一行。 输入样例12021/7/1-Jack@JayChou :\"Hello! mydear.\";2021/7/3-JayChou@buaaer :\"nice to meet you.\"; 2021/7/5-JayChou@Mike :\"emmmm..., I am sorry.\"; 2021/7/6-JayChou@Mike :\"emmmm..., I do not want to talk to you.\"; 2020/7/8-JayChou@buaaer :\"Hahaha! see you again\"; 2020/7/8-JayChou@Sabbaty :\"Hahaha! Sabbaty, come to the center!\"; 2021/6/8-JayChou:\"I am JayChou!\"; 2021/7/11-JayChou:\"I love you!\"; 2021/1/1-JayChou:\"Hi@c \"; END_OF_MESSAGE qsend \"Jack\" qsend -v \"Ja\" qrecv \"buaaer\" qrecv -v \"e\" 输出样例12021/7/1-Jack@JayChou :\"Hello! mydear.\"; 2021/7/1-Jack@JayChou :\"Hello! mydear.\"; 2021/7/3-JayChou@buaaer :\"nice to meet you.\"; 2021/7/5-JayChou@Mike :\"emmmm..., I am sorry.\"; 2021/7/6-JayChou@Mike :\"emmmm..., I do not want to talk to you.\"; 2020/7/8-JayChou@buaaer :\"Hahaha! see you again\"; 2020/7/8-JayChou@Sabbaty :\"Hahaha! Sabbaty, come to the center!\"; 2021/6/8-JayChou:\"I am JayChou!\"; 2021/7/11-JayChou:\"I love you!\"; 2021/1/1-JayChou:\"Hi@c \"; 2021/7/3-JayChou@buaaer :\"nice to meet you.\"; 2020/7/8-JayChou@buaaer :\"Hahaha! see you again\"; 2021/7/3-JayChou@buaaer :\"nice to meet you.\"; 2021/7/5-JayChou@Mike :\"emmmm..., I am sorry.\"; 2021/7/6-JayChou@Mike :\"emmmm..., I do not want to talk to you.\"; 2020/7/8-JayChou@buaaer :\"Hahaha! see you again\"; 输入样例22021/7/1-Jack@JayChou :\"Hello!\";2021/7/3-JayChou@buaaer :\"Hahaha\"; 2021/7/5-JayChou@Mike :\"emmmm\"; 2020/7/8-JayChou@buaaer :\"Hahaha\"; 2021/6/8-JayChou:\"Hahaha\"; END_OF_MESSAGE qdate 2021/7/1 qdate 2021// qdate /7/ qdate //1 qdate 2021/7/ qdate /7/1 输出样例22021/7/1-Jack@JayChou :\"Hello!\"; 2021/7/1-Jack@JayChou :\"Hello!\"; 2021/7/3-JayChou@buaaer :\"Hahaha\"; 2021/7/5-JayChou@Mike :\"emmmm\"; 2021/6/8-JayChou:\"Hahaha\"; 2021/7/1-Jack@JayChou :\"Hello!\"; 2021/7/3-JayChou@buaaer :\"Hahaha\"; 2021/7/5-JayChou@Mike :\"emmmm\"; 2020/7/8-JayChou@buaaer :\"Hahaha\"; 2021/7/1-Jack@JayChou :\"Hello!\"; 2021/7/1-Jack@JayChou :\"Hello!\"; 2021/7/3-JayChou@buaaer :\"Hahaha\"; 2021/7/5-JayChou@Mike :\"emmmm\"; 2021/7/1-Jack@JayChou :\"Hello!\"; 输入样例32022/07/04-Jack:\"I have a leading zero.\"; 2022/7/4-Jack:\"I dont have leading zero\"; 2022/7/04-Jack:\"We have the same meaning!\"; END_OF_MESSAGE qdate 2022//4 qdate /07/04 输出样例32022/07/04-Jack:\"I have a leading zero.\"; 2022/7/4-Jack:\"I dont have leading zero\"; 2022/7/04-Jack:\"We have the same meaning!\"; 2022/07/04-Jack:\"I have a leading zero.\"; 2022/7/4-Jack:\"I dont have leading zero\"; 2022/7/04-Jack:\"We have the same meaning!\"; 第六部分：限制说明 一行输入中可能包含多条消息，但一条消息只会完整地出现在一行内。 每条消息之间和每行末尾可能存在若干空白字符作为分隔（空格和制表符\\t），也可能不存在。 保证所有的消息和指令符合格式。 保证输入的日期、用户名、正文都非空。 对于日期，保证 $year \\in [0, 9999], mounth \\in [1, 12], day \\in [0,31]$。日期中可能存在前导0，比如1月可以表示为01月，258年可以表示为0258年，且保证日期合法。以及包括前导0在内，年份的位数不超过4位，月、日的位数不超过两位（这条与上次作业不同） qdate指令保证输入的日期中年月日三个参数不同时缺省 发送者和接收者的用户名仅由大小写英文字母、数字组成。 正文内容仅由大小写英文字母、数字、空格、四种标点符号（? ! , .）构成。 输入数据中所有内容均对大小写敏感。 如果一条消息中存在@用户的情况（对应前两种消息模式），则保证该信息中@+用户名结构后面一定有一个空格，而且@用户最多只会在一个消息中出现一次。 输入数据不超过300行 输入数据每行不超过10个消息 输入数据总询问数不超过100条 第七部分：提示与警示提示 日期的前导0并不影响日期本身的含义，查询时请按照日期本身的语义进行查询。具体可见我们给出的样例。 警示不要试图Hack评测机，不要抄袭。如发现其他人的代码疑似存在上述行为，可向课程组举报。课程组感谢同学们为课程建设所作出的贡献。 第五次实验数据点击下载","author":"OOpre"},{"title":"第三次作业指导书","date":"2022-12-31T16:00:00.000Z","updated":"2023-01-02T10:03:26.824Z","comments":true,"path":"oopre/hw3.html","permalink":"https://toby-shi-cloud.github.io/oopre/hw3.html","excerpt":"","text":"第三次作业指导书第一部分：训练目标 学习接口相关知识，并实践如何使用接口来建立行为层次结构。 学会使用 Java 类库提供的类进行排序。 掌握容器的克隆方法，理解浅克隆 (Shallow copy) 和 深克隆 (Deep copy) 初步了解 git 分支的用法 第二部分：预备知识一、接口前面我们提到了子类可以重写父类的方法，这使得子类的方法可以在父类的方法的基础上增加功能，或者实现一套和父类不同的新的功能。 倘若父类的抽象程度很高，以至于在父类中没有办法去编写一个实现具体功能的方法，我们可能会想是不是可以不写方法的具体实现语句，只定义方法签名呢？ 比方说，正方形和圆形的面积计算很具体，假设为正方形和圆形建立了一个共同的抽象父类二维图形，此时如何去实现一个二维图形的面积呢？ 比如下面的例子： class Square { private double length; public double getArea() { //你可以为一个正方形编写求面积方法 return length * length; } } class Circle { private double radius; public double getArea() { //你可以为一个圆形编写求面积方法 return radius * radius * Math.PI; } } 很显然，我们无法为抽象的二维图形Shape类实现面积求解方法。此时，我们可以使用接口(Interface)来表示这个抽象的类，然后声明上述两个具体的类实现(implements)了这个接口： interface Shape { public double getArea(); // 你不能为抽象的`形状`概念定义求面积方法 } class Square implements Shape { private double length; public Square(double length) { this.length = length; } @Override public double getArea() { //你可以为一个正方形编写求面积方法 return length * length; } } class Circle implements Shape { private double radius; public Circle(double radius) { this.radius = radius; } @Override public double getArea() { //你可以为一个圆形编写求面积方法 return radius * radius * Math.PI; } } 之后，你可以用接口类型来引用实现了该接口的任意类型的实例化对象，并调用接口所声明的方法。需要注意的是，你不能用接口类型来实例化一个对象： class Main { public static void main(String[] args) { Shape myShape; // 声明一个Shape的变量， 这是还没有任何实例产生 myShape = new Square(888); // 创建一个Square的实例，用myShape变量引用它。 System.out.println(myShape.getArea()); myShape = new Circle(888); // 创建一个Circle的实例，用myShape变量引用它。 System.out.println(myShape.getArea()); myShape = new Shape(); // Shape的概念过于抽象以至于实例化没有意义，这一行编译报错。 } } 需要注意的是，接口提供了行为的抽象机制。在上面的例子中，Square和Circle的共性在于其行为操作，因而使用接口是合适的。对于其他一些情况，多个类之间可能即有共性的行为，也有共性的数据属性，此时使用类建立抽象层次更加合适。 在编程时，尽量使用高层次的引用（比如抽象类的引用和接口的引用），避免使用实际子类型的引用的方式，叫做面向抽象编程。下面我们会通过本 Task 让大家体会这一点。 二、浅克隆与深克隆前面已经提到，在 Java 中，我们使用引用 (reference) 来操作一个对象。这表明，当我们在程序中写出形如 Bottle bottle 时，我们所声明的 bottle 变量只是一个引用，他可能会引用所有类型正确的实例。因此，如果我们需要对一个实例进行复制操作，就需要仔细考虑复制的是引用还是实例。请看下面的程序片段： class Main { public static void main(String[] args) { Shape shape1 = new Square(888); Shape shape2; shape2 = shape1; // 试图复制一个实例 shape1.setArea(1); // 更改 shape1 引用的实例 System.out.println(shape2.getArea()); // 输出 shape2 引用的实例 } } /** * 输出： * 1 **/ 我们可以发现，上面的程序只是对引用进行了克隆。上面的程序首先创建了一个 Square 实例，并使用 shape1 引用它。之后声明变量 shape2，并让 shape2 引用了 shape1 所引用的实例。我们只创建了一个实例，shape1 和 shape2 均为同一个实例的引用。因此，通过 shape1 引用对实例进行的修改，也会在使用 shape2 访问该示例时体现。 上面的这种只克隆引用的克隆过程，称为 浅克隆 (Shallow copy)。如果希望创造出一个“完整”的克隆，我们不仅要在编码时创建一个新的引用，还要创建一个新的实例： class Main { public static void main(String[] args) { Shape shape1 = new Square(888); Shape shape2 = new Square(); shape2.setArea(shape1.getArea()); System.out.println(\"shape1: \" + shape1.getArea() + \", shape2: \" + shape2.getArea()); shape2.setArea(1); System.out.println(\"shape1: \" + shape1.getArea() + \", shape2: \" + shape2.getArea()); } } /** * 输出： * shape1: 888, shape2: 888 * shape1: 888, shape2: 1 **/ 这种克隆引用和实例的克隆过程，称为 深克隆 (Deep copy)。 三、容器中的克隆我们已经了解到，Java 使用引用来操作实例，这导致克隆时既可以克隆引用，也可以克隆实例，即深克隆和浅克隆。在之前的两次作业中，同学们已经学会了容器的基本使用方法。容器提供了管理多个对象的方法，字如其名，容器中”容纳了若干个对象”。在拷贝容器时，深拷贝和浅拷贝的区别将会加大。 现在请大家思考，一个对象是否可以位于多个容器中呢？答案是肯定的，这是因为 Java 中只能使用引用来操作实例，容器也不例外；每个容器维护的是若干个实例的 引用。因此，如果我们希望将一个容器进行拷贝，我们有两种方法： 使用浅拷贝，拷贝出的另一个容器管理的 引用 与原容器相同 使用深拷贝，先拷贝出该容器中管理的所有实例，再依次添加至新容器中 假设现在有一个名为 advs 的 ArrayList 容器，该容器管理了若干个 Adventurer 类型对象的引用。由于 Java 中所有类型都继承于 Object 类，该类拥有 clone 方法，因此我们使用 advs.clone() 对该容器进行克隆： advs.get(0).setName(\"Old Name\"); ArrayList&lt;Adventurer&gt; advsClone = advs.clone(); advsClone.get(0).setName(\"New Name\"); System.out.println(advs.get(0).getName()); /** * 输出： * New Name **/ 可以发现，这是一个浅克隆，只克隆了容器中的引用，而没有克隆 Adventurer 对象。在 ArrayList.clone() 文档中已明确说明，该方法返回一个浅克隆的新容器： public Object clone() Returns a shallow copy of this ArrayList instance. (The elements themselves are not copied.) 如果希望对容器每个对象本身都进行克隆，则需要遍历该容器，克隆其中的每个对象，并添加至新容器中。 在对容器进行克隆操作时，需要特别注意是否需要进行深克隆。 第三部分：基本要求本次作业是本单元最后一次作业，仍需在上一次作业的基础上进行增量开发。 在本任务中，我们允许冒险者雇佣并使用另一个冒险者，且赋予冒险者价值的概念，把装备和冒险者都看作是价值体 commodity。同时，我们还要对冒险者游戏增加版本管理功能，与 git 版本管理工具进行类比，可将冒险者游戏的状态视为需要管理的数据，每执行一条指令视为进行一次 commit，并实现简单的新建分支、检出分支功能。 第四部分：题目描述 增加 Commodity 接口，并使冒险者 Adventurer 类和装备 Equipment 类实现 Commodity 接口。接口中应定义冒险者和装备的共有方法，包括 useBy 方法等。 将原先的冒险者持有的 装备 的容器，更改为 价值体 的容器（即该容器可以容纳所有实现了 Commodity 接口的类）。 定义冒险者的价值为其拥有的所有价值体的价值之和，即冒险者的价值是其装备的价值及其雇佣的冒险者的价值的和。 增加冒险者之间的雇佣关系：冒险者 A 雇佣冒险者 B，可以认为是把冒险者 B 看成一种价值体。此时冒险者 A 拥有价值体冒险者 B，之后冒险者 A 便可以像使用其他装备一样使用冒险者 B。 定义冒险者 A 使用冒险者 B，其效果为冒险者 A 按照价值从大到小、价值相同则按价值体 id 从大到小的顺序 依次使用冒险者 B 的价值体，价值体的价值指的是所有价值体在本次使用前的价值。我们规定：如果当前使用到了冒险者 B 雇佣的冒险者 C，则冒险者 C 要按照如上顺序使用其拥有的价值体，这些价值体将作用于最开始使用的冒险者，在此处即为冒险者 A。 新增版本管理功能：我们仿照 git 中的分支机制进行版本管理。将每一条执行的指令视为一次 commit，初始状态下默认分支名称为1，需要支持“创建分支并检出该分支”功能，以及“检出”功能。与 git 相同，每次 commit 都将移动当前 HEAD 指针所指向的分支指针，也就是说，假设当前处于 br 分支，执行了若干条指令（相当于在 br 分支上进行了若干条 commit）后，br 分支也会发生更改。 第五部分：输入/输出格式第一行一个整数 mm，表示操作的个数。 接下来的 mm 行，每行一个形如 {type} {attribute} 的操作，{type} 和 {attribute} 间、若干个 {attribute} 间使用若干个空格分割，操作输入形式及其含义如下： 对 Task2 中的一些指令进行少量修改，重点地方已经加粗，并新增三条指令 10 ～ 12： type attribute 指令含义 输出 1 {adv_id} {name} 加入一个 ID 为 {adv_id}、名字为 {name} 的冒险者，且未持有任何装备 无 2 {adv_id} {equipment_type} {vars}（equipment_type和vars的含义见下表） 给予某个人某件装备，装备类型由 {equipment_type} 定义，属性由 {vars} 定义，所有的瓶子初始默认装满 无 3 {adv_id} {id} 删除 ID 为 {adv_id} 的冒险者的 ID 为 {id} 的价值体 如果被删除的价值体是冒险者，则解除雇佣关系，后续无法使用该被被解除了雇佣关系的冒险者 如果删除的价值体是装备，则丢弃该装备，后续该冒险者无法使用该装备 无 4 {adv_id} 查询 ID 为 {adv_id} 的冒险者所持有价值体的价格之和 如果价值体是装备，则价值就是 price 如果价值体是冒险者，则其价值计算按照本 Task 最开始定义的规则 一个整数，表示某人所有价值体的价值总和 5 {adv_id} 查询 ID 为 {adv_id} 的冒险者所持有价值体价格的最大值 如果价值体是装备，则价值就是 price 如果价值体是冒险者，则其价值计算按照本 Task 最开始定义的规则 一个整数，表示该冒险者所有价值体价格的最大值 6 {adv_id} 查询 ID 为 {adv_id} 的冒险者所持有的价值体总数 如果价值体是装备，则对总数的贡献是 1 如果价值体是冒险者，则只要考虑被雇佣冒险者本身这一个价值体即可，不需要考虑被雇佣冒险者所拥有的其他价值体，即对总数的贡献也是 1。 一个整数，表示某人所有价值体的数量之和 7 {adv_id} {commodity_id} 打印 ID 为 {commodity_id} 的价值体的全部属性 该价值体的全部属性，格式见下文“属性打印方式” 8 {adv_id} ID 为 adv_id 的冒险者按照价值由大到小的顺序使用其全部价值体，若价值相同则按照价值体的 id 由大到小的顺序使用。（ 价值体价值为所有价值体本次使用前的价值） 若当前使用的是价值体是装备，这次使用的效果同 Task2 中的规定 若当前使用的价值体是冒险者，这次使用的效果已在 第四部分 中规定。 每个价值体在使用时就会产生输出，除此之外无额外输出 9 {adv_id} 打印 ID 为 {adv_id} 的冒险者的当前状态。 一个字符串表示冒险者的状态： The adventurer’s id is {adv_id}, name is {name}, health is {health}, exp is {exp}, money is {money}. 10 {adv_id1} {adv_id2} ID 为adv_id1的冒险者雇佣 ID 为adv_id2的冒险者 无 11 {branch_name} 在当前状态新建分支，分支名称为 branch_name。 与 git 类比，相当于在当前状态创建一个名为 branch_name 的分支，并检出该分支：git branch ${branch_name} &amp;&amp; git checkout ${branch_name} 或 git checkout -b ${branch_name} 无 12 {branch_name} 切换到版本名称为 branch_name 的分支，之后的更改也将应用于该分支，详见“题目描述”部分。 与 git 类比，相当于检出名为 branch_name 的分支：git checkout ${branch_name} 无 vars 和 equipment_type 如下： 装备类型 equipment_type vars Bottle 1 id name price capacity HealingPotion 2 id name price capacity efficiency ExpBottle 3 id name price capacity expRatio Sword 4 id name price sharpness RareSword 5 id name price sharpness extraExpBonus EpicSword 6 id name price sharpness evolveRatio 属性打印方式表格： 价值体类型 属性打印方式 Bottle The bottle’s id is {id}, name is {name}, capacity is {capacity}, filled is {filled}. HealingPotion The healingPotion’s id is {id}, name is {name}, capacity is {capacity}, filled is {filled}, efficiency is {efficiency}. ExpBottle The expBottle’s id is {id}, name is {name}, capacity is {capacity}, filled is {filled}, expRatio is {expRatio}. Sword The sword’s id is {id}, name is {name}, sharpness is {sharpness}. RareSword The rareSword’s id is {id}, name is {name}, sharpness is {sharpness}, extraExpBonus is {extraExpBonus}. EpicSword The epicSword’s id is {id}, name is {name}, sharpness is {sharpness}, evolveRatio is {evolveRatio}. Adventurer（新增） The adventurer’s id is {id}, name is {name}, health is {health}, exp is {exp}, money is {money}. 一、数据范围与操作限制变量约束 变量 类型 说明 id, adv_id, adv_id1, adv_id2, commodity_id 整数 取值范围：0 - 2147483647 name 字符串 保证不会出现空白字符 装备的 price 长整数 在 long 精度范围内，且保证不小于0 capacity, efficiency, expRatio, sharpness, extraExpBonus, evolveRatio, health, exp, money 浮点数 在 double 精度范围内 branch_name 字符串 只包含数字和字母 操作约束 操作数满足 $1 \\leq m \\leq 2000$。 保证所有价值体的 ID 两两不同。 操作2-9：冒险者 ID 一定存在。 操作 3,7：冒险者一定持有该 ID 的价值体。 操作 4,6：冒险者不持有任何价值体，则输出 0。 操作 5：冒险者一定持有至少一个价值体。 操作 10：雇佣和被雇佣的冒险者均已存在，且不是同一个冒险者。 指令 11：新建的 branch_name 不与已有的 branch_name 重名。 指令 12：检出的 branch_name 之前一定被新建过。 冒险者的雇佣关系不会存在循环雇佣的情况，每个冒险者最多仅能被一个其他冒险者雇佣一次。 初始状态下位于 branch_name 为 1 的分支。 二、测评方法输出数值时，你的输出数值需要和正确数值相等。 假设你的输出值 $x_{out}$ 和正确数值 $x_{std}$ 之间的绝对或相对误差小于等于 $10 ^ {-5}$，则认为是相等的，即满足$$\\dfrac {|x_{std} - x_{out}|}{\\max(1, |x_{std}|)} \\leq 10^{-5}$$ 三、输入输出示例样例1输入： 19 1 2 Co20ocvblT 1 30 Al8QnWnkS7 1 91 pqWY5UNcm4 2 91 1 26 6DlfOJGzfY 74 96.3964 2 2 6 35 yv58Ec49pK 2 65.161 68.6988 2 2 1 71 FEw7siBqbW 64 66.534 2 91 2 44 OLy4CqtmrO 45 60.135 13.2503 2 30 1 56 H2EvYaqUXD 0 64.7676 2 91 6 65 Wjsn3jVy6E 60 20.1061 23.1743 2 2 2 28 0WnMAYPzUH 37 27.0554 10.4833 10 30 91 10 91 2 3 30 56 4 30 5 91 6 2 7 2 28 8 2 9 2 输出： 282 103 3 The healingPotion's id is 28, name is 0WnMAYPzUH, capacity is 27.0554, filled is true, efficiency is 10.4833. Co20ocvblT drank FEw7siBqbW and recovered 6.6534. Co20ocvblT drank 0WnMAYPzUH and recovered 2.70554. Co20ocvblT recovered extra 283.62987482. Co20ocvblT used yv58Ec49pK and earned 65.161. yv58Ec49pK's sharpness became 4476.4825068. The adventurer's id is 2, name is Co20ocvblT, health is 382.98881482, exp is 10.0, money is 65.161. 样例2输入： 30 1 2 Co20ocvblT 1 30 Al8QnWnkS7 1 91 pqWY5UNcm4 2 91 1 26 6DlfOJGzfY 74 96.3964 2 2 6 35 yv58Ec49pK 2 65.161 68.6988 2 2 1 71 FEw7siBqbW 64 66.534 2 91 2 44 OLy4CqtmrO 45 60.135 13.2503 2 30 1 56 H2EvYaqUXD 0 64.7676 2 91 6 65 Wjsn3jVy6E 60 20.1061 23.1743 2 2 2 28 0WnMAYPzUH 37 27.0554 10.4833 11 2 10 30 91 10 91 2 3 30 56 4 30 5 91 6 2 7 2 28 8 2 9 2 12 1 10 30 91 10 91 2 3 30 56 4 30 5 91 6 2 7 2 28 8 2 9 2 输出： 282 103 3 The healingPotion's id is 28, name is 0WnMAYPzUH, capacity is 27.0554, filled is true, efficiency is 10.4833. Co20ocvblT drank FEw7siBqbW and recovered 6.6534. Co20ocvblT drank 0WnMAYPzUH and recovered 2.70554. Co20ocvblT recovered extra 283.62987482. Co20ocvblT used yv58Ec49pK and earned 65.161. yv58Ec49pK's sharpness became 4476.4825068. The adventurer's id is 2, name is Co20ocvblT, health is 382.98881482, exp is 10.0, money is 65.161. 282 103 3 The healingPotion's id is 28, name is 0WnMAYPzUH, capacity is 27.0554, filled is true, efficiency is 10.4833. Co20ocvblT drank FEw7siBqbW and recovered 6.6534. Co20ocvblT drank 0WnMAYPzUH and recovered 2.70554. Co20ocvblT recovered extra 283.62987482. Co20ocvblT used yv58Ec49pK and earned 65.161. yv58Ec49pK's sharpness became 4476.4825068. The adventurer's id is 2, name is Co20ocvblT, health is 382.98881482, exp is 10.0, money is 65.161. 样例3输入： 23 1 2 Co20ocvblT 1 30 Al8QnWnkS7 12 1 1 91 pqWY5UNcm4 2 91 1 26 6DlfOJGzfY 74 96.3964 2 2 6 35 yv58Ec49pK 2 65.161 68.6988 2 2 1 71 FEw7siBqbW 64 66.534 2 91 2 44 OLy4CqtmrO 45 60.135 13.2503 12 1 2 30 1 56 H2EvYaqUXD 0 64.7676 2 91 6 65 Wjsn3jVy6E 60 20.1061 23.1743 2 2 2 28 0WnMAYPzUH 37 27.0554 10.4833 10 30 91 10 91 2 3 30 56 4 30 12 1 5 91 6 2 7 2 28 12 1 8 2 9 2 输出： 282 103 3 The healingPotion's id is 28, name is 0WnMAYPzUH, capacity is 27.0554, filled is true, efficiency is 10.4833. Co20ocvblT drank FEw7siBqbW and recovered 6.6534. Co20ocvblT drank 0WnMAYPzUH and recovered 2.70554. Co20ocvblT recovered extra 283.62987482. Co20ocvblT used yv58Ec49pK and earned 65.161. yv58Ec49pK's sharpness became 4476.4825068. The adventurer's id is 2, name is Co20ocvblT, health is 382.98881482, exp is 10.0, money is 65.161. 样例4输入： 30 1 329740070 sEhDbhnEnd 1 1851576059 8N3Vj7BkdZ 1 1151146527 T3NZDh4jCz 2 1151146527 1 1604225601 1u4QtP6lL9 5038843478073893142 28.0905 2 1151146527 4 419039688 Yuu2onZU2y 2877398768860155635 93.917 2 1151146527 4 1151636326 Fv1RvYmP0E 7285089275503127969 95.7149 2 329740070 2 1154770639 eRNkZX7yE8 8269076524323616536 13.2538 24.7047 2 329740070 4 1710411361 N8Nav2fayl 2308642044102240255 72.4425 2 329740070 2 112570669 hFC53lbVRK 4601284869343090065 47.6571 43.1437 11 2 10 1851576059 1151146527 5 329740070 7 329740070 1154770639 6 1851576059 12 2 10 1151146527 329740070 8 329740070 2 329740070 2 698684406 xD5l7UCB4Y 3742687023378757769 79.1502 74.4603 6 329740070 11 3 9 329740070 2 1851576059 4 870218830 mgyVlRqvxp 2506134180893997996 67.5698 2 329740070 3 1851077531 fHDuxXvDW6 773490031336115588 94.9004 58.1943 6 329740070 12 2 1 909784950 6REvh6RB7v 2 329740070 4 264476603 ibOoPOPubU 278140469188458658 33.6055 8 1851576059 2 329740070 2 192707537 V8mhiYQmm6 5462659141869010887 80.353 52.5216 11 4 输入： 8269076524323616536 The healingPotion's id is 1154770639, name is eRNkZX7yE8, capacity is 13.2538, filled is true, efficiency is 24.7047. 1 sEhDbhnEnd drank eRNkZX7yE8 and recovered 1.32538. sEhDbhnEnd recovered extra 327.43115286. sEhDbhnEnd drank hFC53lbVRK and recovered 4.76571. sEhDbhnEnd recovered extra 2056.10362527. sEhDbhnEnd used N8Nav2fayl and earned 72.4425. 4 The adventurer's id is 329740070, name is sEhDbhnEnd, health is 2479.62586813, exp is 10.0, money is 72.4425. 5 8N3Vj7BkdZ drank xD5l7UCB4Y and recovered 7.91502. 8N3Vj7BkdZ recovered extra 5893.54763706. 8N3Vj7BkdZ used N8Nav2fayl and earned 72.4425. Failed to use eRNkZX7yE8 because it is empty. Failed to use hFC53lbVRK because it is empty. 8N3Vj7BkdZ used ibOoPOPubU and earned 33.6055. 8N3Vj7BkdZ used Fv1RvYmP0E and earned 95.7149. 8N3Vj7BkdZ drank 1u4QtP6lL9 and recovered 2.80905. 8N3Vj7BkdZ used Yuu2onZU2y and earned 93.917. 第六部分：提示 冒险者和装备都是价值体，都可以求价值、被使用以及字符串化等，故一个推荐的设计方法是建立价值体接口 ，接口中包含上述提到的三个方法，让冒险者 Adventurer 和装备 Equipment 都实现这个接口，这样在顶层逻辑中就只能看到价值体这一种类型，可使用该类型的引用去调用不同子类型对象的这三种方法，这种处理称为归一化处理，会在正式课程中有专门的论述和训练。 本次作业将会涉及到自定义排序，请学习如何给对象编写 compareTo 方法并实现 Comparable 接口，之后即可利用 Collections.sort 方法来给容器内对象进行排序，考虑到有许多知识同学们还没有学过，本章结尾会给出一个例子，同学们可以照猫画虎地完成，compareTo方法仅需要在Equipment类中定义，Equipment类的子类如果不重写该方法的话，将会与父类行为保持一致。 与 Collections.sort 会调用 compareTo 方法实现自定义排序，类似地，TreeSet 和 TreeMap 容器也会通过调用对象的 compareTo 方法，从而维护一个key对象有序的集合/映射。 另外，HashSet 和 HashMap 这两种容器会通过调用对象的 hashCode 方法和 equals 方法来将任意对象作为key来使用。这个知识点非常重要，不过因为原理上与 compareTo 相似度较高便不在此处过多训练，请同学们务必弄懂其原理。 Java中许多内置的类，比如 Integer 和 BigInteger 等等都已经实现了compareTo、hashCode、equals 方法，所以你才可以直接把他们当作 TreeMap 和 HashMap 的key来使用。 // Comparable接口的例子 import java.util.ArrayList; import java.util.Collections; class MainClass { public static void main(String[] args) { Score xiaoMing = new Score(120, 138); Score xiaoHong = new Score(125, 133); Score xiaoWang = new Score(119, 145); ArrayList&lt;Score&gt; scores = new ArrayList&lt;&gt;(); scores.add(xiaoMing); scores.add(xiaoHong); scores.add(xiaoWang); Collections.sort(scores); for (Score score : scores) { // 如果你使用IDEA编写代码，可以试一试打出 \"scores.for&lt;TAB&gt;\" 这一串按键，快速补齐for循环 System.out.println(score); // 试一试 \"score.sout&lt;TAB&gt;\"，自动补齐打印语句 } /* 运行结果如下，越大的对象越在后面（即升序排序）: Score{chinese=120, math=138} Score{chinese=125, math=133} Score{chinese=119, math=145} */ } } class Score implements Comparable&lt;Score&gt; { // 后面尖括号里的类名基本上都会与前面的类名相同，表达“Score这个类可以与Score这个类相比较”这个意思。 private final int chinese; private final int math; public Score(int chinese, int math) { this.chinese = chinese; this.math = math; } public int getSum() { return chinese + math; } /** * 自定义分数的比较规则，首先比较总分，总分相同比较语文，语文相同比较数学…… */ @Override public int compareTo(Score other) { if (this.getSum() &lt; other.getSum()) { //首先比较总分，总分高的先录取 return -1; // 返回 -1 代表 this 小于 other } else if (this.getSum() &gt; other.getSum()) { return 1; // 返回 1 代表 this 大于 other } if (this.chinese &lt; other.chinese) { //若总分一样，按语文分更高的先录取 return -1; } else if (this.chinese &gt; other.chinese) { return 1; } // 返回任何负值都代表this &lt; other，于是可以这样子简写， // 下面三行关于math的比较和上面的五行关于chinese的比较是完全等价的。 if (this.math != other.math) { return this.math - other.math; } return 0; //返回0代表两被比较对象相等 } @Override public String toString() { return \"Score{\" + \"chinese=\" + chinese + \", math=\" + math + '}'; } } 第三次实验数据点击下载","author":"OOpre"},{"title":"第四次作业指导书","date":"2022-12-31T16:00:00.000Z","updated":"2023-01-02T10:03:41.733Z","comments":true,"path":"oopre/hw4.html","permalink":"https://toby-shi-cloud.github.io/oopre/hw4.html","excerpt":"","text":"第四次作业指导书 第二单元第一次作业主要训练字符串的处理能力，以及正则表达式相关知识。本单元作业同样需要同学们进行迭代，希望同学们在动笔之前先完整阅读一遍指导书，并在做题的同时思考如何给后续的迭代留下修改的空间，而不至于每一个新的 Task 都要重新写一份代码。 第一部分：训练目标 学习正则表达式等相关知识，掌握基本的处理字符串的方式和能力，学会从字符串中提取出有用的信息，并根据信息进行检索。 第二部分：预备知识 本次作业的完成可能需要用到的知识如下。 Java中String类库 Java类库中的String类提供了很多可以帮助你完成这几个Task的辅助方法。例如： split方法，可以根据给定的分隔符来将字符串分割为若干个字符串； indexOf方法，可以在给定的字符串中搜索给定字符串出现的位置； substring方法，可以按照下表位置区间来从给定字符串截取子字符串; trim方法，可以移除给定字符串开头和结尾处的空格以及换行符。 下面以一个简单的例子来辅助说明以上所提及的各个方法。 假设我们已经得到了含有如下信息的字符串： { \"code\":\"iVBORw@0KGgoAAAANSU#hEUgAAAAgAAA$AECAYAAACzzX7wAAAAGUlEQVQImW%NggID/DKjgPzYOLpqwAr^xWAAAbkwv1&amp;EmB71QAAAABJRU5*ErkJggg==\", \"key\":\"64\", \"type\":\"png\" } 现在我们想要将其中的code部分提取出来进行进一步的处理。 我们可以通过字符串查找的方式来完成该任务： public static String extractCode(String jsonString) { int start = jsonString.indexOf(\"\\\"code\\\"\"); //找到\"code\"所在之处； int end = jsonString.indexOf(\"\\n\", start); //从上一次搜索结果开始向后搜索换行符 return jsonString.substring(start + 8, end - 2); //根据以上信息截取子串并返回 } 当然，这种方法并没有对字符串进行实际的解析，仅仅是进行了提取。 我们也可以利用split方法来完成这一任务： public static String extractCode(String jsonString) { String[] records = jsonString.substring(1, jsonString.length() - 1).split(\",\"); //将输入的字符串按照逗号分割开 for (String record : records) { String[] details = record.split(\":\"); //分离每个分割出的字符串中的名称与值（按照冒号进一步分割） if (\"\\\"code\\\"\".equals(details[0])) { //判断数据名称是否为\"code\" return details[1].substring(1, details[1].length() - 1); //返回该数据对应的值。 } } throw new RuntimeException(\"keyword code not found!\"); //未找到，报错 } 除此之外，String类库中提供了其他字符串相关操作，这里不多做赘述。在各主流IDE中，你可以通过将鼠标悬停在方法名上来阅读方法的文档。这可以让你精确地了解该方法的具体作用，为熟悉java类库的使用提供很大的帮助。这里也鼓励大家通过这种方式或其他方式来更多地了解java库的相关知识。 正则表达式 正则表达式是一种强力的字符串结构化处理工具。正则表达式具有以字符串的形式描述一个字符串集合的能力，被频繁地用在字符串匹配等任务中。 正则表达式预定义了很多字符集合：如\\d代表所有数字字符，\\s代表所有空白字符，\\w代表字母、数字或下划线字符。 正则表达式具有灵活的特性。*符号与+符号提供了不定次数重复功能，{}则可以重复指定次数；[]提供了构造自己的字符集合的方法，而()则可以将字符串进行划分。 Java语言对正则表达式提供了多方面的支持。 你可以使用字符串的matches方法来检验字符串是否属于正则表达式所表示的集合；split函数中的分割符也可以填入正则表达式； 此外Java中还有Pattern类专门用来表示正则表达式。你可以使用Pattern.complie()方法将字符串转换为正则表达式。 由Pattern类的matcher方法构造的Matcher类则提供了多种多样的使用正则表达式对字符串进行匹配的方法： 使用find方法可以实现在同一个字符串中使用正则表达式连续的进行匹配； 使用group方法则可以从匹配中提取出与部分正则表达式相对应的子串； 使用start、end方法则可以获取匹配在目标字符串中的位置信息； 使用region方法还可以限定正则表达式进行匹配的范围； 下面以一个例子来简单介绍正则表达式的使用： 我们知道，java语言中存在着“包”这一概念。使用package关键字可以轻松的将java程序划分为不同的包，并建立起一套层次结构。 一般来说，包会使用倒置的域名作为其名字，如com.oocourse.spec1.io, org.apache.catalina, com.xiaoming.log等； 给定一个带有package关键字的java文件的内容(保证包名仅大由小写字母、数字、下划线构成)，请你输出该java文件所在的包以及该包的二级域名。 首先，写出package语句所对应的正则表达式如下： ^package \\w+(\\.\\w+)+; 其中+表示至少匹配1次;^表示匹配行首。 得到了对应的表达式，我们就可以对字符串进行匹配。具体的程序如下： public static final String PACKAEG_PATTERN = \"^package \\\\w+(\\\\.\\\\w+)+\"; public static String getSecondDomain(String javaFileContent) { Pattern pattern = Pattern.compile(PACKAEG_PATTERN); //将定义好的正则表达式字符串转换为正则表达式对象 Matcher matcher = pattern.matcher(javaFileContent); //将正则表达式结合到输入数据上 if (!matcher.find()) { //尝试进行匹配 throw new RuntimeException(\"Invalid input!\"); //失配，报错 } String[] urlParts = matcher.group() //匹配成功，获得匹配到的字符串 .split(\"\\\\.\"); //对匹配进行切分。注意split方法的参数也是正则表达式 if (urlParts.length &lt; 2) { System.err.println(\"package name's too simple!\"); } return urlParts[1]; } 值得注意的是，为了简化处理流程，该程序中的正则表达式并没有使用分号；但是由于正则表达式默认的非贪婪匹配特性，不会出现包名没有完全匹配到的结果。 此外，本任务也可以使用功能更强大的捕获组来完成，这里不多做赘述。同样地，这里鼓励大家自行去搜集指导书以外的资料去获取正则表达式的相关知识。 第三部分：题目描述 小明发现在此聊天软件的群聊功能中，如果不是发给某个特定的人的消息，群聊消息中不会注明消息的接收者。 因为很多用户希望在群聊中让某位用户特别注意到某消息，所以他们喜欢在群聊中发送@某人的信息，这些信息会被系统识别为群聊中发送给相应用户的消息，会提醒被所@的人注意到。 形式化来说，消息可能被表现成以下三种模式： 给个人的消息：yyyy/MM/dd-{sender}@{receiver }:\"{message_content}\"; 2021/07/12-student@teacher :\"can i pass the exam?\"; 本消息为发送给个人的消息，指定了接收者teacher。 群聊中的消息，指定了接收者：yyyy/MM/dd-{sender}:\"{message_content}\";，其中message_content内包含@{receiver } 2021/07/12-student:\"can i pass the exam?@teacher \"; 本消息为在群聊中发送的消息，指定了接收者teacher。 群聊中的消息，未指定接收者：yyyy/MM/dd-{sender}:\"{message_content}\"; 2021/07/12-student:\"can i pass the exam?\"; 本消息为在群聊中发送的消息，未指定接收者。 输入是具有上述模式的聊天消息，并以指定的形式输入多条询问。 请编写程序，根据输入的查询输出指定发送者、接收者、日期的消息。 第四部分：输入/输出说明输入格式 前若干行为消息内容，以一行END_OF_MESSAGE结尾。其中一行内可能有多条消息，每条消息之间和每行末尾可能存在若干空白字符（空格和制表符\\t）。 其后为多条询问，所有可能出现的询问格式如下： qdate year/month/day : 查询某日期的消息 qsend \"username\" : 查询某用户名发送的消息 qrecv \"username\" : 查询某用户名接收的消息。请注意，所有“群聊中@某用户的消息”均算作该用户接收的消息，即接受的消息包括：私聊该用户的消息和群聊中@某用户的消息。 输出格式 对于每一条询问，输出指定消息（输入数据中可能存在多条消息符合条件，此时按照原顺序、原格式输出全部符合条件的消息）。 输出中每条消息均单独占据一行。 输入样例12021/7/1-Jack@JayChou :\"Hello!\";2021/7/3-JayChou@buaaer :\"Hahaha\"; 2021/7/5-JayChou@Mike :\"emmmm\"; 2021/7/8-JayChou@buaaer :\"Hahaha\"; 2021/7/8-JayChou:\"Hahaha\"; 2021/5/3-Mike:\"he@buaaer is unhappy\"; END_OF_MESSAGE qdate 2021/7/1 qsend \"JayChou\" qrecv \"buaaer\" 输出样例12021/7/1-Jack@JayChou :\"Hello!\"; 2021/7/3-JayChou@buaaer :\"Hahaha\"; 2021/7/5-JayChou@Mike :\"emmmm\"; 2021/7/8-JayChou@buaaer :\"Hahaha\"; 2021/7/8-JayChou:\"Hahaha\"; 2021/7/3-JayChou@buaaer :\"Hahaha\"; 2021/7/8-JayChou@buaaer :\"Hahaha\"; 2021/5/3-Mike:\"he@buaaer is unhappy\"; 输入样例20233/2/0-Mike:\"he@buaaer is happy\"; 0233/2/31-Mike:\"he@buaaer is very happy\"; 233/2/0-Mike:\"he@buaaer is very very happy\"; END_OF_MESSAGE qdate 233/02/0 输出样例20233/2/0-Mike:\"he@buaaer is happy\"; 233/2/0-Mike:\"he@buaaer is very very happy\"; 第五部分：限制说明 一行输入中可能包含多条消息，但一条消息只会完整地出现在一行内。 每条消息之间和每行末尾可能存在若干空白字符作为分隔（空格和制表符\\t），也可能不存在。 保证所有的消息和指令符合格式。 保证输入的日期、用户名、正文都非空。 日期仅以 year/month/day 形式给出，$year \\in [0, 9999], mounth \\in [1, 12], day \\in [0,31]$。日期中可能存在前导0，比如1月可以表示为01月，258年可以表示为0258年。且保证合法，以及包括前导0在内，年份的位数不超过4位，月、日的位数不超过两位 发送者和接收者的用户名仅由大小写英文字母、数字组成。 正文内容仅由大小写英文字母、数字、空格、四种标点符号（? ! , .）构成。 输入数据中所有内容均对大小写敏感。 如果一条消息中存在@用户的情况（对应前两种消息模式），则保证该信息中@+用户名结构后面一定有一个空格，而且@用户最多只会在一个消息中出现一次。 不超过300行 每行不超过10个消息 总询问数不超过100条 第六部分：警示不要试图Hack评测机，不要抄袭。如发现其他人的代码疑似存在上述行为，可向课程组举报。课程组感谢同学们为课程建设所作出的贡献。 第四次实验数据点击下载","author":"OOpre"},{"title":"第六次作业指导书","date":"2022-12-31T16:00:00.000Z","updated":"2023-01-02T10:04:08.729Z","comments":true,"path":"oopre/hw6.html","permalink":"https://toby-shi-cloud.github.io/oopre/hw6.html","excerpt":"","text":"第六次作业指导书第一部分：训练目标 继续利用正则表达式的知识实现更加高级的检索功能。并学会简单的异常处理。 第二部分：预备知识 本次作业没有新增的可能使用的知识。 第三部分：基本概念 概念 定义 子序列 将字符串中零个或多个字符去掉后所得结果，一个字符串 abc 的子序列有 a, b, c, ab, ac, bc, abc 子串 字符串中任意个连续的字符组成的子序列 前缀 包含第0个字符的子串 后缀 包含最后一个字符的子串 第四部分：题目描述 形式化来说，消息可能被表现成以下三种模式： 给个人的消息：yyyy/MM/dd-sender@receiver :\"message_content\"; 2021/07/12-student@teacher :\"can i pass the exam?\"; 本消息为发送给个人的消息，指定了接收者teacher。 群聊中的消息，指定了接收者：yyyy/MM/dd-sender:\"message_content\";，其中message_content内包含@receiver 2021/07/12-student:\"can i pass the exam?@teacher \"; 本消息为在群聊中发送的消息，指定了接收者teacher。 群聊中的消息，未指定接收者：yyyy/MM/dd-sender:\"message_content\"; 2021/07/12-student:\"can i pass the exam?\"; 本消息为在群聊中发送的消息，未指定接收者。 模糊查询只能查询子串显然是不够的，我们需要更加强大的模糊查询功能。 同时，当下网络环境纷繁错杂，发送的信息中可能包含敏感词汇，为了响应净网行动，我们的程序需要提供关键字屏蔽功能。 群聊消息格式同前两次作业。 请编写程序读入消息，并根据输入的查询找出指定了接收者/发送者并且该接收者/发送者的用户名包含指定前缀、后缀、子串或子序列的消息。 指令相较于上一次作业的改动如下。 qsend和qrecv的模糊查询模式新增四个参数-ssq, -ssr, -pre, -pos，从左到右分别表示：查询以后续输入字符串为子序列(subsquence)，子串(substring)，前缀(prefix)，后缀(postfix)的发送者/接收者名称的消息。即现在上述两条指令的完整形式为qsend [-v] [param] \"str\"和qrecv [-v] [param] \"str\"。其中param为上述四个参数中的一个。当param缺省而-v存在时，表示含义与param=-ssr且-v存在时一致。 所有指令新增参数-c \"str\"(-c: clean)表示将所有该指令输出消息中的消息内容中的子串str（引号是指令格式要求，并非str内的内容）改为由字符’*’组成的字符串后再输出，其长度与被修改的字符串长度相同。该参数永远是所有指令的最后一个参数。且子串匹配优先级为从左到右（具体解释见样例） 指令参数之间的顺序关系见后续限制说明部分以及样例。 这里我们还需要大家实现对指令格式的检查。格式错误的指令只需按照指导书要求输出即可，无需将错误指令执行，具体如下 qdate指令的日期若不符合现实中的日期表示，则需要输出Command Error!: Wrong Date Format! \"cmd\"，其中cmd为出错指令。 qsend和qrecv中，新增的四个参数只适用于模糊匹配，所以，若-ssq, -ssr, -pre, -pos参数在-v参数之前出现，或-v参数未出现而这四个参数出现了，则需要输出Command Error!: Not Vague Query! \"cmd\"，其中cmd为出错指令。 显然一条指令至多只有一种错误 第五部分：输入/输出说明输入格式 前若干行为消息内容，以一行END_OF_MESSAGE结尾。其中一行内可能有多条消息，每条消息之间和每行末尾可能存在若干空白字符（空格和制表符\\t）。 其后为多条查询语句，每行一条。 正确的查询指令、参数及格式参考上面。 输出格式 对于每一条询问，输出指定消息（输入数据中可能存在多条消息符合条件，此时按照原顺序、原格式输出全部符合条件的消息）。 输出中每条消息均单独占据一行。 输入样例2023/12/23-timetraveler:\"I am from future!!!\"; 2022/8/3-fishlifehh:\"I am lying flat@kasumi . too tired to tap.\"; 2021/3/12-meloneater:\"@timetraveler so what is happen, maybe I should say what will happen in the future?\"; 1999/12/31-earthwarrior:\"so, do we win?\"; 1999/12/31-militaryleader:\"hey! @earthwarrior , you should abide by the agreement!\"; 1999/12/31-earthwarrior@militaryleader :\"aaah! I forget it.\"; 2022/3/23-ooer:\"why you crashed again?\"; 2022/6/4-urgenter:\"hurry! the next class will start immediately.\"; 0257/5/3-ancienter:\"you mean this is the prophecy of a prophet.\"; 0257/5/4-ancientress@ancienter :\"yes, and i dont know why we speak english.\"; END_OF_MESSAGE qdate 2022/2/30 qdate /13/ qsend -v -pos \"er\" qrecv -pos \"or\" qsend \"militaryleader\" -c \"agreement\" qrecv -v -pre \"an\" -c \"english\" qsend \"earthwarrior\" -c \"aa\" 输出样例Command Error!: Wrong Date Format! \"qdate 2022/2/30\" Command Error!: Wrong Date Format! \"qdate /13/\" 2023/12/23-timetraveler:\"I am from future!!!\"; 2021/3/12-meloneater:\"@timetraveler so what is happen, maybe I should say what will happen in the future?\"; 1999/12/31-militaryleader:\"hey! @earthwarrior , you should abide by the agreement!\"; 2022/3/23-ooer:\"why you crashed again?\"; 2022/6/4-urgenter:\"hurry! the next class will start immediately.\"; 0257/5/3-ancienter:\"you mean this is the prophecy of a prophet.\"; Command Error!: Not Vague Query! \"qrecv -pos \"or\"\" 1999/12/31-militaryleader:\"hey! @earthwarrior , you should abide by the *********!\"; 0257/5/4-ancientress@ancienter :\"yes, and i dont know why we speak *******.\"; 1999/12/31-earthwarrior:\"so, do we win?\"; 1999/12/31-earthwarrior@militaryleader :\"**ah! I forget it.\"; 样例解释 对于最后一条指令，忽略-c参数时的输出如下： 1999/12/31-earthwarrior:\"so, do we win?\"; 1999/12/31-earthwarrior@militaryleader:\"aaah! I forget it.\"; 考虑-c第一条消息的内容不以aa为子串，而第二条消息的内容中存在子串aa，根据从左往右的匹配规则，将前两个aa替换成**后输出。 若第二条消息的原版是1999/12/31-earthwarrior@militaryleader:\"aaaah! I forget it.\";，则根据从左到右的匹配规则，会先匹配到前两个aa并将其替换成**，然后匹配到后两个aa并替换成**，最终输出的是1999/12/31-earthwarrior@militaryleader:\"****h! I forget it.\"; 第六部分：限制说明 一行输入中可能包含多条消息，但一条消息只会完整地出现在一行内。 每条消息之间和每行末尾可能存在若干空白字符作为分隔（空格和制表符\\t），也可能不存在。 保证所有的消息符合格式，指令错误只涉及上面谈到的那些类型。（这条与上次作业不同） 保证输入的日期、用户名、正文都非空。 对于日期，保证 $year \\in [0, 9999], mounth \\in [1, 12], day \\in [0,31]$。日期中可能存在前导0，比如1月可以表示为01月，258年可以表示为0258年。且包括前导0在内，年份的位数不超过4位，月、日的位数不超过两位。（这条与上次作业不同） 发送者和接收者的用户名仅由大小写英文字母、数字组成。 qdate指令保证输入的日期中年月日三个参数不同时缺省 qsend和qrecv指令中，保证-ssq, -ssr, -pre, -pos四个参数至多出现其中一个 正文内容仅由大小写英文字母、数字、空格、四种标点符号（? ! , .）构成。 输入数据中所有内容均对大小写敏感。 如果一条消息中存在@用户的情况（对应前两种消息模式），则保证该信息中@+用户名结构后面一定有一个空格。而且@用户最多只会在一个消息中出现一次。 如果有-c参数的话，其一定是所有指令的最后一个参数。 指令涉及到的异常类型一定是上面提到的几个类型之一 日期格式异常只需考虑月，日大小以及平闰年，无需考虑1582年的10月份少了10天等类似的非常偏门的错误。 当日期发生参数缺省时，只需考虑已给定参数的合法性 ，具体而言。若在固定已有参数值的情况下，存在缺省参数的一组取值，使得日期合法，则认为该日期参数合法。 例子1：指令qdate /2/29合法，因为2月可以有29日，且当年份为闰年时，整个日期合法，所以该日期参数合法 例子2：指令qdate /9/31非法，因为9月不可能有31日，这与缺省的年份无关。 例子3：指令qdate 2022//31合法，因为存在有31号的月份。 例子4：指令qdate //32非法，因为不存在有32号的月份。这与缺省的年、月份无关 例子5：指令qdate /13/非法，因为不存在有13月的年份，这与缺省的年、日无关 例子6：指令qdate //0非法，因为不存在0号。 输入数据不超过300行 输入数据每行不超过10个消息 输入数据总询问数不超过100条 第七部分：提示与警示提示 日期的前导0并不影响日期本身的含义，查询时请按照日期本身的语义进行查询。 警示 不要试图Hack评测机，不要抄袭。如发现其他人的代码疑似存在上述行为，可向课程组举报。课程组感谢同学们为课程建设所作出的贡献。 第六次实验数据点击下载","author":"OOpre"},{"title":"第七次作业指导书","date":"2022-12-31T16:00:00.000Z","updated":"2023-01-02T10:04:26.326Z","comments":true,"path":"oopre/hw7.html","permalink":"https://toby-shi-cloud.github.io/oopre/hw7.html","excerpt":"","text":"第七次作业指导书第一部分：训练目标本次作业是针对递归下降算法解析字符串的练习，通过此次作业希望同学们可以了解一种解析“结构性字符串”的方法，从而更好的衔接下学期OO课程的第一单元作业。 第二部分：题目背景小明同学对于网络爬虫十分感兴趣，某天他爬取了twitter网站的数据，数据以jsonline格式返回，每一行jsonline数据包含了一条推特文章的id，转发数，点赞数等等许多信息。小明希望从jsonline数据中挖掘出这些信息，但是面对这么多条jsonline数据，小明感到十分发愁，头发越来越少。希望你能帮其编写一个Java程序来解析这些jsonline格式的数据，然后进一步获得这些jsonline数据中隐藏的结果。 第三部分 Json及Jsonline的介绍首先我们先简单了解一下json，以便更好的理解这次作业。Json是基于 JavaScript的一个子集，是一种开放的、轻量级的数据交换格式，采用独立于编程语言的文本格式来存储和表示数据，易于程序员阅读与编写，同时也易于计算机解析和生成，通常用于在 Web 客户端（浏览器）与 Web 服务器端之间传递数据。 下面给出了一个json格式的数据例子。 { \"object_type\": \"TweetRaw\", \"download_datetime\": \"2022-07-06T17:04:48.030971+08:00\", \"raw_value\": { \"created_at\": \"Sat Dec 04 17:16:55 +0000 2021\", \"id\": 1467181131464609792, \"id_str\": \"1467181131464609792\", \"full_text\": \"there are some contents\", \"display_text_range\": [ 0, 183 ], \"entities\": { \"urls\": [ { \"url\": \"https://t.co/AQNqsGsPsx\", \"expanded_url\": \"https://rpc.flashbots.net\", \"display_url\": \"rpc.flashbots.net\", \"indices\": [ 106, 129 ] }, { \"url\": \"https://t.co/uY0UwIC7lp\", \"expanded_url\": \"https://docs.flashbots.net/flashbots-protect/rpc/quick-start#how-to-use-flashbots-protect-rpc-in-metamask\", \"display_url\": \"docs.flashbots.net/flashbots-prot…\", \"indices\": [ 160, 183 ] } ] }, \"user_id\": 1406813839627153408, \"user_id_str\": \"1406813839627153408\", \"retweet_count\": 1, \"favorite_count\": 2, \"reply_count\": 1, \"quote_count\": 0, \"favorited\": true, \"possibly_sensitive_editable\": false, \"lang\": \"zh\", \"supplemental_language\": null, \"self_thread\": { \"id\": 1467180910961643520, \"id_str\": \"1467180910961643520\" } } } 通过上面这个例子，我们可以更好的理解Json的数据格式，Json的格式约定比较简单，易于理解，包括以下几点。 对象：Json中用大括号 { } 保存对象，对象可以包含多个 key/value（键/值）对。 在上面的例子中，整个json用一对大括号 { }包裹，所以整个json其实是一个json对象。同时”raw_value”、 “entities”、”self_thread”这些键对应的值也都是对象。 对象包含的数据存储在键：值对中 值（value）可以是双引号括起来的字符串（string）、数值(number)、true、false、 null、对象（object）或者数组（array）。 键：一个字符串。 值和名称间用冒号:分割 Json采用名称：值，这种键值对的形式来存储数据，冒号右侧的值可以是多种数据类型，就比如上面给出的例子中的”object_type”、”id”、”favorited”、”supplemental_language”、”raw_value”、 “display_text_range”这些属性，他们所对应的值分别是字符串、数值、boolean(true、false)、 null、对象和数组（array）。 数据由逗号,分隔 Json中数据用逗号,分割，从上面的例子可以看出，对象中的键值对用逗号分隔，但对象中的最后一个键值对后面没有逗号。同时数组中的数据也用逗号分隔，这一点与我们学习的其他语言相同。 数组：中括号 [ ] 保存数组，数组可以包含多个对象,当然也可以包含我们常见的字符串、数值等数据类型。 JSON 中数组值必须是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。比如在上面的例子中，”display_text_range”属性对应的值存储了数字，”urls”属性对应的值存储了2个对象。 了解了Json数据结构后，Jsonline格式的数据顾名思义，就是把Json数据放在一行，作为一行字符串，便于进行数据交换。比如将上面这个Json例子的数据转换为Jsonline数据，即为： {\"object_type\":\"TweetRaw\",\"download_datetime\":\"2022-07-06T17:04:48.030971+08:00\",\"raw_value\":{\"created_at\":\"Sat Dec 04 17:16:55 +0000 2021\",\"id\":1467181131464609792,\"id_str\":\"1467181131464609792\",\"full_text\":\"there are some contents\",\"display_text_range\":[0,183],\"entities\":{\"urls\":[{\"url\":\"https://t.co/AQNqsGsPsx\",\"expanded_url\":\"https://rpc.flashbots.net\",\"display_url\":\"rpc.flashbots.net\",\"indices\":[106,129]},{\"url\":\"https://t.co/uY0UwIC7lp\",\"expanded_url\":\"https://docs.flashbots.net/flashbots-protect/rpc/quick-start#how-to-use-flashbots-protect-rpc-in-metamask\",\"display_url\":\"docs.flashbots.net/flashbots-prot…\",\"indices\":[160,183]}]},\"user_id\":1406813839627153408,\"user_id_str\":\"1406813839627153408\",\"retweet_count\":1,\"favorite_count\":2,\"reply_count\":1,\"quote_count\":0,\"favorited\":true,\"possibly_sensitive_editable\":false,\"lang\":\"zh\",\"supplemental_language\":null,\"self_thread\":{\"id\":1467180910961643520,\"id_str\":\"1467180910961643520\"}}} 第五部分：题目描述小明在爬取数据时提前进行了设置，因此爬取到的Jsonline数据有固定的格式和固定的键值对,在这里将jsonline转换为json格式，向同学们介绍。一个爬取到的数据例子如下： { \"object_type\": \"TweetRaw\", \"download_datetime\": \"2022-07-06 08:00\", \"raw_value\": { \"created_at\": \"Sat Dec 04 17:16:55 2021\", \"id\": 1467181131464609792, \"full_text\": \"this is a retweet_count content\", \"user_id\": 1406813839627153408, \"retweet_count\": 1, \"favorite_count\": 2, \"reply_count\": 1, \"possibly_sensitive_editable\": true, \"lang\": \"zh\", \"emojis\":[ { \"name\":\"Grinning Face\", \"emoji_id\":12, \"count\":2 }, { \"name\":\"Face With Tears of Joy\", \"emoji_id\":22, \"count\":1 } ] } } 属性介绍 属性 值 object_type 字符串，整个json的对象类型，该值固定为”TweetRaw” download_datetime 字符串，爬取这条json数据的时间，时间格式固定“年-月-日 时:分”，年为4位，月、日、时、分补足2位，例如 2022-08-13 08:00 raw_value 对象，包含这条推特的所有信息 created_at 字符串，该条推特发布时间，时间格式固定星期 月份 日期 时:分:秒 年，月份格式约定为{12: 'Dec', 11: 'Nov', 10: 'Oct',9: 'Sep', 8: 'Aug', 7: 'Jul',6: \"Jun\", 5: \"May\", 4: \"Apr\",3: \"Mar\", 2: \"Feb\", 1: \"Jan\"}；星期英文简写为{1: \"Mon\", 2: \"Tue\", 3: \"Wed\", 4: \"Thu\", 5: \"Fri\", 6: \"Sat\", 7: \"Sun\"} id 数值，推特id，该id唯一不重复 full_text 字符串，推特内容，如果不包含任何内容为null user_id 数值，发表用户的id，该id唯一不重复 retweet_count 数值，转发数 favorite_count 数值，点赞数 reply_count 数值，评论数 possibly_sensitive_editable 布尔值，表示是否为敏感信息，true为敏感信息，false则非敏感信息 lang 字符串，语言 emojis 数组，存储这条推特所包含的所有表情包，如果不包含任何表情包为空列表 name 字符串，表情包名字 emoji_id 数值，表情包id count 数值，该条推特里使用了多少个该表情 第六部分：输入/输出说明查询指令介绍为了便于进行正确的性判定，本次作业采用输入查询指令的形式来进行正确性评判，本次作业包含如下指令，指令的查询字段均以空格隔开。 指令序号 输入指令格式 输出格式 1 Qdate user_id start_date~end_date N N1 N2 N3 2 Qemoji id name1 name2 …. 3 Qcount start_date~end_date N 4 Qtext id full_text 5 Qsensitive user_id N 6 Qlang id Language 指令序号 指令含义 说明 1 查询字段以空格隔开，查询id为user_id的用户在start_date~end_date时间段(包含开始和截止日期)内发布推特的条数N，总转发数N1，总点赞数N2，总评论数N3，以空格分隔。 日期格式为year-month-day，月、日的数字要以0补全为2位。如2022-08-08，2022-11-10 2 查询字段以空格隔开，查询id的推特所包含的emoji名字，并以count数量降序排列，count数量相等则以name字典序升序排列，输出的name之间以空格分隔。 若此id推特无任何表情包,为空列表，输出None 3 查询字段以空格隔开，查询一段时间内（包含开始和截止日期），json数据爬取的个数N。 日期格式同指令1中格式 4 查询字段以空格隔开，查询某id推特的内容。 输出原内容时两侧不需要加引号。若此id推特无内容，输出None 5 查询字段以空格隔开，查询某user_id用户发布的敏感内容条数N。 无 6 查询字段以空格隔开，查询某id推特语言属性。 输出原内容时两侧不需要加引号 请编写程序读入多行jsonline数据，并根据输入的查询指令给出对应输出，输出需进行换行。 输入格式首先输入多若干行Jsonline数据，每一条Jsonline为一条推特的信息。最后以一行END_OF_MESSAGE结尾。 其后为多条查询语句，每行一条。 具体的指令请参见上文的查询指令介绍。 输出格式输出格式详见上文的查询指令介绍。 输入样例{\"object_type\":\"TweetRaw\",\"download_datetime\":\"2022-07-06 08:00\",\"raw_value\":{\"created_at\":\"Sat Dec 04 17:16:55 2021\",\"id\":1467181131464609792,\"full_text\":\"content1\",\"user_id\":1406813839627153408,\"retweet_count\":1,\"favorite_count\":2,\"reply_count\":1,\"possibly_sensitive_editable\":true,\"lang\":\"zh\",\"emojis\":[{\"name\":\"Grinning Face\",\"emoji_id\":12,\"count\":2},{\"name\":\"Face With Tears of Joy\",\"emoji_id\":22,\"count\":1}]}} {\"object_type\":\"TweetRaw\",\"download_datetime\":\"2022-07-10 08:00\",\"raw_value\":{\"created_at\":\"Sat Dec 09 17:16:55 2021\",\"id\":1467181131464609793,\"full_text\":\"content2\",\"user_id\":1406813839627153408,\"retweet_count\":1,\"favorite_count\":0,\"reply_count\":0,\"possibly_sensitive_editable\":false,\"lang\":\"zh\",\"emojis\":[]}} END_OF_MESSAGE Qdate 1406813839627153408 2021-12-04~2021-12-05 Qemoji 1467181131464609792 Qcount 2022-07-04~2022-07-06 Qtext 1467181131464609793 Qsensitive 1406813839627153408 Qlang 1467181131464609792 为了便于观察，下面是把jsonline数据转换成的对应顺序json数据 // 第一条Jsonline输入 { \"object_type\": \"TweetRaw\", \"download_datetime\": \"2022-07-06 08:00\", \"raw_value\": { \"created_at\": \"Sat Dec 04 17:16:55 2021\", \"id\": 1467181131464609792, \"full_text\": \"content1\", \"user_id\": 1406813839627153408, \"retweet_count\": 1, \"favorite_count\": 2, \"reply_count\": 1, \"possibly_sensitive_editable\": true, \"lang\": \"zh\", \"emojis\":[ { \"name\":\"Grinning Face\", \"emoji_id\":12, \"count\":2 }, { \"name\":\"Face With Tears of Joy\", \"emoji_id\":22, \"count\":1 } ] } } // 第二条Jsonline输入 { \"object_type\": \"TweetRaw\", \"download_datetime\": \"2022-07-10 08:00\", \"raw_value\": { \"created_at\": \"Sat Dec 09 17:16:55 2021\", \"id\": 1467181131464609793, \"full_text\": \"content2\", \"user_id\": 1406813839627153408, \"retweet_count\": 1, \"favorite_count\": 0, \"reply_count\": 0, \"possibly_sensitive_editable\": false, \"lang\": \"zh\", \"emojis\":[] } } 输出样例1 1 2 1 Grinning Face Face With Tears of Joy 1 content2 1 zh 样例解释Qdate 1406813839627153408 2021-12-04~2021-12-05： 用户对应日期时间段内只发布了一条tweet，即第一条tweet，对应输出1 1 2 1。 Qemoji 1467181131464609792： 查询了第一条tweet内部的表情，按照上文的排序规则排序后，输出Grinning Face Face With Tears of Joy。 Qcount 2022-07-04~2022-07-06： 查询对应时间段内爬取的数据条数，该时间段爬取了第一个tweet，输出1。 Qtext 1467181131464609793： 查询了第2个tweet的full_text内容，输出content2。 Qsensitive 1406813839627153408： 查询了该用户发布的敏感内容条数，2个tweet都为该用户发布，只有第1个为敏感内容，输出1。 Qlang 1467181131464609792： 查询第1个tweet的语言，输出zh。 数据限制 在所有键值对中，只有”full_text“的值可能为null，其他的所有值约定不为null。 指令及数据中的用户user_id，推特的id，emoji的id均存在，数据范围不作保证。emoji的名字唯一不重复。 在字符串内部，规定不包含双引号。 键值对冒号:两侧不包含空格，用于间隔数据的逗号,两侧均没有空格。一行jsonline数据中，只有字符串类型的值内部包含空格。 有关数字的查询指令，保证输出的数值类结果的大小不超过int。 id类的属性(id, user_id,emoji_id)的值，可以有前导零，但01和1是不同的id（即不通过数值相等判断id相同）。 第五部分：提示解题思路（递归下降算法解题思路）有了第一部分和第二部分作业的训练，相信大家对层次化设计和正则表达式有了一个初步的认识。在此基础上，针对本次作业，我们提供一种针对具有特定语法规则的文本结构进行自顶向下分析的方法，即递归下降解析法。理解了这种方法对大二下学期的OO课程第一单元，以及大三上学期的编译课程都有帮助。 首先，我们需要进行抽象层次设计。根据题目需求，我们需要定义一系列的具有一定数据结构和功能结构的类。题目中所出现的较为明显的对象有：1、json对象（具有若干“键:值”对） 2、json中的“键:值”属性对象（可以细分成不同类型的键值对）3、数组对象。因此，可以将他们所具有的属性和所需要实现的功能封装成类。 注：继续分析json格式，可以发现：“json对象”和“数组对象”也能够作为“属性对象”。因此，我们更可以将上文提到的三个类进一步抽象（通过接口进行归一化处理）成一种类型（比如“Attribute”接口）。 其次，文本解析器。有了以上的类型的设计，我们就有了分析文本结构的“原材料”，但是我们缺少一种能够分析文本输入的工具。一般而言，我们针对具有特定语法的文本结构可以采用——“词法分析”和“语法分析”两步分析的方式。 词法分析器：主要负责顺序读取字符流，并提取出关键“词法”。针对本次作业，它应解析出——左大括号，右大括号，逗号，冒号，字符串等等“词法”。较为简单。 语法分析器：利用词法分析器，对当前读取的词法做分析，并将各种词法进一步抽象组合到语法模型中。针对本次作业，它应解析出：json对象，属性对象，数组对象。 注：语言表述比较抽象，如果对此感兴趣的同学，可以自行搜索相关资料进行了解，以下是基于本次作业提供相应思路。 本次作业的词法分析器设计： 属性设计：1、需要分析的字符串 2、负责表示当前读取到的词法 功能设计：需要提供“读取下一个词法”的方法 词法分析较为简单，这里就不过多赘述。 本次作业的语法分析器设计： 属性设计：词法分析器。 功能设计：由于普通的json文件能够无限次数地嵌套（本题不能无限次数嵌套，可以不使用这种方法，大家可以酌情参考），经典的特判类型的分析是无法满足需求的。因此，这里我们利用“递归下降法”的思想。 简而言之，就是对几个需要解析的对象类型分别进行解析，并通过互相调用实现递归分析。具体思路可以看以下代码示例。 // 语法分析器 public class Parser { //词法分析器 private Lexer lexer; // parseObject专门解析并返回json对象 public .../*json对象*/ parseObject() { // 1、当前 Lexer 读到的是左大括号 // 2、循环读取 Lexer 的下一个词法 // 若是右大括号，则停止循环 // 若不是，则调用parseAttribute // 3、返回一个json对象 } //parseAttribute专门解析并返回一个属性对象 public .../*属性对象*/ parseAttribute() { // 1、当前 Lexer 读到的是属性的名称 // 2、分类讨论 Lexer 之后读取的内容 // 若是字符串，则创建字符串属性对象 // 若是数字，则创建数字属性对象 // ... // 若是左大括号，则调用parseObject读取json对象作为属性 // 若是左中括号，则调用parseArray读取数组对象作为属性 // 3、返回一个属性对象 } // parseArray专门解析并返回数组对象 public .../*数组对象*/ parseArray() { // 1、当前 Lexer 读到的是左方括号 // 2、循环读取 Lexer 的下一个词法 // 若是右方括号，则停止循环 // 若不是，则一定是json对象/数字/字符串 // 小tip：java中可以用Object表示任意类型 // 3、返回一个数组对象 } } 例子(一个简单例子)： {\"object_type\":\"TweetRaw\",\"raw_value\":{\"id\":1467181131464609792,\"display_text_range\":[0,183]}} 调用过程： |- parseObject: '{' |- parseAttribute: \"object_type\":\"TweetRaw\" |- parseAttribute: \"raw_value\": |- parseObject: '{' |- parseAttribute: \"id\":1467181131464609792 |- parseAttribute: \"display_text_range\": |- parseArray: '[' |- /* 读入0 183，直到下一个] */ |- parseArray: ']' |- parseObject: '}' |- parseObject: '}' 当然，这里只是提供一种思路，以上这个例子也只是其中一种方式。递归下降法具有很好的通用性，可以帮助你解析任何形式的jsonline数据，不仅限于本题固定格式的jsonline数据。当然由于本题的jsonline内部格式、属性已经固定，正确的解题方法必然是多种多样的，大家可以根据自己的思路构思进行解答～ 第六部分：警示请同学们在作业代码中务必不要使用或导入任何其他第三方包进行Jsonline、Json数据的自动解析！一经查实将取消本次作业成绩，请自行编写程序解析数据，以达到训练效果。 第七次实验数据点击下载","author":"OOpre"},{"title":"oopre","date":"2022-12-31T16:00:00.000Z","updated":"2023-01-02T08:19:22.719Z","comments":true,"path":"oopre/index.html","permalink":"https://toby-shi-cloud.github.io/oopre/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-06-14T10:00:00.000Z","updated":"2022-06-14T10:16:31.019Z","comments":true,"path":"contact/index.html","permalink":"https://toby-shi-cloud.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，一起交流学习！ 特别感谢 特别感谢本博客模板制作者：Luckey Luckeyの博客名称: Luckeyの博客 Luckeyの博客网址: http://www.luckyzmj.cn Luckeyの博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png Luckeyの博客介绍: The harder you work, the luckier you will be"},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-14T07:18:32.029Z","comments":true,"path":"music/index.html","permalink":"https://toby-shi-cloud.github.io/music/index.html","excerpt":"","text":""},{"title":"2022 回顾","date":"2023-01-14T16:00:00.000Z","updated":"2023-01-15T09:13:17.022Z","comments":true,"path":"review/2022.html","permalink":"https://toby-shi-cloud.github.io/review/2022.html","excerpt":"","text":"2022 的回顾注意：排序与重要性无关 考取驾照 已经有好多人坐过我开的车了 虽然车多的时候还是害怕 开过最快的车是在成都二环高架上 80 km/h 初步学习 Swift 学习 Swift 对我来说是很重要的，因为我以前总是说我讨厌前端 Swift 真的很优雅，进而我又去了解了 js 和 ts，开发了一个简单的 vscode 插件 新年的一个愿望就是学会网页（为什么不是继续 Swift 呢？因为我没有 Mac 😢） 参加 ICPC 线上参加真的很遗憾 两次与银擦肩而过真的很遗憾 新的一年希望能线下参赛一次，拿银一次，就算是完美了 当程设助教 认识了很多有趣的朋友 每次上机给同学们发零食很快乐 收到同学们送的礼物也很快乐 进入计算机学院 不知该说开心还是遗憾，有时也会觉得太累 学过计组后我更确信我不喜欢硬件 有时也会后悔为什么不去软院，学学算法之类的 关于计组 遗憾是在上机 100% 通过的情况下，放弃了 P8 最大的收获是学习了 Java，魔改了 Mars，也算是给这门课留下了自己的印记 在理论课几乎没听过的情况下，最后期末成绩出人意料的还不错 关于成绩 数据结构 99 算是错失满分机会（当然或许程设免修才是） 以微弱劣势错失奖学金 物理真的好难 关于朋友 几乎没有交到新朋友，一起玩的还是那些人 很遗憾新的小班活动一次没参加，除了班长一个人不认识 想当一个好梦拓，却发现和梦拓学弟的关系还不如程设的学生 关于感情 一别半载，再见已是炎炎夏日 很喜欢看别人谈恋爱，羡慕，会让我忆起过去 看着两个朋友从牵手到分手，似乎就在一瞬之间，不喜欢快节奏，但祝他们未来会遇见更好的 2023 的展望注意：排序与重要性无关 关于技能 会做一个能看的网页，以及优化我的博客 如果一时脑袋发热买了 Mac 就继续学习 Swift 吧 抽空练琴 关于学习 物理缓考别挂，物理别挂，物理别挂 保研渺茫，不追求分数，只希望留下自己的痕迹，学到喜欢的东西 ICPC 加油，ICPC 加油，ICPC 加油 关于生活 早点睡觉少熬夜 什么时候才能长胖啊 瓶盖，希望不要成为我一生的痛 关于假期 疫情管控结束了，周末就多出去走走吧 长假或许有机会出去旅游了 有机会多在北京走走，以后就不知道什么时候再进京了 关于助教 本来希望当大计基助教，但可惜时间不太合适 不想当计组助教 可以考虑面向对象和程序设计助教","author":"TobyShi"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-14T07:18:32.144Z","comments":true,"path":"tags/index.html","permalink":"https://toby-shi-cloud.github.io/tags/index.html","excerpt":"","text":""},{"title":"Object Oriented History","date":"2023-03-31T16:00:00.000Z","updated":"2023-04-05T02:37:53.108Z","comments":true,"path":"oocheck/history.html","permalink":"https://toby-shi-cloud.github.io/oocheck/history.html","excerpt":"","text":""}],"posts":[{"title":"Operator System Lab 2 上机实验回顾","slug":"OSLab2","date":"2023-04-03T16:00:00.000Z","updated":"2023-04-04T02:12:21.895Z","comments":true,"path":"posts/oslab2.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/oslab2.html","excerpt":"","text":"Exam题面实现函数 u_int&nbsp;page_perm_stat(Pde *pgdir,&nbsp;struct&nbsp;Page *pp, u_int perm_mask) 。 函数介绍：遍历以 pgdir 为页目录基地址的整个二级页表，找到指向 pp 的且权限至少为 perm_mask 页表项个数，并输出找到的个数。 我的代码u_int page_perm_stat(Pde *pgdir, struct Page *pp, u_int perm_mask) { u_int count = 0; for (u_int i = 0; i &lt; (1u &lt;&lt; 10); i++) { Pde *pgdir_entryp = pgdir + i; if (*pgdir_entryp &amp; PTE_V) { Pte *pte = (Pte *) KADDR(PTE_ADDR(*pgdir_entryp)); for (u_int j = 0; j &lt; (1u &lt;&lt; 10); j++) { Pte *pte_entryp = pte + j; if ((*pte_entryp &amp; PTE_V) &amp;&amp; (*pte_entryp &amp; perm_mask) == perm_mask) { if (pa2page(PTE_ADDR(*pte_entryp)) == pp) count++; } } } } return count; } 代码解释 u_int count = 0; 定义了一个用于计数的变量。 for (u_int i = 0; i &lt; (1u &lt;&lt; 10); i++) 这层循环遍历页目录下的所有页表项。 Pde *pgdir_entryp = pgdir + i; 这是页目录下的页表项。 if (*pgdir_entryp &amp; PTE_V) 如果这个页表项是有效的。 Pte *pte = (Pte *) KADDR(PTE_ADDR(*pgdir_entryp)); PTE_ADDR 取高 20 位，然后 KADDR 把物理地址转换为虚拟地址，于是得到 (二级) 页表基地址。 for (u_int j = 0; j &lt; (1u &lt;&lt; 10); j++) 遍历整个页表。 Pte *pte_entryp = pte + j; 这是一个页表项。 (*pte_entryp &amp; PTE_V) 判断页表项是否有效。 (*pte_entryp &amp; perm_mask) == perm_mask 判断页表项是否包含相应权限。 pa2page(PTE_ADDR(*pte_entryp)) == pp 判断是否指向指定页表，pa2page 把物理地址转换为页表控制结构体。 Extra题面实现内存交换机制。不限制策略和效率。 指定位于 $[0x3900000, 0x3910000)$ 的 16 个物理页作为可交换内存。使用 swap_alloc 申请可交换内存，如果可交换内存全部已满，则将一个页面换出到外存。使用 swap_lookup 查找虚拟地址对应物理内存，如果该内存已被换出，则需要换入。 这里课程组使用了一个 u_char 数组模拟外存，总计有 64 个外存页。我们只需要调用 disk_alloc 和 disk_free 就可以申请和释放外存了。 题目为填空题，已有代码如下： #include &lt;swap.h&gt; struct Page_list page_free_swapable_list; static u_char *disk_alloc(); static void disk_free(u_char *pdisk); void swap_init() { LIST_INIT(&amp;page_free_swapable_list); for (int i = SWAP_PAGE_BASE; i &lt; SWAP_PAGE_END; i += BY2PG) { struct Page *pp = pa2page(i); LIST_REMOVE(pp, pp_link); LIST_INSERT_HEAD(&amp;page_free_swapable_list, pp, pp_link); } } // Interface for 'Passive Swap Out' struct Page *swap_alloc(Pde *pgdir, u_int asid) { // Step 1: Ensure free page if (LIST_EMPTY(&amp;page_free_swapable_list)) { /* Your Code Here (1/3) */ } // Step 2: Get a free page and clear it struct Page *pp = LIST_FIRST(&amp;page_free_swapable_list); LIST_REMOVE(pp, pp_link); memset((void *)page2kva(pp), 0, BY2PG); return pp; } // Interfaces for 'Active Swap In' static int is_swapped(Pde *pgdir, u_long va) { /* Your Code Here (2/3) */ } static void swap(Pde *pgdir, u_int asid, u_long va) { /* Your Code Here (3/3) */ } Pte swap_lookup(Pde *pgdir, u_int asid, u_long va) { // Step 1: If corresponding page is swapped out, swap it in if (is_swapped(pgdir, va)) { swap(pgdir, asid, va); } // Step 2: Look up page table element. Pte *ppte; page_lookup(pgdir, va, &amp;ppte); // Step 3: Return return ppte == NULL ? 0 : *ppte; } // Disk Simulation (Do not modify) u_char swap_disk[SWAP_DISK_NPAGE * BY2PG] __attribute__((aligned(BY2PG))); u_char swap_disk_used[SWAP_DISK_NPAGE]; static u_char *disk_alloc() { int alloc = 0; for (;alloc &lt; SWAP_DISK_NPAGE &amp;&amp; swap_disk_used[alloc]; alloc++) { ; } assert(alloc &lt; SWAP_DISK_NPAGE); swap_disk_used[alloc] = 1; return &amp;swap_disk[alloc * BY2PG]; } static void disk_free(u_char *pdisk) { int offset = pdisk - swap_disk; assert(offset % BY2PG == 0); swap_disk_used[offset / BY2PG] = 0; } 内存交换流程： 换入过程： 申请一个可交换内存页（使用 swap_alloc） 将换出到外存的数据全部拷贝到新申请到的页 将所有指向该外存的页表项全部指向新内存页 将所有指向该外存的页表项的 PTE_V 置 1，PTE_SWP 置 0 释放外存页 换出过程： 选择一个要换出的内存页（任何策略都可以接受） 申请一个新的外存页（使用 disk_alloc） 将所有指向该内存页的页表项全部指向新外存页 将所有指向该内存页的页表项的 PTE_V 置 0，PTE_SWP 置 1 复制内存页的全部数据到外存 释放内存页，并将其插入空闲页表队列 代码实现Your Code Here (1/3)struct Page *swap_alloc(Pde *pgdir, u_int asid) { // Step 1: Ensure free page if (LIST_EMPTY(&amp;page_free_swapable_list)) { // random chose one page to swap out u_long pa = 0x3900000 + (asid % 16) * BY2PG; // chose page (asid % 16) u_long da = (u_long) disk_alloc(); // alloc a disk page page_swap_out_lookup(pgdir, asid, pa, da); // update page table entries // note: copy memory should use va, thus using KADDR to convert memcpy((void *)PTE_ADDR(da), (void *)KADDR(PTE_ADDR(pa)), BY2PG); // copy memory struct Page *pp = pa2page(pa); // get page pp-&gt;pp_ref = 0; // no looger use page_free(pp); // free page LIST_INSERT_HEAD(&amp;page_free_swapable_list, pp, pp_link); // insert to head } // Step 2: Get a free page and clear it struct Page *pp = LIST_FIRST(&amp;page_free_swapable_list); LIST_REMOVE(pp, pp_link); memset((void *)page2kva(pp), 0, BY2PG); return pp; } Your Code Here (2/3)static int is_swapped(Pde *pgdir, u_long va) { // note: you can refer to va2pa in pmap.h pgdir = &amp;pgdir[PDX(va)]; // get pgdir entry if (!(*pgdir &amp; PTE_V)) return 0; // not valid Pte *pte = (Pte *) KADDR(PTE_ADDR(*pgdir)); // get page table entry if (!(pte[PTX(va)] &amp; PTE_V) &amp;&amp; (pte[PTX(va)] &amp; PTE_SWP)) return 1; // swapped return 0; // not swapped } Your Code Here (3/3)static void swap(Pde *pgdir, u_int asid, u_long va) { struct Page *pp = swap_alloc(pgdir, asid); // alloc a new page Pte *pte = (Pte *) KADDR(PTE_ADDR(pgdir[PDX(va)])); // get pte of va u_long da = PTE_ADDR(pte[PTX(va)]); // get da what pte point to u_long kva = PTE_ADDR(page2kva(pp)); // get kva of the new page memcpy((void *)kva, (void *)da, BY2PG); // copy from disk to the new page u_long pa = (u_long) page2pa(pp); // get pa of the new page page_swap_in_lookup(pgdir, asid, pa, da); // update page table entries disk_free((u_char *)da); // free disk memory } Tool Functions// note: these are similar to page_perm_stat in Lab2-exam. /* Overview: * Walk through all the page table entries of pgdir * to find all the entries that point to pa * and change these entries to satify swap outs. */ void page_swap_out_lookup(Pde *pgdir, u_int asid, u_long pa, u_long da) { for (u_int i = 0; i &lt; (1u &lt;&lt; 10); i++) { Pde *pgdir_entryp = pgdir + i; if (*pgdir_entryp &amp; PTE_V) { Pte *pte_entryp = (Pte *) KADDR(PTE_ADDR(*pgdir_entryp)); for (u_int j = 0; j &lt; (1u &lt;&lt; 10); j++) { Pte *pte = pte_entryp + j; if ((*pte &amp; PTE_V) &amp;&amp; PTE_ADDR(*pte) == PTE_ADDR(pa)) { *pte = (*pte &amp; 0xfff) | PTE_ADDR(da); // point to da *pte = (*pte &amp; ~PTE_V) | PTE_SWP; // modify term u_long va = ((u_long)i &lt;&lt; 22) + ((u_long)j &lt;&lt; 12); tlb_invalidate(asid, va); // invalidate TLB } } } } } /* Overview: * Walk through all the page table entries of pgdir * to find all the entries that point to da * and change these entries to satify swap ins. */ void page_swap_in_lookup(Pde *pgdir, u_int asid, u_long pa, u_long da) { for (u_int i = 0; i &lt; (1u &lt;&lt; 10); i++) { Pde *pgdir_entryp = pgdir + i; if (*pgdir_entryp &amp; PTE_V) { Pte *pte_entryp = (Pte *) KADDR(PTE_ADDR(*pgdir_entryp)); for (u_int j = 0; j &lt; (1u &lt;&lt; 10); j++) { Pte *pte = pte_entryp + j; if ((*pte &amp; PTE_SWP) &amp;&amp; PTE_ADDR(*pte) == PTE_ADDR(da)) { *pte = (*pte &amp; 0xfff) | PTE_ADDR(pa); // point to pa *pte = (*pte &amp; ~PTE_SWP) | PTE_V; // modify term u_long va = ((u_long)i &lt;&lt; 22) + ((u_long)j &lt;&lt; 12); tlb_invalidate(asid, va); // invalidate TLB } } } } } 小结其实整篇写下来也没有什么难度。可是在考场上要一下写那么多内核代码还是很困难的。特别是你不理解每个变量名是什么意思的时候。另外善用 pmap.h 和 mmu.h 中的地址相关宏也是很重要的。 PDX(va) 页目录偏移量，即 ((((u_long)(va)) &gt;&gt; 22) &amp; 0x03FF) PTX(va) 页表偏移量，即 ((((u_long)(va)) &gt;&gt; 12) &amp; 0x03FF) PTE_ADDR(pte) 获取页表项中的物理地址，即 ((u_long)(pte) &amp; ~0xFFF)，也就是获取高 20 位 PADDR(kva) kseg0 处虚拟地址 → 物理地址，即 (kva - ULIM)，ULIM 是 0x80000000 KADDR(pa) 物理地址 → kseg0 处虚拟地址，即 (kva + ULIM)，ULIM 是 0x80000000 u_long va2pa(Pde *pgdir, u_long va) 查页表，虚拟地址 → 物理地址 struct Page *pa2page(u_long pa) 物理地址 → 页控制块 u_long page2pa(struct Page *pp) 页控制块 → 物理地址 u_long page2kva(struct Page *pp) 页控制块 → kseg0 处虚拟地址","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://toby-shi-cloud.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"OS","slug":"OS","permalink":"https://toby-shi-cloud.github.io/tags/OS/"}],"author":"TobyShi"},{"title":"Object Oriented 2023 第一单元总结","slug":"OOUnit1","date":"2023-03-18T20:00:00.000Z","updated":"2023-03-18T20:00:10.189Z","comments":true,"path":"posts/oounit1.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/oounit1.html","excerpt":"","text":"前言第一单元作业主要要求是进行表达式化简。一共三次作业。第一次是较为简单的表达式，只涉及一层括号，加减乘和乘方。第二次作业增加了三角函数和嵌套括号。第三次作业增加了求导因子。 总结一下我的成果，很高兴在没有出现任何 Bug 的情况下通关第一单元，当然这很大程度上要归功于搭建了评测机。搭建一个好的评测机，一个人的努力是不够的，所以我在 GitHub 上开了一个私有的仓困，并邀请了几个朋友一起参与开发。当然了最后还是我写了绝大部分，有的朋友只是在白嫖，甚至还有的连白嫖都没有学会。但是也要感谢所有做出贡献的朋友，帮我发现了几个 Bug，还让我成功的 Hack 到了房友。 架构一个好的架构是整个项目成功的关键。第一次作业时我的架构就不太理想，十分混乱。于是在第二次作业中狠心重构。于是在效率和复杂度上都得到了极大层度的提升。 老师说很多同学的 Bug 都是因为深浅拷贝处理不当。所以我重构后的第二次作业，不再进行任何拷贝，一是减少了深拷贝开销，而是也不需要考虑拷贝出错的问题。 下面是我的架构的 UML 图： 简而言之，我所有的表达式相关类都是不可被 public 方法修改的，所有计算都将生成新的表达式。这样就不存在拷贝的问题了。当然了频繁运算会带来海量开销，所以我引入了 ExpressionBuilder 类，可以支持表达式加法，方法是直接修改，而不是拷贝。Expression 和 ExpressionBuilder 之间的关系是仿照 String 和 StrinBuilder 建立的。 另外，为了方便三角函数化简的实现，我的表达式存储方式是 整式*若干项三角函数+...+整式*若干项三角函数，这样就可以把三角函数单独拿出来化简了。 评测机使用 sympy 进行评测。使用递归下降和正则表达式 check 表达式的合法性。使用递归下降 generate 数据。这些都是较为常规的思路，就不再赘述了。 特别的一点是，我挑选出几十组特殊的数据，然后每次在本地评测后都将评测记录上传到云端，然后从云端索取当前最好的有效长度，以此为依据计算性能分。这在第一次作业还是发挥了一些作用，后续作业中，由于我们开发小组的集体摆烂式优化，所以大家都没那么在乎性能分，这个功能也就没有发挥出太大作用了。 得分 作业 1，强测 100 分，互测 +0 分； 作业 2，强测 97.9019 分，互测 8.5 分； 作业 3，强测 94.5088 分，互测 10.5 分。 鸣谢","categories":[{"name":"面向对象","slug":"面向对象","permalink":"https://toby-shi-cloud.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"OO","slug":"OO","permalink":"https://toby-shi-cloud.github.io/tags/OO/"},{"name":"Java","slug":"Java","permalink":"https://toby-shi-cloud.github.io/tags/Java/"}],"author":"TobyShi"},{"title":"Mac launchctl 自动后台任务","slug":"mac_launchctl_auto_background_task","date":"2023-03-10T11:00:00.000Z","updated":"2023-03-10T18:19:43.848Z","comments":true,"path":"posts/mac-launchctl-auto-background-task.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/mac-launchctl-auto-background-task.html","excerpt":"","text":"前言自从有了一个 mac mini 后，我就有了一个可以长时间不关机，不移动，不睡眠的主机，或者说，我可以把它当做一个私有的微型服务器。 正如前文所言，这个服务器将会至少运行 Alist 云盘，当然也可以顺便远程 ssh 用于跑代码。 由于在这个过程中踩了好一些坑，遂写本文记录。 ssh 排雷mac 是有集成 ssh 的，所以只需要在系统设置中打开 22 端口的远程登录权限就可以 ssh 连接上了。 可是因为我 ssh 连接 GitHub 的时候遇到了 kex_exchange_identification error，所以尝试了更改 sshd 的配置。不过有一回改配置改炸掉了，GitHub 能连接上了，但是其他设备连接本机却出现了 kex_exchange_identification error: connection reset。 我尝试了很多种方法，包括检查白名单黑名单等等，Google 和 StackOverflow 都搜索过，但是一直没有解决问题。 后来偶然有一天我想到，如果能直接输出 ssh 的日志不就能知道有什么问题了吗！ 果然，我在 Stack Overflow 上搜索 mac ssh log，找到了 logging - Where to find sshd logs on MacOS sierra - Stack Overflow。第一高赞回答 (by jerrythea) 就完美解决了我的问题。 当我获取到日志信息后，立马就发现了问题所在：sshd_config 配置重复定义了一个量！删掉这一行后，ssh 立马恢复正常！ launchctl 排雷在上一篇文章配置 Alist 的时候，配置了守护进程，不过我确实觉得那个守护进程好像根本没有作用。于是就长期把 Alist 挂在前台（我还以为只能这样）。 后来我在设置一个定时任务的时候，就发现了大问题。不仅定时无效，而且 launchctl start 也不能正常运行。 遂上网搜索，在知乎上找到一篇非常完美的回答 Mac 使用 Launchctl 设置后台定时任务无效的解决方法 - 知乎。其中最最关键的一步就是下载一个 launchcontrol 检测和管理所有的 launchctl tasks。 使用 mac 的 homebrew 安装： brew install launchcontrol 又是瞬间发现问题瞬间觉悟！ 这下我不仅定时任务成功了，Alist 也不用挂前台了，cpolar 也可以长期运行了。 参考资料 logging - Where to find sshd logs on MacOS sierra - Stack Overflow Mac 使用 Launchctl 设置后台定时任务无效的解决方法 - 知乎","categories":[{"name":"Shell","slug":"Shell","permalink":"https://toby-shi-cloud.github.io/categories/Shell/"}],"tags":[{"name":"Apple","slug":"Apple","permalink":"https://toby-shi-cloud.github.io/tags/Apple/"}],"author":"Toby Shi"},{"title":"Object Oriented 2023 作业 1","slug":"OOHW1","date":"2023-02-28T07:00:00.000Z","updated":"2023-02-28T07:16:40.291Z","comments":true,"path":"posts/oohw1.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/oohw1.html","excerpt":"","text":"写在前面由于目前距离第一单元作业结束还有很久很久，所以本文会较为简略的描述我的思路架构和测试。还请诸位谅解。 思路和架构总体而言，思路和架构都可以大部分模仿 Training （两个 Training，一个是 正则表达式/逆波兰表达式，一个是 递归下降）我模仿的第二个。我的思路是一个 Lexer 分析 Token， 一个 Parser 解析字符串，最后 Simplifie 一下表达式就可以了。 主要类结构 BaseExpr - interface - 基类。 Expression - 存储由 Parser 分析而来的，由 Term 构成的表达式 Term - 储存由 Parser 分析而来的，由 Factor 构成的表达式 Factor - 储存由 Parser 分析而来的，由 base ** index 构成，其中 base 可能是 Expression，Constant，或 Variable。 Lexer - 词法分析 Parser - 表达式解析 Simple - 化简表达式 测试自动化测试真好用。所以强烈建议大家都去自己写一下。如果自己不能写的话，记得请一个会写的大佬吃饭（确信）。 正确性测试第一单元作业是表达式化简。人生苦短，我用 Python。sympy 库可以非常非常方便的帮助你验证两个表达式是否是等价的（唯一需要注意的是需要去除前导零）。 这里就贴个代码给大家参考参考吧（应该很好理解吧？）。 def parse_leading_zero(s: str): \"\"\"Delete leading zero\"\"\" pattern = re.compile(r'(\\D)0+(\\d)') return pattern.sub(r'\\g&lt;1&gt;\\g&lt;2&gt;', s) def judge(s1: str, s2: str): \"\"\" s1 - input str; s2 - output str; return True if s1 == s2 else False \"\"\" if '(' in s2 or ')' in s2: return False try: ifunc = sympy.sympify(parse_leading_zero(' ' + s1)) ofunc = sympy.sympify(parse_leading_zero(' ' + s2)) return True if ifunc.equals(ofunc) else False except ValueError: # sympify error return False 性能分测试本次作业性能分可以理解为输出的化简后表达式越短分越高。不过由于你的表达式是否短取决于是否有其他同学比你更短。所以我们需要一个数据库保存大家测试的结果，然后找出每组数据最短的表达式的长度是多少，借此评估性能分。 这里我采用了 Lean Cloud 的免费数据库来储存数据，然后将测试脚本发给多人进行测试，这样下来，大家都知道自己的性能分处于什么水平了（当然这要求你的朋友们中都是些大佬）。 获得到得分后的计算就按照指导书中所述就可以啦： def get_grade(lp: int, lmin: int, base=1): x = lp / lmin if x &lt;= 1: return 1.0 * base elif x &gt;= 1.5: return 0.0 * base return (-31.8239 * x**4 + 155.9038 * x**3 - 279.2180 * x**2 + 214.0743 * x - 57.9370) * base Lean Cloud 的使用方法可以参考官方文档，这里就不详细介绍了。大家也可以使用其他数据库。 import leancloud leancloud.init('appID', 'appKey') HW1 = leancloud.Object.extend('HW1') def fetch(sh: str, length: int): query = HW1.query query.equal_to('hash', sh) data_list = query.find() if data_list: data = data_list[0] last_length = data.get('lmin') if last_length &gt; length: data.set('lmin', length) data.save() return length return last_length else: data = HW1() data.set('hash', sh) data.set('lmin', length) data.save() return length 数据生成随机生成器通常就按照指导书上的介绍一一生成就可以了。框架如下： # Generators def white_space_term(): length = randint(0, MAX_SINGLE_WHITE_SPACE_LENGTH) return reduce(lambda x, y: x + y, [choice(WHITE_SPACE[0]) for _ in range(length)], '') def integer_with_leading_zeros(): length = randint(1, MAX_INTEGER_LENGTH) return reduce(lambda x, y: x + y, [choice(DIGIT) for _ in range(length)], '') def integer_with_signal(): return choice(PLUS_MINUS + ['']) + integer_with_leading_zeros() def exponent(smaller=False): if smaller: return '**' + white_space_term() + choice(['+', '']) + choice(['0', '']) + choice(INDEX[:20]) return '**' + white_space_term() + choice(['+', '']) + choice(['0', '']) + choice(INDEX) def power_function(): if random() &gt; PROBABILITY_OF_POWER_WITHOUT_EXPONENT: return choice(VARIABLES) + white_space_term() + exponent() return choice(VARIABLES) def expression_factor(brackets): if random() &gt; PROBABILITY_OF_EXPRESSION_WITHOUT_EXPONENT: return '(' + expression(brackets - 1) + ')' + white_space_term() + exponent() return '(' + expression(brackets - 1) + ')' def factor(brackets): if brackets &gt; 0: res = random() if res &lt; PROBABILITY_OF_CONSTANT_FACTOR: return integer_with_signal() elif res &lt; PROBABILITY_OF_CONSTANT_FACTOR + PROBABILITY_OF_VARIABLE_FACTOR: return power_function() else: return expression_factor(brackets) else: if random() &lt; PROBABILITY_OF_CONSTANT_FACTOR \\ / (PROBABILITY_OF_CONSTANT_FACTOR + PROBABILITY_OF_VARIABLE_FACTOR): return integer_with_signal() else: return power_function() def term(brackets, factors=MAX_FACTOR_PER_TERM): if random() &lt; 1 / factors: return choice(PLUS_MINUS + ['']) + white_space_term() + factor(brackets) else: return term(brackets, factors - 1) + white_space_term() + '*' + white_space_term() + factor(brackets) def expression(brackets, terms=MAX_TERM_PER_EXPRESSION): if random() &lt; 1 / terms: return white_space_term() + choice(PLUS_MINUS + ['']) \\ + white_space_term() + term(brackets) + white_space_term() else: return expression(brackets, terms - 1) + choice(PLUS_MINUS) \\ + white_space_term() + term(brackets) + white_space_term() 强测和互测强测和互测均没有出现 bug。甚至更离谱的是，互测整个 room 都没有发现 bug。 不过根据其他同学反馈的信息，有一些数据值得一试： -1（单独的数字） 0*x**0（零的零次幂以及零乘以零次幂） 1+2+3\\t \\t \\t\\t（尾随空白符） (x+y+z)**8（几千项的展开） ---1（多重符号）","categories":[{"name":"面向对象","slug":"面向对象","permalink":"https://toby-shi-cloud.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"OO","slug":"OO","permalink":"https://toby-shi-cloud.github.io/tags/OO/"},{"name":"Java","slug":"Java","permalink":"https://toby-shi-cloud.github.io/tags/Java/"}],"author":"TobyShi"},{"title":"使用 Alist 和 IPV6 搭建私有云盘","slug":"alist_with_ipv6","date":"2023-02-21T12:00:00.000Z","updated":"2023-02-21T15:00:59.619Z","comments":true,"path":"posts/alist-with-ipv6.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/alist-with-ipv6.html","excerpt":"","text":"前言拥有多个设备的人总是会担心数据同步问题，这也是为什么Apple生态显得那么的出色。可是当你既拥有Windows又拥有Mac的时候，文件同步就困难了起来，特别是两台电脑还不在同一个局域网内时。 因此我虽然很早就在考虑搭建云盘，但是直到我拥有了Mac我才觉得这件事情非常非常急迫。于是我花了一个下午找到了一个合适的开源私有云——Alist。 当然仅搭建了一个网站是不够的，还需要做内网穿透，我尝试了cpolar，但是速度实在太慢了。不过好在我们学校校园网有IPV6，这就是得设备之间的直连成为可能。 下图是完工后的样子。真好看啊。 搭建过程整个搭建的过程算是十分的轻松加愉快的。因为Alist的官方文档实在是太详细了。 Alist官网：https://alist.nn.ci Alist官方文档：https://alist.nn.ci/guide/ Alist官方GitHub Release：https://github.com/Xhofe/alist/releases 安装流程如下： 前往官方GitHub Release下载最新版。 Mac的话下载Darwin版的，M系列芯片选arm64，Intel芯片选amd64 安装在服务器或者linux上就选linux的就好 Windows的也有对应的版本 对着教程run一边。 Daemon是守护进程的意思，避免进程被杀死，推荐也弄一弄。 打开http://localhost:5244，登陆admin账号开始配置。 首先当然是进行存储的配置，安装教程Storage相关的内容配置就可以啦。 然后“索引”可以配置一下，这样可以Ctrl+K或者Command+K搜索。 最后点击主页就可以开始使用了！ 内网穿透和IPV6然而云盘搭建好后，其他电脑还是无法访问。因为两个电脑不在同一个局域网内，服务端又没有公网IP。 那么就有两种选择，一种是内网穿透，另一种是IPV6直连。 先说内网穿透，我尝试了免费的内网穿透工具cpolar，成功了，但是效果不太理想，因为cpolar的带宽实在是太低了，用作网页还好，用作云盘……100kb的速度实在不能接受，比度盘还差劲。 剩下的就是IPV6，这个很简单，IPV6是给每个电脑都分配了唯一地址，所以直接查到本机的IPV6地址就可以访问了。如果你的地址是2aaa:bbb:ccc:ddd:eee:fff:555:666，那么在地址栏输入http://[2aaa:bbb:ccc:ddd:eee:fff:555:666]:5244这样的就可以啦。 不过我听说需要配置一下光猫的防火墙才行。不过我两台电脑都在校园网里面就不用管这个了。","categories":[{"name":"私有云","slug":"私有云","permalink":"https://toby-shi-cloud.github.io/categories/%E7%A7%81%E6%9C%89%E4%BA%91/"}],"tags":[{"name":"私有云","slug":"私有云","permalink":"https://toby-shi-cloud.github.io/tags/%E7%A7%81%E6%9C%89%E4%BA%91/"}],"author":"Toby Shi"},{"title":"你好博客 2 ？Hello Again?","slug":"HelloBlog2","date":"2023-01-02T08:00:00.000Z","updated":"2023-01-02T09:35:31.990Z","comments":true,"path":"posts/helloblog2.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/helloblog2.html","excerpt":"","text":"前言这次改动的主要目的是提供一个 oopre 的题面查看和数据下载的方式。正好借此机会进一步的了解 hexo 博客的构建机制，为未来的改动打下基础。 想要做的事儿想法是开一个子页面 oopre，然后 index 就是一个介绍，给出每次作业的链接。然后其下的页面就是每次作业，再在每次作业最后加上一个下载数据链接即可。 关于 Hexo这下我基本上是理解了 hexo 的构建思路。首先就是所有的东西都储存在 source 这个目录下（当然可以在 hexo 的 config 里面更改），然后渲染后的成品放在 public 目录下，最后 push 到 github 时，把 public 目录下的东西覆盖 .deploy_git 然后发布即可。所以实际上 github 仓库内容是和 .deploy_git 目录同步的，.deploy_git又是来自 public 的，public 则是由 source 渲染得到的。 下面重点说一下渲染过程。首先检查 hexo 的 config 下的 skip_render 变量，这个数组里面的内容是绝对不用渲染，会直接复制进 public 目录。（小贴士：** 表示递归遍历文件夹下所有文件和文件夹）然后其他在 source 目录下的文件均会被渲染。渲染方式是首先看 md 文件头部有没有 layout 变量，有 layout 的，在主题目录里的 layout 目录下找到对应的 layout 文件渲染，否则一律按照 posts 渲染。至于 source 目录里两个下划线开头的目录，显然有特殊用处的嘛…… 理解这些简单 Hexo 渲染流程之后，魔改就比较简单了，虽然我还不是很会写网页…… 关于这次的改动这次的改动的话主要是新增了 oopre 相关的几个 ejs 文件。 用于 index 的 oopre.ejs，这个主要功能是网页重定向，重定向至介绍 oopre 的那篇博客。 用于展示题面的 oopre_hw.ejs，主要由 post.ejs 复制而来，主要改动就是去除了一些不需要的判断语句，另外把内容页换成了 oopre-detail-toc.ejs。 _partial/oopre-detail-toc.ejs，从 _partial/post-detail-toc.ejs 复制而来。主要改动就是把 _partial/post-detail.ejs 换成了 _partial/oopre-detail.ejs。 _partial/oopre-detail.ejs，改动主要是 tag 和 category 恒定为 oopre，然后超链接恒为 /oopre。 参考资料 网页重定向：https://blog.csdn.net/penngrove/article/details/6933860","categories":[{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"网页","slug":"网页","permalink":"https://toby-shi-cloud.github.io/tags/%E7%BD%91%E9%A1%B5/"}],"author":"TobyShi"},{"title":"2022年 C++（即oopre）作业自测","slug":"oopre2022SelfTest","date":"2022-12-31T16:00:00.000Z","updated":"2023-01-03T06:13:21.557Z","comments":true,"path":"posts/oopre2022selftest.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/oopre2022selftest.html","excerpt":"","text":"前言 &amp; 注意事项 所有数据均为官方输入+我的 AC 输出。 由于第一单元输出的浮点数采用误差比较，所以您的答案和我不同也可能是正确的。 您可以考虑自行写一个评测机进行误差比较。 数据可能不全。通过所有测试点也并不代表您的程序没有问题。 本网站没有设置任何自动化评测。 推荐大家同时熟悉 Git 的使用。 请养成良好的代码风格。这是有分的！ 作业框架 &amp; 题面导航作业分为四个单元，第零单元，第一单元，第二单元，第三单元，其中第一和第二单元均有三次练习，为迭代开发。 第零单元 作业 0 hw0 第一单元 作业 1 hw1 作业 2 hw2 作业 3 hw3 第二单元 作业 4 hw4 作业 5 hw5 作业 6 hw6 第三单元 作业 7 hw7 Tips IDEA 打不开，提示 Internet Error，试试管理员模式运行这个： net stop winnat net start winnat 关于课程资料：下载链接 这里有一个简单的 Python 评测机供参考： def check(src1: list[str], src2: list[str]): ''' function check - this function is to check whether src2 is the same as src1 within acceptable error. param src1 - standard answer split by '\\\\n' param src2 - your answer split by '\\\\n' ''' while src1[-1] == '': src1 = src1[:-1] while src2[-1] == '': src2 = src2[:-1] if len(src1) != len(src2): return 'Your answer is too long/short.' for i, (l1, l2) in enumerate(zip(src1, src2)): l1 = l1.split() l2 = l2.split() if len(l1) != len(l2): return f'Your answer is too long/short on line {i+1}.' for e1, e2 in zip(l1, l2): if e1[-1] == ',' or e1[-1] == '.': if e1[-1] != e2[-1]: return f'Your answer differs from the standard answer on line {i+1}.' e1 = e1[:-1] e2 = e2[:-1] if e1 == e2: continue try: n1 = float(e1) n2 = float(e2) if abs(n1 - n2) / max(1, n1) &lt;= 1e-5: continue except ValueError: pass return f'Your answer differs from the standard answer on line {i+1}.' return 'Your answer is correct!'","categories":[{"name":"面向对象","slug":"面向对象","permalink":"https://toby-shi-cloud.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"OO","slug":"OO","permalink":"https://toby-shi-cloud.github.io/tags/OO/"},{"name":"Java","slug":"Java","permalink":"https://toby-shi-cloud.github.io/tags/Java/"}],"author":"TobyShi"},{"title":"计组实验的回顾","slug":"COreview","date":"2022-12-17T16:00:00.000Z","updated":"2022-12-29T07:57:31.213Z","comments":true,"path":"posts/coreview.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/coreview.html","excerpt":"","text":"「总结」 清一色的「通过」。 可惜没有考 P8。还是太摆烂啦！ 虚假的原因：考期了。 真实的原因：肝原！ 小技巧快速变换模块声明为模块实例从使用 Verilog 搭建 CPU 开始，我们就会遇到许多很长很长的模块定义，这个时候由于除了虚拟机上的 Sublime 以外，都没有自动生成模块实例的方式，手动将 input [31:0] addr 之类的模块声明转换为 .addr(addr) 之类的实例声明很困难。有没有什么快速的方案呢？当然是有的。使用正则表达式替换即可。 如在 VSCode 中：查找 (input|output)\\s*(\\[.*?\\])?\\s*(\\w+?)(,|\\n) 替换为 .$3($3)$4 即可。","categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}],"tags":[{"name":"CO","slug":"CO","permalink":"https://toby-shi-cloud.github.io/tags/CO/"}],"author":"Toby Shi"},{"title":"BUAA Tools 使用文档","slug":"BUAAToolsUsage","date":"2022-11-19T15:30:00.000Z","updated":"2022-11-26T13:32:07.056Z","comments":true,"path":"posts/buaatoolsusage.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/buaatoolsusage.html","excerpt":"","text":"前言本使用指南以 iPad 界面为主。在 iPhone 上使用体验略有不同。 界面登录界面如下图所示，登录界面简单而明显。输入您的统一身份认证的学号和密码即可登录。 Feature 对于密码错误和网络错误都会给予相应的提示。 可以使用 iCloud 钥匙串自动填充学号密码。 仅首次启动或手动退出登录后需要登录，再次启动 App 可以自动登录。 导航栏左侧导航栏会显示信息概览。默认顺序依次为 校园网流量，TD 次数，校园卡余额，健康打卡状态，核酸排队情况。 Feature 导航栏可以简单概览目前状态。 点击导航栏可以查看详细页面。 导航栏顺序可以设置。 详细视图大部分视图即为对应的官网。这里以点击每日健康打开为例。 Feature 会主动询问是否允许访问位置。 拥有与微信小程序或智慧北航一致的行为。 可以交互的真实网页。 设置界面可以调整视图顺序和对一些特定视图进行设置。设置界面由右上角任务图像唤出。 Feature 自由调整其中的任何设置。 醒目的退出登录标识。 可以取消设置。 其他 Feature 自由的在深色主题和浅色主题之间切换（跟随系统）。 自适应屏幕大小变化（支持台前调度的各个大小）。 可在 iPhone，iPad，以及 Mac 上运行。[^1] [^1]: 仅支持 iOS 16，iPadOS 16，或 macOS 13 及以上 从源代码安装 打开 Xcode 点击Xcode-Preferences或者使用快捷键command+,打开偏好设置，在 Accounts 中添加自己的 AppleID，添加成功后关闭偏好设置。 在左侧视图中点击App的名称，选中signing &amp; Capabilities，在 Signing 栏的 Development Team 中选中自己 AppleID 的名字。 鼠标悬停在中间正上方，会出现为什么构建应用程序，选中Any iOS Device，然后点击菜单栏Product-Archive。 在弹出菜单出选择 Distribute App，选择 Development，然后一路 Next 下去，就可以看到在相同目录下生成了一个文件夹，点开文件夹，就可以得到由你自己签名的 ipa 安装包。 自签安装包是可以安装使用的，但是有效期只有 7 天。因此可以考虑使用 AltStore 等自签工具来完成续签。AltStore 使用方法详见官网。 从 ipa 安装 安装前请确保您的设备在 iOS 16，iPadOS 16，或 macOS 13 及以上 从 GitHub 上下载 最新 ipa 文件，或者直接点击此链接下载 1.0 版本 推荐使用 AltSotre 侧载 记得定期重签名 Enjoy BUAA Tools AltStore 侧载方法 在电脑上安装 Alt Server，下载链接：https://altstore.io/ 将要 IOS 设备连接到电脑，然后使用 Alt Server 为 IOS设备安装 Alt Store 通常会要求你输入 Apple ID，因为任何 App 都需要 Apple ID 进行签名 如果不信任 AltStore 可以考虑重新注册一个新的 Apple ID 专门用于签名 在 IOS 设备上信任开发者（设置 - 通用 - VPN与设备管理） 打开 IOS 设备上的 AltStore，My Apps 栏中点击加号，选中 ipa 文件安装 注意需要在 7 天之内再次打开 AltStore 进行再次签名 签名时，必须要通过局域网或有线连接到装有 AltServer 的电脑（注意：北航校园网并非局域网） 如果忘记签名，IOS 提示应用不再可用，重新连接电脑安装 AltStore 然后再次给侧载应用签名即可 鸣谢特别感谢对本软件的提供建议或帮助的所有人。","categories":[{"name":"Swift编程","slug":"Swift编程","permalink":"https://toby-shi-cloud.github.io/categories/Swift%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://toby-shi-cloud.github.io/tags/Swift/"},{"name":"Apple","slug":"Apple","permalink":"https://toby-shi-cloud.github.io/tags/Apple/"}],"author":"Toby Shi"},{"title":"从教务网站上获取课表并导入iCloud日历","slug":"CDUTCMcalendar","date":"2022-10-14T20:30:00.000Z","updated":"2022-10-15T03:44:35.697Z","comments":true,"path":"posts/cdutcmcalendar.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/cdutcmcalendar.html","excerpt":"","text":"前言因为我家羽羽说她的课表一天一个样，每次都手动输入到日历中的话非常不方便，所以我打算帮她把课表从教务网站上爬出来，然后写在ics文件中，这样就可以一键导入了。 方案打开他们学校的教务网站，我就麻了，因为必须要输入验证码。这对自动化脚本来说是一个非常阴间的事情，所以考虑使用selenium，打开网页后，人工登录，程序检测到网页跳转后开始运行。 登录完成后就可以看到课表，默认是月课表，所以只需要让脚本自己翻页然后读取网页全部内容即可。通过F12，我们可以看到那些写着有课程信息的元素大致长什么样子，使用正则表达式即可爬取所有课程了。 使用在经历了漫长了写代码过程之后，终于到了运行的时候啦！看到一个程序能跑起来，真的是很开心的一件事！（大家也可以尝试复制下面的代码，自己运行试试看） 如果读者想要运行以下代码，需要进行下列步骤： 安装一个Python（这不是废话吗，建议是3.6以上，我自己用的3.10） 安装icalendar和selenium（在命令行执行pip install xxx） 如果你使用Chrome浏览器，请下载和你的Chrome匹配的chromedriver（见参考链接6），并为chromedriver添加环境变量，或放在脚本所在目录下。 如果你不使用Chrome浏览器，请自行搜索selenium如何使用你的浏览器（FireFox，Edge 和Safari等主流浏览器都是支持的，如果你使用其他浏览器，也可以尝试，因为它们大概率和Google Chrome使用同样的内核，只不过版本较老）另外，不要忘记更改chrome = Chrome()这条语句。 在脚本所在目录下打开命令行，输入python xxx即可运行（xxx是你的脚本名，通常你应该让后缀是.py）（通常安装python时会关联文件，所以双击运行也不是不可以） 日程会储存在cdutcm.ics中，许多日历App都支持.ics格式 配置更改有如下内容可能需要更改： 如果你不是使用的Chrome，更改chrome = Chrome()（第68行） 默认只会获取课程，而不会获取考试，若要获取考试请更改正则表达式中的上课任务（第32行） 默认是秋季学期课表，若要获取春季学期课表，更改while month != '八月'和while month != '二月'，交换八月金和二月的位置大概就可以了（第76和83行） 更改begin_date = datetime(2022, 8, 29, tzinfo=UTC8)中的2022, 8, 29为本学期开学第一周星期一的时间（第97行） 代码# coding=utf-8 import re from time import sleep from typing import Any import icalendar as ics from selenium.webdriver import Chrome from selenium.webdriver.common.by import By from datetime import datetime, timezone, timedelta UTC8 = timezone(timedelta(hours=8)) def create_event(name: Any, location: Any, dtstart: Any, dtend: Any, description: Any) -&gt; ics.Event: ''' create a single icalendar event :type of params: any Python native type or icalendar property type. ''' event = ics.Event() event.add('summary', name) event.add('location', location) event.add('dtstart', dtstart) event.add('dtend', dtend) event.add('description', description) return event def get_lesson_from_html(begin_date: datetime, html: str, begin_week: int = -1) -&gt; tuple[list[dict[str,str|datetime]],int]: REGEX = ( r'&lt;a class=\"fc-day-grid-event fc-h-event fc-event fc-start fc-end\" lay-tips=\"' r'&lt;table class=&amp;quot;kb-tips&amp;quot; border=&amp;quot;1&amp;quot;&gt;' r'&lt;tr&gt;&lt;th&gt;事件类型：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;上课任务&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'上课时间：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;(.*?)--(.*?)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'教学模式：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;.*?&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'教学形式：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;.*?&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'星期：&lt;/th&gt;&lt;td&gt;(\\d*?)&lt;/td&gt;&lt;th&gt;节次：&lt;/th&gt;&lt;td&gt;\\d*?&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;上课周次：&lt;/th&gt;&lt;td &gt;(\\d*?)&lt;/td&gt;&lt;th&gt;' r'课序号：&lt;/th&gt;&lt;td&gt;.*?&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'课程：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;\\[.*?\\]\\[.*?\\](.*?)\\[.*?\\]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'授课教师：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;(.*?)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'教学场地：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;(.*?)\\(?\\)?&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'上课班级：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;.*?&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'排课/上课：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;.*?&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'授课内容：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;((.|\\n)*?)&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;\" style=\"background-color: rgb\\(\\d+, \\d+, \\d+\\);\"&gt;' ) end_week = 0 lessons : list[dict[str,str|datetime]] = [] for match in re.findall(REGEX, html): day = int(match[2]) - 1 week = int(match[3]) - 1 if week &lt;= begin_week: continue end_week = max(end_week, week) today = begin_date + timedelta(days=7 * week + day) start_t = [int(x) for x in match[0].split(':')] end_t = [int(x) for x in match[1].split(':')] dtstart = today + timedelta(hours=start_t[0], minutes=start_t[1], seconds=start_t[2]) dtend = today + timedelta(hours=end_t[0], minutes=end_t[1], seconds=end_t[2]) name = str(match[4]) teacher = str(match[5]) location = str(match[6]) content = str(match[7]) lessons.append({'课程':name, '教学场地':location, '开始时间':dtstart, '结束时间':dtend, '教师':teacher, '授课内容':content}) return (lessons, end_week) def get_lesson(begin_date: datetime) -&gt; list[dict[str,str|datetime]]: # 第一步获取网页元素 chrome = Chrome() chrome.get('http://jwweb.cdutcm.edu.cn') while chrome.current_url != 'https://jwweb.cdutcm.edu.cn/new/welcome.page': sleep(1) # 这里需要手动输入账号密码验证码！ sleep(3) # 等待加载 iframe = chrome.find_element(By.XPATH, '/html/body/div[3]/div/div/div[2]/div/div/iframe') chrome.switch_to.frame(iframe) month = chrome.find_element(By.XPATH, '/html/body/div[1]/div/div[1]/div/div/div/div[1]/div[3]/h2').get_attribute('textContent').split(' ')[1] while month != '八月': chrome.find_element(By.XPATH, '/html/body/div[1]/div/div[1]/div/div/div/div[1]/div[1]/div/button[1]').click() sleep(3) # 等待加载 month = chrome.find_element(By.XPATH, '/html/body/div[1]/div/div[1]/div/div/div/div[1]/div[3]/h2').get_attribute('textContent').split(' ')[1] begin_week = -1 lessons : list[dict[str,str|datetime]] = [] while month != '二月': html = chrome.page_source lessons_gets, begin_week = get_lesson_from_html(begin_date, html, begin_week) lessons += lessons_gets chrome.find_element(By.XPATH, '/html/body/div[1]/div/div[1]/div/div/div/div[1]/div[1]/div/button[2]').click() sleep(3) # 等待加载 month = chrome.find_element(By.XPATH, '/html/body/div[1]/div/div[1]/div/div/div/div[1]/div[3]/h2').get_attribute('textContent').split(' ')[1] return lessons if __name__ == '__main__': calendar = ics.Calendar() calendar.add('version', '2.0') begin_date = datetime(2022, 8, 29, tzinfo=UTC8) lessons = get_lesson(begin_date) for lesson in lessons: name = lesson['课程'] location = lesson['教学场地'] dtstart = lesson['开始时间'] dtend = lesson['结束时间'] description = '教师：' + str(lesson['教师']) + '\\n\\n授课内容：\\n' + str(lesson['授课内容']) event = create_event(name, location, dtstart, dtend, description) calendar.add_component(event) with open('cdutcm.ics', 'wb') as f: f.write(calendar.to_ical()) 参考链接 「Selenium」- 在页面中，点击按钮（或元素） 使用Python在Selenium WebDriver中获取WebElement的HTML源代码 ICS在线课表制作 ICS在线课表制作 源码 如果意外地从 iCloud 中删除了日历、书签或通讯录 chromedriver下载与安装方法，亲测可用","categories":[{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/categories/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/tags/Python/"},{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/tags/%E8%84%9A%E6%9C%AC/"}],"author":"TobyShi"},{"title":"CO review：P0","slug":"CO_P0","date":"2022-10-05T11:05:00.000Z","updated":"2022-12-17T04:33:36.903Z","comments":true,"path":"posts/co-p0.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/co-p0.html","excerpt":"","text":"L0 五人投票题目概述裁判组有一个组长和四个组员（组员编号依次为 2'b00,2'b01,2'b10,2'b11）。每个组员都可以赞成、反对或是弃权。组长还拥有屏蔽投票权：屏蔽一位组员的投票，无论该组员投什么票，都视为弃权。投票的输入信息和输入信号对应如下： 意义赞成反对弃权屏蔽投票组长2'b002'b012'b102'b11组员2'b002'b01, 2'b112'b10- 当赞成票大于反对票时，表决结果为通过；反之为不通过。 输入输出描述","categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}],"tags":[{"name":"CO","slug":"CO","permalink":"https://toby-shi-cloud.github.io/tags/CO/"}],"author":"Toby Shi"},{"title":"使用junit4对java程序进行测试","slug":"JunitTestForObjectOriented","date":"2022-09-28T17:00:00.000Z","updated":"2023-03-30T18:34:27.340Z","comments":true,"path":"posts/junittestforobjectoriented.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/junittestforobjectoriented.html","excerpt":"","text":"前言总所周知测试是写程序必不可少的一项。对于IDEA和java来说，junit测试是一个比较好的选择。 安装junit首先在IDEA上安装junit的插件； 前往官方github下载junit； 在项目结构中添加junit依赖。 具体可以参考： IDEA中添加junit4的三种方法（详细步骤操作） IDEA中使用JUnit4单元测试 使用junitjunit最基础的使用，IDEA中使用JUnit4单元测试已经说的十分明白了，而且举的例子也非常出色，我在这里就不加赘述了。 大概来说，就是新建一个测试类，然后搞明白@Before，@After，@Test，assertEquals的基本意思就行了。 模拟输入和捕获输出上面junit的最基本的用法是测试方法或者类的行为是否正常，但是我们希望junit能够帮助我们测试样例数据，而我们的main方法的交互方式是输入和输出，而不是传参和返回，所以不能直接使用上面的方式。 因此我们通过输入输出重定向的方式来模拟输入和捕获输出。可以写以下代码： import org.junit.After; import org.junit.Before; import org.junit.Test; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.InputStream; import java.io.PrintStream; import static org.junit.Assert.assertEquals; public class SampleTest { private final InputStream systemIn = System.in; private final PrintStream systemOut = System.out; private ByteArrayInputStream testIn; private ByteArrayOutputStream testOut; @Before public void setUpOutput() { testOut = new ByteArrayOutputStream(); System.setOut(new PrintStream(testOut)); } private void provideInput(String data) { testIn = new ByteArrayInputStream(data.getBytes()); System.setIn(testIn); } private String getOutput() { return testOut.toString(); } @After public void restoreSystemInputOutput() { System.setIn(systemIn); System.setOut(systemOut); } @Test public void sample1() { final String testStringIn = \"\"\" 2021/7/1-Jack@JayChou :\"Hello!\";2021/7/3-JayChou@buaaer :\"Hahaha\"; 2021/7/5-JayChou@Mike :\"emmmm\"; 2021/7/8-JayChou@buaaer :\"Hahaha\"; 2021/7/8-JayChou:\"Hahaha\"; 2021/5/3-Mike:\"he@buaaer is unhappy\"; END_OF_MESSAGE qdate 2021/7/1 qsend \"JayChou\" qrecv \"buaaer\" \"\"\"; // 多行字符串，这里填样例输入 final String testStringOut = \"\"\" 2021/7/1-Jack@JayChou :\"Hello!\"; 2021/7/3-JayChou@buaaer :\"Hahaha\"; 2021/7/5-JayChou@Mike :\"emmmm\"; 2021/7/8-JayChou@buaaer :\"Hahaha\"; 2021/7/8-JayChou:\"Hahaha\"; 2021/7/3-JayChou@buaaer :\"Hahaha\"; 2021/7/8-JayChou@buaaer :\"Hahaha\"; 2021/5/3-Mike:\"he@buaaer is unhappy\"; \"\"\"; // 多行字符串，这里填样例输出 provideInput(testStringIn); MainClass.main(new String[0]); assertEquals(testStringOut, getOutput().replace(\"\\r\\n\", \"\\n\")); // 这里根据实际情况replace。一般来说是需要replace的 } } 文件读入以及多组数据有的时候，输入输出会特别的长，或者输入输出有很多组，使用上面这个死板的方法就会显得非常臃肿。所以我们需要进行文件读入。 文件读入使用BufferedReader和FileReader可以之间读取一个文件中的全部字符，并将其转化为String，具体代码如下： private String readFromFile(String fileName) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(fileName)); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { stringBuilder.append(line); stringBuilder.append('\\n'); } return stringBuilder.toString(); } 多组数据junit提供了一种运行多组测试的方式：Parameterized 具体来说，就是当你使用@RunWith (Parameterized.class)修饰class时，junit会首先调用被@Parameterized.Parameters修饰的static方法，这个方法必须返回一个Collection。然后junit会遍历这个Collection，把遍历到的值传入class的构造方法中，生成一个测试类的对象。然后再运行@Test方法。 完整代码这里我写了一种文件读入的方法，大家可以直接使用： import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import java.util.List; import java.util.HashMap; import java.util.ArrayList; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.InputStream; import java.io.PrintStream; import java.io.BufferedReader; import java.io.IOException; import java.io.FileReader; import java.io.File; import static org.junit.Assert.assertEquals; @RunWith (Parameterized.class) public class PublicTest // 类名根据需要重构 { private static final String PATH = \"./test/public_test\"; // 测试数据目录 private static final String SUFFIX_IN = \".in\"; // 测试点输入文件后缀 private static final String SUFFIX_OUT = \".out\"; // 测试点输出文件后缀 private final InputStream systemIn = System.in; private final PrintStream systemOut = System.out; private ByteArrayInputStream testIn; private ByteArrayOutputStream testOut; private final String inputFileName; private final String expectedFileName; public PublicTest(String input, String expected) { this.inputFileName = input; this.expectedFileName = expected; } @Before public void setUpOutput() { testOut = new ByteArrayOutputStream(); System.setOut(new PrintStream(testOut)); } private void provideInput(String data) { testIn = new ByteArrayInputStream(data.getBytes()); System.setIn(testIn); } private String getOutput() { return testOut.toString(); } @After public void restoreSystemInputOutput() { System.setIn(systemIn); System.setOut(systemOut); } private String readFromFile(String fileName) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(fileName)); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { stringBuilder.append(line); stringBuilder.append('\\n'); } return stringBuilder.toString(); } @Test (timeout = 10000) public void runTest() throws IOException { final String testStringIn = readFromFile(inputFileName); final String testStringOut = readFromFile(expectedFileName); provideInput(testStringIn); MainClass.main(new String[0]); assertEquals(testStringOut, getOutput().replace(\"\\r\\n\", \"\\n\")); } @Parameterized.Parameters public static List&lt;String[]&gt; getParams() { File file = new File(PATH); File[] fs = file.listFiles(); HashMap&lt;String, File&gt; fInMap = new HashMap&lt;&gt;(); HashMap&lt;String, File&gt; fOutMap = new HashMap&lt;&gt;(); assert fs != null; for (File f : fs) { String name = f.getName(); int index = name.lastIndexOf(\".\"); String prefix; String suffix; if (index == -1) { System.err.print(\"Warning: file \"); System.err.print(\"\\\"\" + PATH + \"/\" + f.getName() + \"\\\"\"); System.err.println(\" does NOT appear to be a test data.\"); continue; } prefix = name.substring(0, index); suffix = name.substring(index); if (suffix.equals(SUFFIX_IN)) { fInMap.put(prefix, f); } else if (suffix.equals(SUFFIX_OUT)) { fOutMap.put(prefix, f); } else { System.err.print(\"Warning: file \"); System.err.print(\"\\\"\" + PATH + \"/\" + f.getName() + \"\\\"\"); System.err.println(\" does NOT appear to be a test data.\"); } } ArrayList&lt;String[]&gt; testData = new ArrayList&lt;&gt;(); for (String name : fInMap.keySet()) { File in = fInMap.get(name); File out = fOutMap.get(name); if (out == null) { System.err.print(\"Warning: file \"); System.err.print(\"\\\"\" + PATH + \"/\" + name + SUFFIX_IN + \"\\\"\"); System.err.println(\" does NOT appear to have a corresponding out file.\"); continue; } String[] pair = { PATH + \"/\" + in.getName(), PATH + \"/\" + out.getName() }; testData.add(pair); } return testData; } } 测试结果测试结果如下： 细节注意测试是不能添加到平台上进行评测的（会CE），所以我们必须要采用git多分支的方式进行。 通常的做法是，我们首先master分支中创建README，然后commit，之后进行git checkout -b develop。一切改动都在develop分支进行。测试无误后，执行git checkout master以及git checkout develop src/*即可提交并推送到远程仓库。 后记从课程网站上下载数据非常麻烦，所以如果你有一个自动下载脚本的话…… 2022年10月2日 更新如果你运行测试出错了却找不到哪个文件出错了的话，可以在80行左右的位置，runTest方法里面，加入 System.err.println(\"File In: \" + inputFileName); System.err.println(\"File Ans: \" + expectedFileName); 这样就可以看见读入的文件是哪一个了，如下图所示： 2022年10月4日 更新之前的测试类只能测试一个文件夹下的数据，不能测试一个文件夹下的子文件夹下的数据，因此做出改进。 import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import java.util.List; import java.util.HashMap; import java.util.ArrayList; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.InputStream; import java.io.PrintStream; import java.io.BufferedReader; import java.io.IOException; import java.io.FileReader; import java.io.File; import static org.junit.Assert.assertEquals; @RunWith (Parameterized.class) public class InfiniteTest { private static final String PATH = \"./test\"; private static final String SUFFIX_IN = \".in\"; private static final String SUFFIX_OUT = \".out\"; private final InputStream systemIn = System.in; private final PrintStream systemOut = System.out; private ByteArrayInputStream testIn; private ByteArrayOutputStream testOut; private final String inputFileName; private final String expectedFileName; public InfiniteTest(String input, String expected) { this.inputFileName = input; this.expectedFileName = expected; } @Before public void setUpOutput() { testOut = new ByteArrayOutputStream(); System.setOut(new PrintStream(testOut)); } private void provideInput(String data) { testIn = new ByteArrayInputStream(data.getBytes()); System.setIn(testIn); } private String getOutput() { return testOut.toString(); } @After public void restoreSystemInputOutput() { System.setIn(systemIn); System.setOut(systemOut); } private String readFromFile(String fileName) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(fileName)); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { stringBuilder.append(line); stringBuilder.append('\\n'); } return stringBuilder.toString(); } @Test (timeout = 10000) public void runTest() throws IOException { System.err.println(\"The input file is \" + \"\\\"\" + inputFileName + \"\\\"\"); System.err.println(\"The answer file is \" + \"\\\"\" + expectedFileName + \"\\\"\"); final String testStringIn = readFromFile(inputFileName); final String testStringOut = readFromFile(expectedFileName); provideInput(testStringIn); MainClass.main(new String[0]); assertEquals(testStringOut, getOutput().replace(\"\\r\\n\", \"\\n\")); } private static final HashMap&lt;String, File&gt; fInMap = new HashMap&lt;&gt;(); private static final HashMap&lt;String, File&gt; fOutMap = new HashMap&lt;&gt;(); private static void getFiles(File directory) { assert directory != null; File[] files = directory.listFiles(); assert files != null; for (File f : files) { if (f.isDirectory()) { getFiles(f); continue; } String name = f.getPath(); int index = name.lastIndexOf(\".\"); String prefix; String suffix; if (index == -1) { System.err.print(\"Warning: file \"); System.err.print(\"\\\"\" + f.getPath() + \"\\\"\"); System.err.println(\" does NOT appear to be a test data.\"); continue; } prefix = name.substring(0, index); suffix = name.substring(index); if (suffix.equals(SUFFIX_IN)) { fInMap.put(prefix, f); } else if (suffix.equals(SUFFIX_OUT)) { fOutMap.put(prefix, f); } else { System.err.print(\"Warning: file \"); System.err.print(\"\\\"\" + f.getPath() + \"\\\"\"); System.err.println(\" does NOT appear to be a test data.\"); } } } @Parameterized.Parameters public static List&lt;String[]&gt; getParams() { getFiles(new File(PATH)); ArrayList&lt;String[]&gt; testData = new ArrayList&lt;&gt;(); for (String name : fInMap.keySet()) { File in = fInMap.get(name); File out = fOutMap.get(name); if (out == null) { System.err.print(\"Warning: file \"); System.err.print(\"\\\"\" + in.getPath() + \"\\\"\"); System.err.println(\" does NOT appear to have a corresponding out file.\"); continue; } String[] pair = { in.getPath(), out.getPath() }; testData.add(pair); } System.err.println(); return testData; } }","categories":[{"name":"面向对象","slug":"面向对象","permalink":"https://toby-shi-cloud.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"OO","slug":"OO","permalink":"https://toby-shi-cloud.github.io/tags/OO/"},{"name":"Java","slug":"Java","permalink":"https://toby-shi-cloud.github.io/tags/Java/"}],"author":"TobyShi"},{"title":"复现 A Tutorial on Linear and Differential Cryptanalysis中差分分析的例子","slug":"DifferentialCryptanalysis","date":"2022-09-23T10:30:00.000Z","updated":"2022-09-23T11:58:12.807Z","comments":true,"path":"posts/differentialcryptanalysis.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/differentialcryptanalysis.html","excerpt":"","text":"前言黑历史++😢😢😢 差分分析什么是差分分析呢？其实简单来说，就是考察明文的某一或某些位取反对密文的影响，所以这里的差分，实质就是异或的意思。其实感觉差分分析的过程和线性分析是基本一致的，所以这个博客我就写简单一点，实在记不住了还可以翻阅上一篇博客。虽然上一篇也不怎么详细（） Sbox拟合与线性分析一致，我们不得不对sbox进行拟合。同样的，对于输入的每一种可能的差分，我们穷举所有的输入1（输入2=输入1$\\oplus$输入差分）并记录由此带来的输出差分值（输出差分=输出1$\\oplus$输出2），计算出输入差分和输出差分对应的概率关系。通过16*16的256次计算，我们就可以整理出一张sbox的拟合表格。 子密钥分析同样的，我们选取概率较大的路径，可以得到明文对的一个差分和一个倒数第二轮输出的差分之间的概率，在论文中，选取的是$\\Delta P = [0000\\ 1011\\ 0000\\ 0000]$和$\\Delta U4 = [0000\\ 0110\\ 0000\\ 0110]$，概率是$\\frac{27}{1024}=0.0264$。 同样的我们穷举最后一轮相关联的密钥$k_2$和$k_4$，通过倒推得到$U4$，最后计算出当$\\Delta P$成立时$\\Delta U4$成立的概率即可。 由于我们选择的是高概率路径，所以最后成立概率最高的密钥就大概率是我们要找的密钥。 复现结果 其中子密钥用16进制表示，x表示未知（即和例子的路径无关）。 可见$k_2=2$且$k_4=4$的概率远超其他密钥组合，而且概率$0.0272863$与理论$\\frac{27}{1024}=0.0264$非常接近。 复现代码#include \"structure.hh\" // \\delta P = [0000 1011 0000 0000] // \\delta U4 = [0000 0110 0000 0110] const char* FileNamePlain = \"plaintexts.hex\"; const char* FileNameCipher = \"ciphertexts.hex\"; const char* FileNameCsv = \"diff.csv\"; ifstream fp, fc; ofstream fcsv; int pcPair[1&lt;&lt;16]; // use -1 stands for undefined const u16 deltaP = 0b0000101100000000; const u16 deltaU4 = 0b0000011000000110; inline u16 getU4(u16 _C, u16 key) { _C = key_mixing(_C, key); _C = substitution(_C, SBOX_INV); return _C; } int main() { fp.open(FileNamePlain, ios::binary | ios::in); fc.open(FileNameCipher, ios::binary | ios::in); memset(pcPair, 0xff, sizeof pcPair); int num = 0; for(;;) { u16 P, U; if(!fp.read((char*)&amp;P, 2)) break; if(!fc.read((char*)&amp;U, 2)) break; P = P &lt;&lt; 8 | P &gt;&gt; 8; U = U &lt;&lt; 8 | U &gt;&gt; 8; if(!~pcPair[P]) num++; pcPair[P] = U; // cerr &lt;&lt; hex &lt;&lt; P &lt;&lt; \"-&gt;\" &lt;&lt; U &lt;&lt; endl; // if(num == 100) break; } cerr &lt;&lt; \"num = \" &lt;&lt; num &lt;&lt; endl; // 有效明密文对个数（剔除重复） fp.close(); fc.close(); fcsv.open(FileNameCsv, ios::out); fcsv &lt;&lt; \"partial subkey\" &lt;&lt; \",\" &lt;&lt; \"prob\" &lt;&lt; endl; for(u16 k2 = 0; k2 &lt; 16; k2++) for(u16 k4 = 0; k4 &lt; 16; k4++) { int sum = 0, count = 0; u16 key = k2 &lt;&lt; 8 | k4; for(int i = 0; i &lt; 65536; i++) { if(pcPair[i] == -1) continue; if(pcPair[i^deltaP] == -1) continue; if(i &gt; (i ^ deltaP)) continue; // cerr &lt;&lt; (!(pcPair[i] == -1) &amp;&amp; !(pcPair[i^deltaP] == -1)) &lt;&lt; endl; sum++; if((getU4(pcPair[i],key) ^ getU4(pcPair[i^deltaP],key)) == deltaU4) count++; } double prob = count * 1.0 / sum; fcsv &lt;&lt; hex &lt;&lt; \"x\" &lt;&lt; k2 &lt;&lt; \"x\" &lt;&lt; k4 &lt;&lt; \",\" &lt;&lt; dec &lt;&lt; prob &lt;&lt; endl; if(!k2 &amp;&amp; !k4) cerr &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; endl; // 有效明密文对组的组数（剔除没有配对成组的） } fcsv.close(); return 0; } structure.hh是我自己写的一个头文件，里面是加密解密需要用到的函数以及Sbox和permutation连线的方式。由于加密解密以及分析都需要用到这些函数，所以就放在头文件里面了。 用cpp的原因是，bluebeen告诉我cpp比python快数十倍……python分析10万组明密文对要1分钟真的难受…… 因为差分分析需要符合要求的明密文对组，即明文需要满足$\\Delta P$的那个式子。所以是先把涉及到的明密文对存下来（代码里面是pcPair）然后在进行统计。 在进行差分分析的复现的时候，我突然想到一个问题，为什么论文上只用了1万对明密文对，而我用了10万对才能找出答案吗？我的复现究竟是出了什么样的问题呢？ 其实在上面的复现代码中，输出num和sum就已经揭晓了答案。根据输出，我的10万对明密文，只有num=5万的有效明密文对，然后再安装$\\Delta P$的要求配对后，只有sum=2万组。而论文直接说的就是1万组满足$\\Delta P$的明密文组。其实我也就用了两倍的数据而已。所以我的数据看起来比论文中要精确一些，但是也没有精确太多。 参考资料[1]Heys, Howard M . A Tutorial on Linear and Differential Cryptanalysis[J]. Cryptologia, 2002, 26(3):189-221.","categories":[{"name":"密码学","slug":"密码学","permalink":"https://toby-shi-cloud.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"密码分析","slug":"密码分析","permalink":"https://toby-shi-cloud.github.io/tags/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90/"}],"author":"TobyShi"},{"title":"复现 A Tutorial on Linear and Differential Cryptanalysis中线性分析的例子","slug":"LinearCryptanalysis","date":"2022-09-14T08:30:00.000Z","updated":"2022-09-23T11:57:49.044Z","comments":true,"path":"posts/linearcryptanalysis.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/linearcryptanalysis.html","excerpt":"","text":"前言这学期选了一门网安的科研课堂。第一节课就给了我一个下马威，直接阅读全英论文。好在我借助翻译读了一遍后，又听教授和同学们讲了一次，总算是把33页论文的第一部分，也就是Linear Cryptanalysis理解完了。 当然理解归一回事儿，实现是另一回事，所以昨天晚上（也就是9月13日下午），我就把论文中的例子基本复现出来了。 分组密码什么是分组密码？简而言之就是把数据分组，一组一组的加密。论文中的例子是一个非常简单的分组加密，数据每16bit为一组，采用的是SPN结构（即Substitution-Permutation Network）。这个加密会经过若干轮，每轮有如下步骤： Substitution 置换我们把16bit数据分成4bit一组，一共4组。将每组的4bit的值传入对应S-box中，S-box也会传出一个4bit的值。每个S-box的逻辑都可以查表得到。通常4个S-box应当不一样，但是作为例子，论文中选取了同样的S-box。其映射表如下： input 0 1 2 3 4 5 6 7 8 9 A B C D E F output E 4 D 1 2 F B 8 3 A 6 C 5 9 0 7 上表以16进制数表示4bit的值。 Permutation 排列排列就是一个连线的操作，当然也可以理解为一种映射。本步骤的输出就是输入的一种排列。下表是例子选用的排列： input 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 output 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16 上表中input=3, output=9表示输出中第9比特的值来自输入中第3比特的值。 Key Mixing 密钥加密所谓Key Mixing其实异常简单，就是给一个16bit的密钥，然后和16bit的输入进行异或，就得到了16bit的输出。 图示本图是从 A Tutorial on Linear and Differential Cryptanalysis 中摘下来的。 线性分析我原以为，我们可以直接从明密文对获取加密信息，并且破译密码。结果，我发现我们能做的不过是在Substitution和Permutation都已知的情况下去推测Subkey的值。但即便如此，也并非易事。 堆积引理$X_1,X_2,\\cdots,X_n$是二值分布，在它们相互独立的情况下，若$p_1=\\frac12+\\epsilon_1,\\cdots,p_n=\\frac12+\\epsilon_n$，则有：$$Pr(X_1 \\oplus \\cdots \\oplus X_n = 0) = \\frac12 + 2^{n-1}\\prod_{i=1}^{n}\\epsilon_i$$或者说：$$\\epsilon_{1,2,\\cdots,n} = 2^{n-1}\\prod_{i=1}^{n}\\epsilon_i$$我们称$\\epsilon$为bias，偏差，$\\epsilon=Pr-\\frac12$。 线性拟合S-box由于S-box是整个加密过程中唯一的非线性过程，也是本加密方法的安全性所在。为了破译密码，我们不得不对S-box进行线性拟合。 假设S-box的输入是$X_1,X_2,X_3,X_4$，输出是$Y_1,Y_2,Y_3,Y_4$，列出一组线性表达式，我们就可以算出输入随机的时候，该线性表达式成立的概率。譬如：$X_2 \\oplus X_3 = Y_1 \\oplus Y_3 \\oplus Y_4$，穷举后可知16个不同输入中有12个使得这个式子成立。则成立概率是$\\frac34$，偏差是$\\frac14$。 子密钥分析我们选取偏差较大的线性方程，然后模拟该方程所涉及到的输入的加密路劲，沿途应用堆积引理，最终可以得到一个明文和倒数第二轮的输出的一个线性表示的成立的概率的偏差的绝对值。 然后，穷举最后一个subkey的有涉及的位，根据密文逆推得到倒数第二轮输出，然后和明文一起，记录线性表达式成立的次数。选取很多组明文对（论文是1万组，我实测是10万组才能得到好的结果），计算线性表示成立概率。对于穷举到的每一个subkey，最后偏差绝对值最大的那一个就高概率是密钥，而且这个偏差和线性表达式的偏差的非常接近。 复现加密过程复现最开始是打算用Python的，后来发现Python位运算并不方便，所以就用C++了。贴个代码吧。 #include &lt;bitset&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;fstream&gt; #include &lt;sstream&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef unsigned char u8, u4; typedef unsigned short u16; const u4 sbox[] = { 0xE, 0x4, 0xD, 0x1, 0x2, 0xF, 0xB, 0x8, 0x3, 0xA, 0x6, 0xC, 0x5, 0x9, 0x0, 0x7, }; const u4 wire[] = { 0x0, 0x4, 0x8, 0xc, 0x1, 0x5, 0x9, 0xd, 0x2, 0x6, 0xa, 0xe, 0x3, 0x7, 0xb, 0xf, }; const u16 KEYS[] = { 0xed52, 0x3799, 0xac27, 0x47fc, 0x72b4, // 0xacbd, 密钥随便改 }; inline u16 permutation(u16); inline u16 substitution(u16); inline u16 key_mixing(u16, u16); inline u16 halfWordFunc(u16&amp;, const u16*, int); int main() { freopen(\"1.data.in\", \"rb\", stdin); freopen(\"1.data.out\", \"wb\", stdout); int ch1, ch2; while(~(ch1 = getchar())) { ch2 = getchar(); if(ch2 == EOF) ch2 = 0; u16 data = ch1 &lt;&lt; 8 | ch2; // 两个字节16bit为一组 halfWordFunc(data, KEYS, 4); ch1 = data &gt;&gt; 8; ch2 = data &amp; 0xff; putchar(ch1); putchar(ch2); } return 0; } inline u16 substitution(u16 data) { const u16 p1 = 0xf000, p2 = 0x0f00, p3 = 0x00f0, p4 = 0x000f; u16 d1 = (data &amp; p1) &gt;&gt; 12, d2 = (data &amp; p2) &gt;&gt; 8, d3 = (data &amp; p3) &gt;&gt; 4, d4 = data &amp; p4; d1 = sbox[d1] &lt;&lt; 12; d2 = sbox[d2] &lt;&lt; 8; d3 = sbox[d3] &lt;&lt; 4; d4 = sbox[d4]; return d1 | d2 | d3 | d4; } inline u16 permutation(u16 data) { bitset&lt;16&gt; bst = data, out; for(int i = 0; i &lt; 16; i++) { out[i] = bst[wire[i]]; } return (u16) out.to_ulong(); } inline u16 key_mixing(u16 data, u16 key) { return data ^ key; } inline u16 halfWordFunc(u16&amp; data, const u16* keys, int round) { for(int i = 1; i &lt; round; i++) { data = key_mixing(data, keys[i-1]); data = substitution(data); data = permutation(data); } data = key_mixing(data, keys[round-1]); data = substitution(data); data = key_mixing(data, keys[round]); return data; } 密码分析这次用的Python，虽然我还是觉得Python的位运算真的有些别扭…… import pandas as pd 'U4,6 ^ U4,8 ^ U4,14 ^ U4,16 ^ P5 ^ P7 ^ P8 = 0' SBOX = ( 0xE, 0x4, 0xD, 0x1, 0x2, 0xF, 0xB, 0x8, 0x3, 0xA, 0x6, 0xC, 0x5, 0x9, 0x0, 0x7, ) WIRE = ( 0x0, 0x4, 0x8, 0xc, 0x1, 0x5, 0x9, 0xd, 0x2, 0x6, 0xa, 0xe, 0x3, 0x7, 0xb, 0xf, ) INV_SBOX = ( 0xe, 0x3, 0x4, 0x8, 0x1, 0xc, 0xa, 0xf, 0x7, 0xd, 0x9, 0x6, 0xb, 0x2, 0x0, 0x5, ) '明文对个数' DATA_GROUP = 100000 if __name__ == '__main__': anlysis = pd.DataFrame(columns=['partial subkey', '|bias|']) # print(anlysis.info()) for k in range(256): fp = open('1.data.in', 'rb') fe = open('1.data.out', 'rb') k2 = k &gt;&gt; 4 k4 = k &amp; 0xf key = k2 &lt;&lt; 8 | k4 count_of_equal = 0 for i in range(DATA_GROUP): p = ord(fp.read(1)) &lt;&lt; 8 | ord(fp.read(1)) e = ord(fe.read(1)) &lt;&lt; 8 | ord(fe.read(1)) # print('%X-&gt;%X'%(p,e)) v = key ^ e u2 = INV_SBOX[(v&amp;0x0f00)&gt;&gt;8] u4 = INV_SBOX[(v&amp;0x000f)&gt;&gt;0] u_4_6 = (u2 &amp; 0b0100) &gt;&gt; 2 u_4_8 = (u2 &amp; 0b0001) &gt;&gt; 0 u_4_14 = (u4 &amp; 0b0100) &gt;&gt; 2 u_4_16 = (u4 &amp; 0b0001) &gt;&gt; 0 p_5 = (p &amp; 0x0800) &gt;&gt; 11 p_7 = (p &amp; 0x0200) &gt;&gt; 9 p_8 = (p &amp; 0x0100) &gt;&gt; 8 if u_4_14 ^ u_4_6 ^ u_4_8 ^ u_4_16 == p_5 ^ p_7 ^ p_8: count_of_equal += 1 anlysis = anlysis.append({'partial subkey':'%x %x'%(k2,k4), '|bias|':'%.04f'%(abs(count_of_equal - DATA_GROUP / 2) / DATA_GROUP)}, ignore_index=True) fp.close() fe.close() anlysis.to_csv('1.data.csv', index=False) 分析结果 可见第五轮subkey的第5-9bit是0b0010，第13-16bit是0b0100，还是十分准确的，而且bias是0.0308和论文给的理论值$\\frac1{32}=0.03125$还是十分接近的。 参考资料[1]Heys, Howard M . A Tutorial on Linear and Differential Cryptanalysis[J]. Cryptologia, 2002, 26(3):189-221.","categories":[{"name":"密码学","slug":"密码学","permalink":"https://toby-shi-cloud.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/tags/Python/"},{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"密码分析","slug":"密码分析","permalink":"https://toby-shi-cloud.github.io/tags/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90/"}],"author":"TobyShi"},{"title":"使用VScode进行Verilog仿真和波形查看","slug":"VerilogWithVScode","date":"2022-09-07T07:00:00.000Z","updated":"2022-09-28T17:14:41.608Z","comments":true,"path":"posts/verilogwithvscode.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/verilogwithvscode.html","excerpt":"","text":"前言计组课程官方推荐的Verilog仿真工具是ISE和VCS，评测机使用ISE。 但是在尝试在win11的wslg上安装ISE后，虽然成功了，但是难用的一批，而且还有bug，仿真总是失败等问题。而课程虚拟机里面的VCS按照课程组提供的方法，又无法生成波形文件，查阅资料后也一筹莫展，弄的我一头雾水。于是开始寻求其他工具。 在经过不同关键词检索以后，终于看到了本校学长的知乎专栏，推荐了一个VScode上进行Verilog仿真的方法！安装不仅非常简单，而且使用也很简单，爆杀20G的ISE和安装繁琐的VCS！而且是一个开源的，跨平台的软件，简直就是神一般的存在！ 下面的教程参考了学长的专栏 安装VScode不会吧不会吧，不会有人看这篇文章却没有安装VScode吧。 安装iVerilogiVerilog全称Icarus Verilog，官方下载方式在这里 安装的时候，基本上都可以随意，直接Next都行，不过记得添加PATH。就是一定要勾选“Add executable folders to the user PATH” 安装VScode插件你需要安装以下几个插件： Verilog-HDL/SystemVerilog/Bluespec SystemVerilog Verilog HDL Verilog Snippet WaveTrace 前三个插件，提供代码高亮，代码补全，一键运行等功能。 第四个插件，提供波形查看。（下载iVerilog的时候应该有下载GTKWave，你也可以用这个软件查看波形） 插件设置仅需要设置Verilog-HDL/SystemVerilog/Bluespec SystemVerilog插件 找到插件设置中的Verilog &gt; Linting: Linter 在下拉菜单中选中iverilog即可 使用写一端.v代码，然后写对应的testbench，然后在testbench里面，点击右上角的绿色的按钮，即可运行。 若想要生成波形文件，请在testbench中加上以下代码： initial begin $dumpfile(\"*.vcd\"); // * 是你希望产生的波形文件的名字 $dumpvars; end 注意：你必须在testbench的test运行结束之后，使用$finish;结束代码，否则波形文件不会结束，需要手动前往任务管理器，结束vvp.exe进程。 最后点开*.vcd文件就可以查看波形了（如果你下载了WaveTrace插件的话） testbench怎么写我就不教了吧，下面给一个测试代码吧。 示例代码// adder.v `timescale 1ns/1ps module adder ( input clk, input [31:0] in1, input [31:0] in2, output reg [31:0] out ); always @(posedge clk) begin out &lt;= in1 + in2; end endmodule // adder_tb.v `timescale 1ns/1ps `include \"adder.v\" module adder_tb; // Dump waveform to file (it would be impossible to view wavefrom without // this task) initial begin $dumpfile(\"adder_wave.vcd\"); $dumpvars(); end // Generate clock reg clk; initial clk = 0; always #10 clk = ~clk; // Input registers reg [31:0] a, b; wire [31:0] c; initial begin a = 0; b = 0; @(negedge clk); a = 32'h631; b = 341; @(negedge clk); $display(\"%d + %d = %d\\n\", a, b, c); a = 32'o1461; b = 0; @(negedge clk); $display(\"%d + %d = %d\\n\", a, b, c); #20; // Exit the simulation $finish; end // Device under test (our adder) adder dut(.clk(clk), .in1(a), .in2(b), .out(c)); endmodule 参考资料 https://zhuanlan.zhihu.com/p/414308549","categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}],"tags":[{"name":"CO","slug":"CO","permalink":"https://toby-shi-cloud.github.io/tags/CO/"},{"name":"VScode","slug":"VScode","permalink":"https://toby-shi-cloud.github.io/tags/VScode/"}],"author":"TobyShi"},{"title":"使用Xcode编译Swift App并分发到iPhone或iPad上","slug":"swift_xcode_ipa","date":"2022-08-30T06:00:00.000Z","updated":"2022-11-19T15:37:20.960Z","comments":true,"path":"posts/swift-xcode-ipa.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/swift-xcode-ipa.html","excerpt":"","text":"前言这学期成功选上了Swift程序设计这门课。虽然我还只会写Hello World，但是已经非常好奇如何将自己写的程序放在自己的iPhone中运行了，因此我们今天就来尝试一次。 代码Mac上的Xcode和iPad上的Playground差距还是有些大的。但是因为我的Mac是虚拟机，运行缓慢，所以我打算现在iPad上编写程序并测试运行。 由于我对Swift的了解还很少，所以我在网上下载了一个简单的程序作为测试。测试软件下载链接[1] 下载好后，在iPad的Playground中尝试导入，几乎都失败了。遂怀疑是版本问题。于是准备重新创建项目后复制粘贴源代码。粘贴好后会提示SwiftyJSON和Alamofire找不到，遂前往GitHub搜索，并在Playground的添加Swift软件包中粘贴链接导入软件包即可。省流：链接分别是https://github.com/SwiftyJSON/SwiftyJSON和https://github.com/Alamofire/Alamofire 点击运行，就能看到软件运行成功了。 分发由于iPad的Playground只能将应用发布到App Store，而这个需要用户成为Apple Developer Member，不仅需要验证和审核，还需要688元/年的会费，对学生来说没有必要，邃转向Xcode。 首先在Playground中将刚刚抄的App导出并存放在iCloud中（存什么地方不重要，方便导入电脑即可，也可以直接AirDrop）。随后打开Mac上的Xcode，打开项目，选择我们刚刚的导出的软件。项目导入后，Xcode会提示正在fetch SwiftyJSON和Alamofire，fetch结束后就可以command+R运行了。可见App在Simulator中运行状态也是正常的。 之后点击Xcode-Preferences或者使用快捷键command+,打开偏好设置，在Accounts中添加自己的AppleID，添加成功后关闭偏好设置。 在左侧视图中点击App的名称，选中signing &amp; Capabilities，在Signing栏的Development Team中选中自己AppleID的名字，在Bundle Identifier中填入应用唯一标识符，命名规范一般是com.AppName.DeveloperName 随后鼠标悬停在中间正上方，会出现为什么构建应用程序，选中Any iOS Device，然后点击菜单栏Product-Archive，编译成功后在Finder中打开文件夹，文件夹位置默认在~/Library/Developer/Xcode/Archives下的今天日期文件夹中（可在偏好设置的Location栏更改）。此可以看见一个扩展名为xcarchive的文件即说明编译成功。 最后，打开终端，cd到.xcarchive文件所在文件夹，输入以下命令：[2] xcodebuild -exportArchive -exportOptionsPlist Info.plist -archivePath *.xcarchive -exportPath myApp.ipa 其中Info.plist需要随便准备一个（如果你是直接在Xcode中创建的项目会附赠一个，你在项目文件中找到即可，如果是Playground创建的，则需要借用其他项目的），*.xcarchive为你的应用名称。在看到** EXPORT SUCCEEDED **后说明导出ipa成功。 会在当前文件夹下产生一个叫做myApp.ipa的文件夹，将其中的myApp.ipa文件拿出来，使用爱思助手就可以直接安装在iPad/iPhone中使用。[3] 注意：根据Apple官方的规定，免费用户只能将同一个程序分发给至多3个设备，且一次签名最多持续7天。 参考链接或注释 参考链接：https://sspai.com/post/70655 参考链接：https://www.jianshu.com/p/0171d6b49771 注释：由于Info.plist不匹配和免费签名的缘故，不能使用iTunes进行安装，只能使用第三方助手","categories":[{"name":"Swift编程","slug":"Swift编程","permalink":"https://toby-shi-cloud.github.io/categories/Swift%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://toby-shi-cloud.github.io/tags/Swift/"},{"name":"Apple","slug":"Apple","permalink":"https://toby-shi-cloud.github.io/tags/Apple/"}],"author":"Toby Shi"},{"title":"在WSL上安装ISE","slug":"installISEonWSL","date":"2022-08-07T18:00:00.000Z","updated":"2022-09-28T17:15:00.298Z","comments":true,"path":"posts/install-ise-on-wsl.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/install-ise-on-wsl.html","excerpt":"","text":"前言因为我们计组要使用到ISE，但是ISE和win11不相容，所以我就打算在wslg上安装ISE了。 安装过程 在官网下载Xilinx_ISE_DS_Lin_14.7_1015_1.tar:https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/vivado-design-tools/archive-ise.html 将压缩包解压（我是直接在Nautilus中双击解压的） cd到解压后的文件夹里面，通过ls可以看到如下内容 $ ls bin data idata labtools msg planahead_wp webpack xsetup common edk ise lib planahead sysgen xinfo 如果xsetup是可运行的，则直接sudo ./xsetup，否则先sudo chmod +x xsetup 如果安装报错： error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file 即缺少libncurses.so.5库文件，可以通过以下指令解决 $ sudo apt install apt-file $ sudo apt-file update $ sudo apt-file find libncurses.so.5 $ sudo apt install libncurses5 安装界面是图形界面，按照指引操作即可。全默认就行了，目录就在/opt/，Install cable drivers也不用安装 打开终端输入以下指令 $ cd /opt/Xilinx/14.7/ISE_DS $ ls EDK ISE PlanAhead SysGen Xilinx.lic common settings32.csh settings32.sh settings64.csh settings64.sh $ source settings64.sh . /opt/Xilinx/14.7/ISE_DS/common/.settings64.sh /opt/Xilinx/14.7/ISE_DS/common . /opt/Xilinx/14.7/ISE_DS/EDK/.settings64.sh /opt/Xilinx/14.7/ISE_DS/EDK . /opt/Xilinx/14.7/ISE_DS/PlanAhead/.settings64.sh /opt/Xilinx/14.7/ISE_DS/PlanAhead . /opt/Xilinx/14.7/ISE_DS/ISE/.settings64.sh /opt/Xilinx/14.7/ISE_DS/ISE $ ise 这里如果你的Ubuntu是32位的，请选择settings32.sh 至此ISE首次运行成功！ 打开后会提示没有License，那么我们直接需要在官网先申请到一个免费的License，然后在Help -&gt; Manage Licenses里面Load官网通过邮件发给你的Xilinx.lic即可 最后界面如下图： 运行注意到每次重启wsl后都必须重新输入第6步的指令非常麻烦，所以已有大佬写了脚本一键运行： 在任何地方新建文件，我选择的是/opt/Xilinx/14.7/ISE_DS/quickstart，内容如下： #!/bin/bash export LD_PRELOAD=/opt/Xilinx/usb-driver/libusb-driver.so ISE_DS_DIR=/opt/Xilinx/14.7/ISE_DS unset LD_PRELOAD export gmake=/usr/bin/make cd \"$ISE_DS_DIR\" source \"$ISE_DS_DIR\"/settings64.sh export LANG='' # reset locale to English to fix decimal/comma seperation \"$ISE_DS_DIR\"/ISE/bin/lin64/ise 并为脚本添加可执行权限： sudo chmod a+x /opt/Xilinx/14.7/ISE_DS/quickstart 在/usr/share/applications新建文件ISE.desktop，内容为： [Desktop Entry] Version=1.0 Name=ISE Exec=/opt/Xilinx/14.7/ISE_DS/quickstart Terminal=false Icon=/opt/Xilinx/14.7/ISE_DS/ISE/data/images/pn-ise.png Type=Application Categories=Development 其中Exec指向的就是上一步建立的脚本文件 之后可以使用gtk-launch ISE一键打开 还可以在Windows桌面创建快捷方式： 路径写wslg ~ -d Ubuntu20.04 gtk-launch ISE 不过这个其实是会自动添加到开始菜单的 后记由于ISE安装包巨大，如果保留非常占据空间，所以考虑删掉。但是删掉后并不能真正释放空间，这个时候需要使用磁盘压缩工具对wsl的虚拟磁盘进行压缩，方法如下： 以管理员身份运行powershell，并输入 PS C:\\Windows\\System32&gt; wsl --shutdown PS C:\\Windows\\System32&gt; diskpart DISKPART&gt; select vdisk file=\"D:\\WSL\\ext4.vhdx\" DISKPART&gt; attach vdisk readonly DISKPART&gt; compact vdisk DISKPART&gt; detach vdisk 其中file=后面是你的wsl虚拟磁盘的位置 关于驱动由于我还没有开始写任何一个测试程序，尚不知驱动是否正常，这里挖一个坑，改日再填。 参考链接 缺少libncurses.so.5怎么办：https://blog.csdn.net/qq_36393978/article/details/110948418 Ubuntu安装ISE教程：https://blog.csdn.net/weixin_43238031/article/details/89022601 Ubuntu安装ISE教程以及快捷启动脚本：https://blog.csdn.net/ixunmo/article/details/82194896 释放wsl占用空间：https://zhuanlan.zhihu.com/p/358528257 清理wsl磁盘占用：https://www.cnblogs.com/enrio/p/14222648.html","categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}],"tags":[{"name":"CO","slug":"CO","permalink":"https://toby-shi-cloud.github.io/tags/CO/"},{"name":"wsl","slug":"wsl","permalink":"https://toby-shi-cloud.github.io/tags/wsl/"}],"author":"Toby"},{"title":"将wsl迁移至D盘","slug":"moveWSLtoD","date":"2022-08-07T15:30:00.000Z","updated":"2022-09-28T17:14:49.584Z","comments":true,"path":"posts/movewsltod.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/movewsltod.html","excerpt":"","text":"前因因为下学期的计组课程需要用到ISE，然而ISE这样13年的软件和win11自然是不兼容了（经过网上大佬们的各种尝试，最终也只能安装到92%），所以在水群大佬的推荐下，我可以尝试使用WSLG（Windows Subsystem for Linux GUI）来运行ISE，于是我就先安装官网教程更新了wsl2，这个流程不太难，就不赘述了。 由于ISE体量巨大，所以不得不将WSL迁移到D盘以防止C盘爆炸。 过程迁移WSL需要使用工具LxRunOffline GitHub网址：https://github.com/DDoSolitary/LxRunOffline/releases如果迁移中遇到以下错误，则应该改用：https://ddosolitary-builds.sourceforge.io/LxRunOffline/LxRunOffline-v3.5.0-11-gfdab71a-msvc.zip [ERROR] Couldn't set the case sensitive attribute of the directory \"\\\\?\\C:\\Users\\toby2\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc\\LocalState\\\". Reason: Indicates that the directory trying to be deleted is not empty. 操作步骤注意：建议使用管理员身份运行powershell 查看已安装的子系统 ./LxRunOffline list 查看子系统所在目录 ./LxRunOffline get-dir -n [xxx] xxx是你在步骤1中查询到的子系统版本 迁移系统 ./LxRunOffline move -n [xxx] -d [ddd] xxx是你在步骤1中查询到的子系统版本 ddd是你期望移动到的路径 如果迁移系统中出现以下错误 [ERROR] The distro \"Ubuntu-20.04\" has running processes and can't be operated. \"wsl -t &lt;name&gt;\" or \"wsl --shutdown\" might help. 则使用快捷键Win+x再按g打开计算机管理重启服务LxssManager（也可以直接停止服务，迁移结束后再打开） 如果迁移后Ubuntu报错“拒绝访问” 使用下列指定为目录授权 icacls [ddd] /grant \"[user]:(OI)(CI)(F)\" ddd为移动后的路径 user为你的用户名 授权后建议重启LxssManager服务 Q&amp;A 如果Ubuntu报错“另一个程序正在使用此文件，进程无法访问” 以管理员身份运行以下指令 Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 然后按照要求重启电脑 造成此错误的原因估计为在未开启WSL的情况下使用资源管理器尝试打开WSL的磁盘镜像文件（.vhdx文件） 关于wslg的分辨率 目前wslg似乎只支持整数倍缩放，这非常不友好，但是可以手动启用非整数倍缩放 在wsl终端输入sudo vi /mnt/c/ProgramData/Microsoft/WSL/.wslgconfig新建一个文件（或者在Windows中找到C:\\ProgramData\\Microsoft\\WSL，并在其中新建文件.wslgconfig），文件内容如下： [system-distro-env] WESTON_RDP_DISABLE_FRACTIONAL_HI_DPI_SCALING=false 然后关闭wsl终端，打开powershell，输入wsl --shutdown即可 只不过150%缩放确实有点糊……","categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}],"tags":[{"name":"wsl","slug":"wsl","permalink":"https://toby-shi-cloud.github.io/tags/wsl/"}],"author":"Toby"},{"title":"CF R 809 (Div.2) 题解","slug":"CFR309","date":"2022-07-20T12:00:00.000Z","updated":"2022-07-21T16:10:20.663Z","comments":true,"path":"posts/codeforcesr809.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/codeforcesr809.html","excerpt":"","text":"比赛链接试题链接 官方题解 *注意：在本文中，题目大意没有还原题目背景，也没有细节说明，如果您没有看过题目，还请前往Codeforces官网看 A题题目大意给定长度为$n$且只包含$1$和$m$之间的正整数数列$a_1,a_2,\\cdots,a_n$，有一个长度为$m$的字符串$s$，初始时串$s$只包含字符B 接下来进行如下$n$次操作： 在第$i$次操作时$(1\\le i \\le n)$，你可以选择将$s$串的第$a_i$个字符或者第$(m+1-a_i)$个字符改成A。（注意，你可以对同一个位置进行若干次操作） 找到$n$次操作后，你能得到的字典序最小的串$s$ *本题有多组数据$(t\\le2000)$，对于每组数据$1\\le n,m \\le50$ 解析签到题。显然数列${a_n}$的顺序与答案没有关系，因此可以考虑贪心，每次操作都优先将靠前的位置换成A，如果靠前的位置已经被更换了，就换另一个，如果两个都被更换过当然这次操作无论如何都没有意义了。 代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 55; int n, m; int cnt[maxn]; char str[maxn]; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { memset(cnt, 0, sizeof cnt); memset(str, 'B', sizeof str); scanf(\"%d%d\", &amp;n, &amp;m); str[m] = 0; for(int i = 0; i &lt; n; i++) { int v; scanf(\"%d\", &amp;v); v = min(v, m - v + 1); // v和m-v+1的操作选择是一样的，所以就取小的存下来 cnt[v]++; // 这里我用的桶存ai } for(int i = 1; i &lt;= m; i++) // 实际上当i&gt;m/2时cnt[i]就恒为0了 { if(cnt[i]) str[i-1] = 'A'; // 优先把靠前的换为A if(cnt[i] &gt; 1) str[m - i] = 'A'; // 如果不止1次更换机会，就把靠后的也换掉 } puts(str); } return 0; } B题题目大意有一个长度为$n$的数列数列${c_i}$，其值为不超过$n$的正整数。 现在对每个$c_i$依次进行如下操作： 对$c_1$，你将它放在$(0,0)$点 对$c_i(2\\le i\\le n)$，记$c_{i-1}$放在了$(x,y)$点，则你可以将$c_i$放在$(x+1,y)$或$(x-1,y)$或$(x,y+1)$（但是不能放在$(x,y-1)$）当然前提是这些地方之前没有放置过其他的$c_i$ 若对于某个$(x,y)$和某个$s$，若$(x,y),(x,y+1),\\cdots,(x,y+s-1)$被放置了值相同的$c_i$，则定义这些点组成了一个“塔”。定义“塔”的高是$s$，“塔”被放置在了$(x,y)$处，“塔”的颜色为这些相同的$c_i$的值。 对于每一个不超过$n$的正整数$r$，独立的解决如下问题： 找到你能按规则构造出的，颜色为$r$​的，高度最高的“塔”。 *本题有多组数据$(t \\le 10^4)$，每组数据满足$n \\le 10^5$，对于全部数据$\\sum n \\le 2 \\cdot 10^5$ 解析注意到题目要求我们独立的处理每一个$r$而且只需要找出最高的“塔”，所以我们可以考虑对于固定的$r$，贪心的希望每个$r$都能刚好搭在上一个$r$上。抽象化的，记$c_i=c_j=r(i &lt; j)$，什么情况下$c_i$和$c_j$可以组成一个“塔”呢？ 进过简单的推理可以证明，当且仅当$(j-i)$为奇数时，$c_i$和$c_j$能构成一个“塔”。 必要性证明过程大致如下： 若$c_i$被放置在$(x,y)$处，则记$Q(c_i)=x+y$ 则根据题意有$Q(c_{i+1})=x+y\\pm1$，即$Q(c_{i+1}) \\equiv Q(c_i) + 1 \\ (mod\\ 2)$ 所以$Q(c_j) \\equiv Q(c_i) + j - i \\ (mod \\ 2)$ 因为$c_j$和$c_i$构成“塔”，所以$Q(c_j)-Q(c_i)=1$ 于是有$j-i \\equiv 1 \\ (mod \\ 2)$，即$(j-i)$是奇数 充分性证明略，因为只需要给出一个简单的构造，这里就留给读者吧~ 那么当$(j-i)$是偶数的时候会发生什么情况呢？由于$c_i$下面可能已经成塔了，但是$c_j$并没有，所以当出现$c_k=r$而且$(k-i)$是奇数时（此时显然$(k-j)$也是奇数）将$c_k$放在$c_i$的上面为“塔”填一层楼是更优的。 因此本题只需要记录第一个$c_i=r$的$i$值，然后之后一旦碰见$c_j=c_i$而且$(j-i)$是奇数时就ans++即可。 最后可以看出，对于不同的$r$，我们可以同时进行计算，至此本题解决。 代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 1e5 + 5; int n, c[maxn], cnt[maxn], lst[maxn]; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) { lst[i] = -1; cnt[i] = 0; } for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;c[i]); for(int i = 0; i &lt; n; i++) { if((i - lst[c[i]]) % 2 == 1 || lst[c[i]] == -1) cnt[c[i]]++; lst[c[i]] = i; } for(int i = 1; i &lt;= n; i++) { printf(\"%d \", cnt[i]); } puts(\"\"); } return 0; } C题题目大意给定长度为$n$的正整数列${h_i}$，你可以花费代价增大其中的值，每花费$1$点代价可以将一个$h_i$增大$1$。 描述$h_i$是“好看的”，当且仅当$i\\neq 1$且$i\\neq n$且$h_i &gt; h_{i-1}$且$h_i &gt; h_{i+1}$。 要求在保证整个数列“好看的”$h_i$最多的情况下花费的最小代价。 *本题有多组数据$(t \\le 10^4)$，对于每组数据$3 \\le n \\le 10^5$，$h_i \\le 10^9$，对于全部数据$\\sum n \\le 2 \\cdot 10^5$ 解析首先肯定要考虑如何让“好看的”$h_i$最多。根据题意，“好看的”$h_i$无法连续出现，也不能出现在收尾，所以必然可以使得而且最多只能使得$\\lfloor\\frac{n-1}{2}\\rfloor$个$h_i$成为“好看的”。而且当$n$是奇数时很容易解决，因为必然得是所有的$h_{2i}$都是“好看的”。所以接下来重点讨论当$n$是偶数的情况。 可以注意到，$n$是偶数时，必然存在一个$k$，使得$i&lt;k$时，当$i$是偶数时$h_i$是“好看的”，当$i&gt;k$时，当$i$是奇数时$h_i$是“好看的”。于是，我们可以考虑进行dp。 设dp[i]使得$h_i$是好看的前提下，保证前$i$个$h_i$中的“看好的”数最多，需要的最少花费，那么最终答案就是min(dp[n-2],dp[n-1])。下面考虑如何转移。进过我们之前的讨论，可以知道，当$i$是偶数时，前面一个好看的数必然是偶数，当$i$是奇数时则既可能是奇数有可能是偶数，于是转移方程如下： int w = max(h[i-1], h[i+1]) - h[i] + 1; // w就是变成“好看的”的代价 if(w &lt; 0) w = 0; if(i &amp; 1) dp[i] = min(dp[i-2], dp[i-3]) + w; else dp[i] = dp[i-2] + w; 最后需要注意一点，本题需要开long long 代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 1e5 + 5; int n, h[maxn]; long long ans, dp[maxn]; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { ans = 0; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;h[i]); if(n &amp; 1) { for(int i = 2; i &lt; n; i+=2) { int w = max(h[i-1], h[i+1]) - h[i] + 1; if(w &gt; 0) ans += w; } printf(\"%lld\\n\", ans); continue; } dp[0] = dp[1] = 0; for(int i = 2; i &lt; n; i++) { int w = max(h[i-1], h[i+1]) - h[i] + 1; if(w &lt; 0) w = 0; if(i &amp; 1) dp[i] = min(dp[i-2], dp[i-3]) + w; else dp[i] = dp[i-2] + w; } printf(\"%lld\\n\", min(dp[n-1], dp[n-2])); } return 0; } D题题目大意给定长度为$n$的正整数列${a_n}$以及正整数$k$，寻找一个长度为$n$，值不超过$k$的正整数列${p_n}$，使得下面这个式子的值最小$$\\max_{1 \\le i \\le n}(\\lfloor\\frac{a_i}{p_i}\\rfloor)-\\min_{1 \\le i \\le n}(\\lfloor\\frac{a_i}{p_i}\\rfloor)$$最后题目只要求输出上面这个式子可能的最小值，不需要输出对应${p_n}$ *本题分为D1和D2，仅仅是数据范围不同 *D1范围：有多组数据$(t \\le 100)$，对于每组数据$n,k,a_n \\le 3000$，且保证${a_n}$单调不减，且对于全部数据$\\sum n \\le 3000$ *D2范围：有多组数据$(t \\le 100)$，对于每组数据$n,k,a_n \\le 10^5$，且保证${a_n}$单调不减，且对于全部数据$\\sum n \\le 10^5$ 解析 1先考虑D1怎么做，这里根据范围可以猜想存在$O(n^2)$的做法可以通过D1。显然遍历所有的${p_n}$是非常不现实的，因为复杂度将达到$O(k^n)$，十分恐怖。 观察要求的式子，如果我们令$M=\\max_{1 \\le i \\le n}(\\lfloor\\frac{a_i}{p_i}\\rfloor)$以及$m=\\min_{1 \\le i \\le n}(\\lfloor\\frac{a_i}{p_i}\\rfloor)$，则我们可以考虑遍历$M$（从$a_n$遍历到$\\lfloor\\frac{a_n}{k}\\rfloor$），然后对于每个$M$尽可能的选取较大的$m$即可。具体做法如下： 对于固定$M$和每一个$a_i$，为了使得$m$最大，则必须让每个$\\lfloor\\frac{a_i}{p_i}\\rfloor$尽量大，即$p_i$尽量小，即有$\\lfloor\\frac{a_i}{p_i}\\rfloor \\le M$但是$\\lfloor\\frac{a_i}{p_i-1}\\rfloor &gt; M$，如果记$a_i = kM + r(0\\le r &lt; M)$可以解出$p_i = k (0 \\le r &lt; k)$或者$p_i = k + 1 (k \\le r &lt; M)$。借此我们就可以以$O(n^2)$的复杂度过D1。 代码1#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 3e3 + 5; const int inf = 1e9 + 7; int n, k, a[maxn]; int ans; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { scanf(\"%d%d\", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); if(a[n] / k == 0) { puts(\"0\"); continue; } ans = inf; for(int max_val = 3000; max_val &gt;= 1; max_val--) { int min_val = inf; for(int i = 1; i &lt;= n; i++) { int p = a[i] / max_val; if(p == 0 || a[i] / p &gt; max_val) p++; if(p &gt; k) p = k; if(a[i] / p &gt; max_val) { min_val = inf; break; } min_val = min(min_val, a[i] / p); } if(min_val &lt;= max_val) ans = min(ans, max_val - min_val); } printf(\"%d\\n\", ans); } return 0; } 解析2沿用D1的思路，但是我们希望可以在$O(log n)$的复杂度内找出给定$M$情况下的最大$m$。 要做到这一点，我们要先回过头来看看式子，$\\lfloor\\frac{a_i}{p_i}\\rfloor \\le M$但是$\\lfloor\\frac{a_i}{p_i-1}\\rfloor &gt; M$，但是这次我们不解出$p_i$而是反而解出$a_i$，于是有$(M+1)(p_i-1)\\le a_i &lt; (M+1)p_i$。由于对于相同的$p_i$当然是$a_i$越小才能影响到$m$的值，所以对于每一个$M$，遍历$p$（从1开始直到$(p+1)\\cdot(M+1)&gt;a_n$为止），然后对于每一个$p$，可以用二分的方式（因为$a_n$有序）找到第一个不小于$(M+1)(p_i-1)$的$a_i$，用$\\lfloor\\frac{a_i}{p}\\rfloor$更新$m$（取min）。 于是复杂度来到了$O(\\sum\\frac{n}{i}log n)$，可以证明$O(\\sum\\frac{n}{i})=O(nlogn)$所以总的复杂度是$O(nlog^2n)$。但是这个复杂度并不是最优的（虽然对于1e5的数据已经足够了）。我们可以考虑预处理而非每次都二分来寻找$a_i$，这使得复杂度降到$O(nlogn)$。 代码2#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 1e5 + 5; const int inf = 1e9 + 7; int n, k, a[maxn]; int ans, max_val, min_val; int great_min[maxn]; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { scanf(\"%d%d\", &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); if(a[n-1] / k == 0) { puts(\"0\"); continue; } n = unique(a, a + n) - a; // 去重，显然重复的ai对本题无影响，当然这个语句本来也不是必须的 for(int i = 0, *p = a; i &lt;= a[n-1]; i++) { if(*p &lt; i) p++; great_min[i] = *p; // 预处理，即great_min[x]表示不小于x的最小的ai } max_val = a[n-1], min_val = a[0]; ans = max_val - min_val; while(max_val &gt;= a[n-1] / k) { for(int i = 0; i * (max_val+1) &lt;= a[n-1]; i++) // 这里i其实是遍历的(p-1) { min_val = min(min_val, great_min[i*(max_val+1)] / (i+1)); } ans = min(ans, max_val - min_val); max_val--; } printf(\"%d\\n\", ans); } return 0; } E题题目大意给定一个$n$个点$m$条边的无向无权连通图，点编号从1到n，边编号从1到m。 给出$q$次询问，每次询问包括两个正整数$l$和$r$。你需要找到你一个最小的满足下列要求的$k$： 对任何满足$l \\le a \\le b \\le r$的点对$(a,b)$，点$a$和点$b$可以只使用前$k$条边（即编号从1到k的边）的情况下连通 *本题有多组数据$(t \\le 1000)$，对每个数据$n\\le10^5$，$m,q\\le2\\cdot10^5$，对全部数据$\\sum n\\le10^5$，$\\sum m,\\sum q\\le2\\cdot10^5$ 解析本题第一眼看的时候有一种二分答案+可持续化并查集的感觉。然而可惜的是，每次询问不是检查两个点是否连通，而是检查一个区间是否连通。那么提到区间，就可以想到一种做法是倍增。而且我们惊人的发现两个区间的合并是如此的简单，只要有公共点，两个区间合并就是对$k$取max。于是问题转化为如何求得每两个相邻点的$k$。 转化到这个地步了，当然可以直接二份答案+可持续化并查集，可是复杂度将来到3个log，而且写起来还很麻烦，根本用不着。于是考虑只使用普通的并查集，而且不用路径压缩，而是改为启发式合并的并查集，这样做的好处就是每加一条边的时候，都只检查小集合里面的所有点有没有和相邻的点相连。复杂度是$O(nlogn)$。 于是本题总复杂度为$O(nlogn+nlogn+qlogn)$即$O((n+q)logn)$ 代码#include &lt;vector&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 1e5 + 5; const int c_pow2[] = { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072 }; int n, m, q; int fa[maxn]; int ans[maxn][20]; vector&lt;int&gt; forest[maxn]; inline int c_log2(int x) { return upper_bound(c_pow2, c_pow2 + 18, x) - c_pow2 - 1; } int main() { int T; scanf(\"%d\", &amp;T); while(T--) { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i++) { fa[i] = i; ans[i][0] = -1; vector&lt;int&gt;({i}).swap(forest[i]); } for(int i = 1; i &lt;= m; i++) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if(fa[v] == fa[u]) continue; if(forest[fa[v]].size() &gt; forest[fa[u]].size()) swap(u, v); int fa_v = fa[v]; for(int x : forest[fa_v]) { fa[x] = fa[u]; forest[fa[u]].push_back(x); } for(int x : forest[fa_v]) { if(x != 1 &amp;&amp; ans[x-1][0] == -1 &amp;&amp; fa[x-1] == fa[x]) ans[x-1][0] = i; if(x != n &amp;&amp; ans[x][0] == -1 &amp;&amp; fa[x+1] == fa[x]) ans[x][0] = i; } vector&lt;int&gt;().swap(forest[fa_v]); } vector&lt;int&gt;().swap(forest[fa[1]]); for(int pk = 1; c_pow2[pk] &lt; n; pk++) { for(int i = 1; i &lt;= n; i++) { if(c_pow2[pk] + i &gt; n) break; ans[i][pk] = max(ans[i][pk-1], ans[i+c_pow2[pk-1]][pk-1]); } } while(q--) { int l, r; scanf(\"%d%d\", &amp;l, &amp;r); int pk = c_log2(r - l); printf(\"%d \", max(ans[l][pk], ans[r-c_pow2[pk]][pk])); } puts(\"\"); } return 0; }","categories":[{"name":"竞赛","slug":"竞赛","permalink":"https://toby-shi-cloud.github.io/categories/%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://toby-shi-cloud.github.io/tags/Codeforces/"},{"name":"算法","slug":"算法","permalink":"https://toby-shi-cloud.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"Toby Shi"},{"title":"学生评教自动化脚本","slug":"EvaluationAutomationScript","date":"2022-07-04T13:00:00.000Z","updated":"2022-07-28T16:18:36.387Z","comments":true,"path":"posts/evaluation-automation-script.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/evaluation-automation-script.html","excerpt":"","text":"脚本内容javascript:function ttj(){ firrr=window.top.document.getElementById(\"iframename\").contentWindow; firrr.alert=function(){return true}; firrr.confirm=function(){return true}; a=firrr.$(\"input[name^=tabmapzb]\"); b=firrr.$(\"span.yellow\"); if(a.length!==0){ a[1].click(); a[5].click(); a[10].click(); a[15].click(); a[20].click(); a[25].click(); }else{ b[1].firstElementChild.click() } var selections = firrr.document.getElementsByTagName(\"select\"); for(var i = 0 ; i&lt; selections.length; i++){ selections[i].value = \"1\"; } firrr.tj(); } firrr=window.top.document.getElementById(\"iframename\").contentWindow; setInterval(\"firrr.$.onload = ttj()\",1400); 使用方法 登录教务系统 请勿更改主题设置 在“教学评价”中找到“学生评教” 点击“开始评教”，进入下面这个界面 按F12打开控制台，并找到Console或者“控制台” 在控制台中粘贴代码并回车运行 评教全部完成后刷新网页即可 附录在附上一个可以提前下载课表的神奇代码 var ele = $(\"#iframename\").contents().find(\"#xnxq\"); for(let i=0;i&lt;4;i++){ if(ele.children().eq(i).text()==\"2022秋季\"){ console.log(\"发现目标，正在等待下载\"); ele[0].selectedIndex = i; break; } } document.getElementsByTagName(\"iframe\")[0].contentWindow.exportExcel();","categories":[{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/categories/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/tags/%E8%84%9A%E6%9C%AC/"}],"author":"Unknown"},{"title":"蓝桥杯2022决赛参赛记录","slug":"LanQiaoCup2022Final","date":"2022-06-18T13:50:00.000Z","updated":"2022-11-26T11:42:36.966Z","comments":true,"path":"posts/lanqiaocup2022final.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/lanqiaocup2022final.html","excerpt":"","text":"A 题：小蓝与钥匙问题描述 小蓝是幼儿园的老师，他的班上有 28 个孩子，今天他和孩子们一起进行了一个游戏。 小蓝所在的学校是寄宿制学校，28 个孩子分别有一个自己的房间，每个房间对应一把钥匙，每把钥匙只能打开自己的门。现在小蓝让这 28 个孩子分别将自己宿舍的钥匙上交，再把这 28 把钥匙随机打乱分给每个孩子一把钥匙，有$28! = 28\\times27\\times \\cdots \\times1 $种分配方案。小蓝想知道这些方案中，有多少种方案恰有一半的孩子被分到自己房间的钥匙（即有 14 个孩子分到的是自己房间的钥匙，有 14 个孩子分到的不是自己房间的钥匙）。 答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 考场思路显然这个题分为两步，一是有14个同学分到了自己的钥匙，二是剩下的14个同学都没有分到自己的钥匙，记方案数为$Q$，则有：$$Q = C_{28}^{14} \\cdot D_{14}$$其中$D_{14}$为14的全错位排列。全错位排列也称“欧拉装错信箱问题”，其计算可用容斥原理，公式如下：$$D_n = \\sum_{i=0}^{n} (-1)^i \\cdot C_n^i \\cdot (n-i)!$$或者：$$D_n = n! \\cdot \\sum_{i=0}^{n} \\frac{(-1)^i}{i!}$$于是有方案数$Q=1,286,583,532,342,313,400$ B 题：排列距离问题描述 小蓝最近迷上了全排列，现在他有一个长度为 17 的排列，里面包含的元素有：abcdefghijklnopqr，即 a 至 r 中除了 m 以外的所有小写字母，这 17个字母在任何一个排列中都恰好出现一次。前面几个排列依次是： 第 1 个排列为：abcdefghijklnopqr； 第 2 个排列为：abcdefghijklnoprq； 第 3 个排列为：abcdefghijklnoqpr； 第 4 个排列为：abcdefghijklnoqrp； 第 5 个排列为：abcdefghijklnorpq； 第 6 个排列为：abcdefghijklnorqp； 第 7 个排列为：abcdefghijklnpoqr； 第 8 个排列为：abcdefghijklnporq； 第 9 个排列为：abcdefghijklnpqor； 第 10 个排列为：abcdefghijklnpqro。 对于一个排列，有两种转移操作：1）转移到其下一个排列。如果当前排列已经是最后一个排列，那么下一个排列就是第一个排列。2）转移到其上一个排列。如果当前排列是第一个排列，那么上一个排列就是最后一个排列。小蓝现在有两个排列，分别为排列 A：aejcldbhpiogfqnkr，以及排列B：ncfjboqiealhkrpgd，他现在想知道，在只有上述两种转移操作的前提下，排列 A 最少转移多少次能得到排列 B。 答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 考场思路显然只要知道了排列A和排列B分别是第几个排列就可以了。 因此我们使用康托展开（Cantor expansion）就可以了。若记排列$\\lambda$为$a_1,a_2,a_3,\\dots,a_n$，则有：$$X_{\\lambda} = q_1 \\cdot (n-1)! + q_2 \\cdot (n-2)! + \\cdots + q_n \\cdot 0!$$其中$q_i$表示$a_i$在$a_i,a_{i+1},\\dots,a_n$中是第$q_i$小的数，则$X_\\lambda$表示排列$\\lambda$是第$X_\\lambda$个排列。（注：这里第几小的数和第几个排列都从0开始标号，计算会比较方便） 最后我的结果是：排列A的编号是$4,542,892,071,974$，排列B的编号是$254,081,962,595,831$，最终答案取$min{X_A - X_B + 19!, X_B - X_A} = 106,148,357,572,143$即可。 C 题：内存空间问题描述 小蓝最近总喜欢计算自己的代码中定义的变量占用了多少内存空间。 为了简化问题，变量的类型只有以下三种：int：整型变量，一个 int 型变量占用 4 Byte 的内存空间。long：长整型变量，一个 long 型变量占用 8 Byte 的内存空间。String：字符串变量，占用空间和字符串长度有关，设字符串长度为 L，则字符串占用 L Byte 的内存空间，如果字符串长度为 0 则占用 0 Byte 的内存空间。 定义变量的语句只有两种形式，第一种形式为：type var1=value1,var2=value2...;定义了若干个 type 类型变量 var1、var2、…，并且用 value1、value2…初始化，多个变量之间用’,’ 分隔，语句以’;’ 结尾，type 可能是 int、long 或 String。例如 int a=1,b=5,c=6; 占用空间为 12 Byte；long a=1,b=5; 占用空间为 16 Byte；String s1=””,s2=”hello”,s3=”world”; 占用空间为 10 Byte。 第二种形式为：type[] arr1=new type[size1],arr2=new type[size2]...;定义了若干 type 类型的一维数组变量 arr1、arr2…，且数组的大小为size1、size2…，多个变量之间用’,’ 进行分隔，语句以’;’ 结尾，type 只可能是 int 或 long。例如 int[] a1=new int[10]; 占用的内存空间为 40Byte；long[] a1=new long[10],a2=new long[10]; 占用的内存空间为160 Byte。 已知小蓝有 T 条定义变量的语句，请你帮他统计下一共占用了多少内存空间。结果的表示方式为：aGBbMBcKBdB，其中 a、b、c、d 为统计的结果，GB、MB、KB、B 为单位。优先用大的单位来表示，1GB=1024MB，1MB=1024KB，1KB=1024B，其中 B 表示 Byte。如果 a、b、c、d 中的某几个数字为 0，那么不必输出这几个数字及其单位。题目保证一行中只有一句定义变量的语句，且每条语句都满足题干中描述的定义格式，所有的变量名都是合法的且均不重复。题目中的数据很规整，和上述给出的例子类似，除了类型后面有一个空格，以及定义数组时 new 后面的一个空格之外，不会出现多余的空格。 输入格式 输入的第一行包含一个整数 T ，表示有 T 句变量定义的语句。接下来 T 行，每行包含一句变量定义语句。 输出格式 输出一行包含一个字符串，表示所有语句所占用空间的总大小。 测试样例 样例输入 样例输出 1long[] nums=new long[131072]; 1MB 4int a=0,b=0;long x=0,y=0;String s1=”hello”,s2=”world”;long[] arr1=new long[100000],arr2=new long[100000]; 1MB538KB546B 样例说明 样例 1，占用的空间为 131072 × 8 = 1048576 B，换算过后正好是 1MB，其它三个单位 GB、KB、B 前面的数字都为 0 ，所以不用输出。 样例 2，占用的空间为 4 × 2 + 8 × 2 + 10 + 8 × 100000 × 2 B，换算后是1MB538KB546B。 规模与约定 对于所有评测用例，1 ≤ T ≤ 10，每条变量定义语句的长度不会超过 1000。所有的变量名称长度不会超过 10，且都由小写字母和数字组成。对于整型变量，初始化的值均是在其表示范围内的十进制整数，初始化的值不会是变量。对于 String 类型的变量，初始化的内容长度不会超过 50，且内容仅包含小写字母和数字，初始化的值不会是变量。对于数组类型变量，数组的长度为一个整数，范围为：$[0, 2^{30}]$，数组的长度不会是变量。T 条语句定义的变量所占的内存空间总大小不会超过 1 GB，且大于 0 B。 考场思路这个题，怎么说呢，几乎就是纯模拟吧大概。 首先每行的首个字符串就是类型说明，然后对于不同的类型找不同的符号就可以了。 比如int和long型，就找有多少个“,”；数组就找“int[”和“long[”；字符串就找“””就可以了。 部分代码如下： void solve_int(const char* str) { while(*str) { if(*str == ',' || *str == ';') ans += 4; str++; } } void solve_int_arr(const char* str) { const char* tmp; // const char* lst = str + strlen(str); while((tmp = strstr(str, \"int[\")) != NULL) { tmp += 4; int num = 0; while(isdigit(*tmp)) { num = num * 10 + (*tmp - '0'); tmp++; } str = tmp; ans += 4 * num; } } void solve_long(const char* str) { while(*str) { if(*str == ',' || *str == ';') ans += 8; str++; } } void solve_long_arr(const char* str) { const char* tmp; // const char* lst = str + strlen(str); while((tmp = strstr(str, \"long[\")) != NULL) { tmp += 5; int num = 0; while(isdigit(*tmp)) { num = num * 10 + (*tmp - '0'); tmp++; } str = tmp; ans += 8 * num; } } void solve_String(const char* str) { const char* tmp; // const char* lst = str + strlen(str); while((tmp = strchr(str, '\\\"')) != NULL) { // fprintf(\"tmp=%s\\n\",tmp); tmp += 1; int num = 0; while(*tmp != '\\\"') { num++; tmp++; } str = tmp + 1; ans += num; } } D 题：最大公约数问题描述 给定一个数组，每次操作可以选择数组中任意两个相邻的元素 x, y 并将其中的一个元素替换为 gcd(x, y) ，其中 gcd(x, y) 表示 x 和 y 的最大公约数。 请问最少需要多少次操作才能让整个数组只含 1 。 输入格式 输入的第一行包含一个整数 n ，表示数组长度。 第二行包含 n 个整数 a1, a2, · · · , an，相邻两个整数之间用一个空格分隔。 输出格式 输出一行包含一个整数，表示最少操作次数。如果无论怎么操作都无法满足要求，输出 −1。 测试样例 样例输入 样例输出 34 6 9 4 规模与约定 对于 30% 的评测用例，$n ≤ 500 ，a_i ≤ 1000$；对于 50% 的评测用例，$n ≤ 5000 ，a_i ≤ 10^6$；对于所有评测用例，$1 ≤ n ≤ 100000 ，1 ≤ a_i ≤ 10^9$。 考场思路可以发现，如果数列中有一个数为1，那么问题就很好解决了：答案即为非1的个数。 因此本题的关键在于如何最快的弄出一个1。 由于题目只允许相邻的两个数取gcd，所以如果找到连续k个数gcd为1的话，就可以用k-1次操作把其中一个数换为1，因此答案为：n+k-2。（当然，如果这n个数的gcd为非1，就直接输出-1即可） 于是问题化为如何找到这个最小的k。 稍微暴力的做法是，首先求两个两个的gcd，然后求三个三个的gcd（可以发现，三个数的gcd就是相邻两个gcd的gcd），依次下去，每次gcd的数目减小1，于是时间复杂度是$O(\\sum_{i=1}^n i)$即$O(n^2)$（由于$a_i$并不大，所以gcd的复杂度（不超过$O(5 \\lg n)$，大约就是10倍左右）就忽略了）实现大致如下： void focus_solve() { int ans = n - 1; while(!flag) { n--; ans++; for(int i = 0; i &lt; n; i++) { num[i] = gcd(num[i], num[i+1]); if(num[i] == 1) {flag = true;break;} } } printf(\"%d\\n\", ans); } 至于100%的数据，我使用了倍增+二分，复杂度大概是$O(40nlogn)$（倍数是gcd的复杂度），复杂度上肯定是没有问题的。大致的想法就是先预处理出从数量任意一个数起，2的整次幂个数的gcd，这里复杂度就是$O(20nlogn)$。然后对上面说的k进行二分（k最大取n），每次check遍历起点，然后用预处理的数据计算出k个数的gcd，也是$O(20nlogn)$。代码大致如下： const int pow2[] = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072}; bool check(int x) { int logval = upper_bound(pow2, pow2 + 18, x) - pow2 - 1; // logval = log2(x)向下取整-1 for(int i = 0; i &lt; n - x + 1; i++) { int l = i, r = i + x; int _g = gcd(_gcd_2[l][logval], _gcd_2[r-pow2[logval]][logval]); // _gcd_2就是预处理数组 if(_g == 1) return true; } return false; } void solve() { int max_log = upper_bound(pow2, pow2 + 18, n) - pow2; for(int p = 0; p &lt; max_log; p++) for(int i = 0; i &lt; n; i++) { if(p == 0) _gcd_2[i][0] = num[i]; else if (i+pow2[p-1] &gt;= n) _gcd_2[i][p] = _gcd_2[i][p-1]; else _gcd_2[i][p] = gcd(_gcd_2[i][p-1], _gcd_2[i+pow2[p-1]][p-1]); } int L = 1, R = n; while(L != R) { int mid = L + R &gt;&gt; 1; if(check(mid)) R = mid; else L = mid + 1; } printf(\"%d\\n\", n + L - 2); } E 题：owo问题描述 小蓝很喜欢 owo ，他现在有一些字符串，他想将这些字符串拼接起来，使得最终得到的字符串中出现尽可能多的 owo 。 在计算数量时，允许字符重叠，即 owowo 计算为 2 个，owowowo 计算为3 个。 请算出最优情况下得到的字符串中有多少个 owo。 输入格式 输入的第一行包含一个整数 n ，表示小蓝拥有的字符串的数量。接下来 n 行，每行包含一个由小写英文字母组成的字符串 si 。 输出格式 输出 n 行，每行包含一个整数，表示前 i 个字符串在最优拼接方案中可以得到的 owo 的数量。 测试样例 样例输入 样例输出 3owowow 112 规模与约定 对于 10% 的评测用例，$n ≤ 10$；对于 40% 的评测用例，$n ≤ 300$；对于 60% 的评测用例，$n ≤ 5000$；对于所有评测用例，$1 ≤ n ≤ 10^6 ，1 ≤ |s_i| ，\\sum|s_i| ≤ 10^6$，其中 $|s_i|$表示字符串$s_i$的长度。 考场思路首先肯定要能计算出每个字符串内部的owo的个数，当然这个是比较好计算的，用kmp或者直接用两个flag就能搞定。 其实是最重要的，要考虑拼接，不过好在这个owo很短，可用的拼接方式并不多，大致应该只有如下三种： 以ow结尾+以o开头 以o结尾+以wo开头 以o结尾+单独一个字母w+以o开头 因此我们就统计上面这些可以拼接的字符串的数量就可以了。但是需要注意的是，如果一个字符串既以ow结尾又以o开头，虽然都要计数，但是不能自己和自己拼接在一起，不仅如此，字符串也不能拼接成环。但是这个我在考试的时候想的不多，就没有考虑完全，大概是寄了，因此就不放代码了，如何实现就留给读者思考吧。 F 题：环境治理问题描述 LQ 国拥有 n 个城市，从 0 到 n − 1 编号，这 n 个城市两两之间都有且仅有一条双向道路连接，这意味着任意两个城市之间都是可达的。每条道路都有一个属性 D ，表示这条道路的灰尘度。当从一个城市 A 前往另一个城市 B 时，可能存在多条路线，每条路线的灰尘度定义为这条路线所经过的所有道路的灰尘度之和，LQ 国的人都很讨厌灰尘，所以他们总会优先选择灰尘度最小的路线。 LQ 国很看重居民的出行环境，他们用一个指标 P 来衡量 LQ 国的出行环境，P 定义为：$$P = \\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1}d(i,j)$$其中 d(i, j) 表示城市 i 到城市 j 之间灰尘度最小的路线对应的灰尘度的值。 为了改善出行环境，每个城市都要有所作为，当某个城市进行道路改善时，会将与这个城市直接相连的所有道路的灰尘度都减少 1，但每条道路都有一个灰尘度的下限值 L，当灰尘度达到道路的下限值时，无论再怎么改善，道路的灰尘度也不会再减小了。 具体的计划是这样的：第 1 天，0 号城市对与其直接相连的道路环境进行改善；第 2 天，1 号城市对与其直接相连的道路环境进行改善；…第 n 天，n − 1 号城市对与其直接相连的道路环境进行改善；第 n + 1 天，0 号城市对与其直接相连的道路环境进行改善；第 n + 2 天，1 号城市对与其直接相连的道路环境进行改善；… LQ 国想要使得 P 指标满足 P ≤ Q。请问最少要经过多少天之后，P 指标可以满足 P ≤ Q。如果在初始时就已经满足条件，则输出 0 ；如果永远不可能满足，则输出 −1。 输入格式 输入的第一行包含两个整数$n, Q$，用一个空格分隔，分别表示城市个数和期望达到的$P$指标。 接下来$n$行，每行包含$n$个整数，相邻两个整数之间用一个空格分隔，其中第$i$行第$j$列的值$D_{ij}$ $(D_{ij} = D_{ji}, D_{ii} = 0)$表示城市$i$与城市$j$之间直接相连的那条道路的灰尘度。 接下来$n$行，每行包含$n$个整数，相邻两个整数之间用一个空格分隔，其中第$i$行第$j$列的值$L_{ij}$ $(L_{ij} = L_{ji}, L_{ii} = 0)$表示城市$i$与城市$j$之间直接相连的那条道路的灰尘度的下限值。 输出格式 输出一行包含一个整数表示答案。 测试样例 样例输入 样例输出 3 100 2 42 0 14 1 00 2 22 0 02 0 0 2 样例说明 初始时的图如下所示，每条边上的数字表示这条道路的灰尘度：此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：$$d(0, 0) = 0, d(0, 1) = 2, d(0, 2) = 3, \\d(1, 0) = 2, d(1, 1) = 0, d(1, 2) = 1, \\d(2, 0) = 3, d(2, 1) = 1, d(2, 2) = 0.$$初始时的 P 指标为 (2 + 3 + 1) × 2 = 12，不满足 P ≤ Q = 10；第一天，0 号城市进行道路改善，改善后的图示如下：注意到边 (0, 2) 的值减小了 1 ，但 (0, 1) 并没有减小，因为 L0,1 = 2 ，所以(0, 1) 的值不可以再减小了。此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：$$d(0, 0) = 0, d(0, 1) = 2, d(0, 2) = 3, \\d(1, 0) = 2, d(1, 1) = 0, d(1, 2) = 1, \\d(2, 0) = 3, d(2, 1) = 1, d(2, 2) = 0.$$此时 P 仍为 12。第二天，1 号城市进行道路改善，改善后的图示如下：此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：$$d(0, 0) = 0, d(0, 1) = 2, d(0, 2) = 2, \\d(1, 0) = 2, d(1, 1) = 0, d(1, 2) = 0, \\d(2, 0) = 2, d(2, 1) = 0, d(2, 2) = 0.$$此时的 P 指标为 (2 + 2) × 2 = 8 &lt; Q ，此时已经满足条件。所以答案是 2。 规模与约定 对于 30% 的评测用例，$1 ≤ n ≤ 10 ，0 ≤ L_{ij} ≤ D_{ij} ≤ 10$；对于 60% 的评测用例，$1 ≤ n ≤ 50 ，0 ≤ L_{ij} ≤ D_{ij} ≤ 100000$；对于所有评测用例，$1 ≤ n ≤ 100 ，0 ≤ L_{ij} ≤ D_{ij} ≤ 100000 ，0 ≤ Q ≤ 2^{31} − 1$。 考场思路不得不说这个题长到离谱（其实是样例解释长），所以我最后看的这个题。这个题暴力的话显然就是每天都用Floyd算法求一遍最短路，然后求一遍P就可以了，复杂度上是$O(day \\cdot n^3)$，其中Day是需要经历的天数，至于输出-1的情况，完全可以用$L_{ij}$作为边权跑一次Floyd就知道了。问题就是，这个复杂度是无法接受的，甚至连60%的数据都不能通过，只能拿到30%的分。 这里呢注意到数据规模中$n$是比较小的，但是$D-L$可能是比较大，所以考虑二分答案，理想中复杂度应该是$O(log(\\frac12n(D-L))\\cdot n^3)$，这样复杂度的话就很可以接受了。这里二分的话最大的天数应该是$\\frac12nD=5e6$。check函数的代码大概如下（复杂度是$O(n^2 + n^3)$）： bool check(int day) { int turn = day / n; // 每一轮，每条道路灰尘度下降2 day %= n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) { dis[i][j] = D[i][j] - 2 * turn; if(day &gt; i) dis[i][j]--; // 如果这一轮城市i还进行了清理 if(day &gt; j) dis[i][j]--; // 如果这一轮城市j还进行了清理 if(dis[i][j] &lt; L[i][j]) dis[i][j] = L[i][j]; // 注意灰尘度是有下限的 } floyd(); P = 0; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) P += dis[i][j]; if(P &lt;= Q) return 1; return 0; } G 题：选素数问题描述 小蓝有一个数 x，每次操作小蓝会选择一个小于 x 的素数 p，然后在 x 成为 p 的倍数前不断将 x 加 1，(如果 x 一开始就是 p 的倍数则 x 不变)。 小乔看到了小蓝进行了 2 次上述操作后得到的结果 n，他想知道 x 在一开始是多少。如果有多种可能，他想知道 x 一开始最小可以是多少，而如果不存在任何解，说明小乔看错了，此时请输出 −1。 输入格式 输入一行包含一个整数 n ，表示经过两次操作后 x 的值。 输出格式 输出一行包含一个整数表示 x 的初始值。如果有多个解，输出最小的。如果不存在解，请输出 −1 。 测试样例 样例输入 样例输出 22 8 规模与约定 对于 60% 的评测用例，$1 ≤ n ≤ 5000$；对于所有评测用例，$1 ≤ n ≤ 10^6$。 考场思路这个题的长度就和前面那个题形成了鲜明的对比😃。经过一番思考，可以发现，如果数$x=p_1^{k_1}p_2^{k_2}\\cdots p_m^{k_m}$且其中$p_1 &lt; p_2 &lt; \\cdots &lt; p_m$，则$x$的上一个数可能且只可能位于$[x-p_m+1,x-1]$中，且如果$x$是素数，这上一个数不存在。 发现这一点之后就可以做了，只需要先把$x$质因数分解，然后找出最大的素因子，得到只经过一轮的数，然后在把所有可能的数都再进行一次操作，就可以得到所有符合要求的原始数了。复杂度应该是$O(\\sum_{i=\\sqrt n}^{n} \\sqrt i)$，不过经过计算可知这个复杂度大约是$O(n^{\\frac32})$，其实是过不了全部数据的，但是由于大部分数不是质数，都拥有较小的质因子，所以分解质因数的复杂度应当小于$O(\\sqrt x)$，所以我大胆猜测是可以过的。 考试代码如下： unsigned solve(int x, int depth) { if(depth == 0) return x; if(x &lt;= 2) return (unsigned)-1; vector&lt;int&gt; prime_i; // 显然是没有必要的 int tmp = x; for(int i = 2; i * i &lt;= tmp; i++) { if(tmp % i == 0) { prime_i.push_back(i); while(tmp % i == 0) tmp /= i; } } if(tmp != 1 &amp;&amp; tmp != x) prime_i.push_back(tmp); // tmp==x说明是x质数 if(prime_i.empty()) return (unsigned)-1; int max_p = prime_i.back(); unsigned anss = (unsigned)-1; for(int i = 1; i &lt; max_p; i++) { anss = min(anss, solve(x - i, depth-1)); // 用unsigned其实就是为了取min方便 } return anss; } 主函数调用solve(n,2)然后把返回值转化为int即可。 未完待续……其实剩下的三个题我都不会了……😢","categories":[{"name":"竞赛","slug":"竞赛","permalink":"https://toby-shi-cloud.github.io/categories/%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"算法","slug":"算法","permalink":"https://toby-shi-cloud.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://toby-shi-cloud.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"author":"TobyShi"},{"title":"【Python】使用socket库实现server-client通讯的联机对战游戏（一）","slug":"Socket","date":"2022-06-16T13:30:00.000Z","updated":"2022-06-16T14:59:48.192Z","comments":true,"path":"posts/pythonsocket.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/pythonsocket.html","excerpt":"","text":"socket单对单通讯socket是Python内建库之一，用途就是网络通讯。作为实验，我们考虑两个Python程序之间的通讯，一个作为服务器，一个作为客户端，客户端向服务器发送一串字符，服务器收到后将原字符串大写后传回，直到客户端发送空信息，服务器退出。 服务器端代码： import socket ip_port = ('', 8888) # 这个tuple的第一项是ip地址，第二项是端口 s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 定义socket类型，网络通信，TCP s.bind(ip_port) # 套接字绑定ip和端口 s.listen(1) # 开始监听连接请求 conn, addr = s.accept() # 接受连接请求，conn是一个新的套接字，addr是客户端地址 conn.sendall('Hello from the server!'.encode('utf-8')) # 发送打招呼信息，并且用utf-8编码 while True: try: data = conn.recv(1024).decode('utf-8') # 接受数据并使用utf-8解码 if not data: break # 如果数据为空就退出 conn.sendall(data.upper().encode('utf-8')) # 把数据大写后返回 except Exception as e: # 如果数据传输出错 print(e) exit(1) conn.close() # 关闭套接字 客户端代码： import socket ip_port = ('localhost', 8888) # 服务器ip和端口 s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 定义socket类型，网络通信，TCP try: s.connect(ip_port) # 尝试连接服务器 except Exception as e: # 如果连接失败socket.socket.connect会抛出错误 print(e) exit(1) data = s.recv(1024).decode('utf-8') # 接受服务器的问候 print(data) while True: try: msg = input('&gt;&gt;&gt; ') # 此时用户可以在运行客户端的控制台中输入内容 s.sendall(msg.encode('utf-8')) # 将消息发送 if not msg: break # 如果数据为空就退出 data = s.recv(1024).decode('utf-8') # 接受服务器的结果 print(data) except Exception as e: # 如果数据传输出错 print(e) exit(1) s.close() # 关闭套接字 运行结果： socketserver多对一通讯由于我的目的是打算写一个联机对战游戏，那么一个服务器需要同时和多个（至少是两个）客户端建立连接。一个很容易想到的做法就是服务器多线程。好在Python已经帮我们封装好了多线程和socket库——socketserver库。 socketserver库的用法和socket几乎一模一样，而且由于只有服务器端需要多线程，所以只需要更改server.py即可。 下面是server.py的代码： import socketserver ip_port = ('', 10888) class MyServer(socketserver.BaseRequestHandler): def handle(self): # 重写RequestHandler中的handle方法用来处理请求 print(\"conn is :\", self.request) # conn print(\"addr is :\", self.client_address) # addr self.request.sendall('Hello from the server!'.encode('utf-8')) while True: # 处理方面的逻辑都是一样的 try: data = self.request.recv(1024).decode('utf-8') if not data: break self.request.sendall(data.upper().encode('utf-8')) except Exception as e: print(e) break print(\"disconnected with\", self.client_address) if __name__ == '__main__': s = socketserver.ThreadingTCPServer(ip_port, MyServer) # 建立TCP协议套接字 # 使用s.serve_forever()接受无穷次连接（需要按下Ctrl+C中断） # 也可以使用一次s.handle_request()接受一次连接 s.serve_forever() 运行结果： 服务器内部数据传输现在我们已经解决了服务器和客户端之间的数据传输问题了，但是这又引入了新的问题：服务器用多线程和客户端交流，但是socketserver封装的太好了，想要直接从外部操作各个线程显然不显示，那么如何进行服务器各个线程之间的交流呢？ 请听下回分解…… 😀","categories":[{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/tags/Python/"},{"name":"网络","slug":"网络","permalink":"https://toby-shi-cloud.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"server-client","slug":"server-client","permalink":"https://toby-shi-cloud.github.io/tags/server-client/"}],"author":"TobyShi"},{"title":"你好博客！Hello Blog!","slug":"HelloBlog","date":"2022-06-14T11:30:00.000Z","updated":"2022-07-20T12:03:43.586Z","comments":true,"path":"posts/helloblog.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/helloblog.html","excerpt":"","text":"01 从零开始搭建属于自己的博客具体操作见此博客 不过由于我之前弄过一半，所以这一步的操作就省了，因此这里就不记录了。 02 选择合适的好看的Theme经过许多次试错，最终看到了Luckey大佬的视频，十分羡慕，于是clone了他的博客. 03 博客个性化如果说前面的内容都是跟着教程动动手指就可以完成，那么这一步将会是最大的噩梦。 其中最大的问题就是：我压根没有学过前端，大佬的博客的复杂程度对于我来说简直难以想象。因此这里要特别感谢Luckey大佬的教程以及Matery主题的使用手册，中文文档真的对我这种英语白痴非常友好！ 然后我就开始看着各式各样的文档一通乱改，为了降低改动难度，我就把用不到的功能的入口删掉了，但是如果你手动输入争取的url的话其实依然可以看到Luckey大佬的很多让我大为震撼的功能，想看的朋友可以去他的博客欣赏欣赏。 我做的比较到大的改动就是升级了这个Theme使用的fontawesome的版本，不过其实只需要在官网下载一个zip然后把里面的东西全部覆盖到~\\themes\\matery\\source\\libs\\awesome就可以了。（这样做是因为只有新版才支持B站的图标，不过Gitee的图标仍然木有） 最后比较遗憾的是，不知道为什么我在“视频”栏中嵌入视频失败了，不知道是不是B站嵌入视频已经失效了。 04 Markdown公式测试$$ S_n = \\sum_{i=1}^{n} a_i $$$$ \\int \\cos(x) dx = \\sin(x) $$ 这是行内公式：$\\lim_{x\\rightarrow 0} \\frac{x}{\\sin x} = 1$ 经过测试，公式内换行不知道为什么没有得到支持。 05 在忙了一下午之后总之到晚上的时候我就已经开始写这篇HelloBlog了，还是很兴奋的，毕竟从未有过写前端的经历，然后几乎是从零开始学习搭建，所以真的非常感谢大佬们的帮助。因此如果有朝一日，我也有能力以后，也一定会向把知识分享出来，供大家学习和参考。 无限进步！","categories":[{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"TobyShi"},{"title":"蓝桥杯2022省赛参赛记录","slug":"LanQiaoCup2022Preliminary","date":"2022-04-09T13:00:00.000Z","updated":"2022-11-08T10:04:46.979Z","comments":true,"path":"posts/lanqiaocup2022preliminary.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/lanqiaocup2022preliminary.html","excerpt":"","text":"第十三届蓝桥杯大赛软件赛省赛C/C++ 大学 A 组本文其他链接CSDN 纪念我参加的第一次蓝桥杯 2022年4月9日 9:00 - 13:00这次蓝桥杯因为疫情，在线上举行 听学长学姐们说蓝桥杯又叫“送钱杯”，省一有手就行那我就在这里先求一个省一吧！2k 奖学金！求求了！ 序因为鄙人才学不高，所以这份题解中的解法难免有纰漏之处，还望各路神犇指出，鄙人将感激不尽。 题目链接题目pdf 试题A: 裁纸刀我的思路考虑记忆化搜索。后来听说怎么剪都是一样的？？？记int mem[n][m]为有$n$行$m$列个二维码时，需要剪多少次（不考虑边框）于是递归公式为$$mem[n][m] = \\min(\\min_{1 \\leq i \\leq n-1}(mem[i][m]+mem[n-i][m]+1), \\min_{1 \\leq i \\leq m-1}(mem[n][i]+mem[n][m-i]+1))$$最后答案是 $mem[20][22] + 4 = 443$ 我的代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int inf = 1 &lt;&lt; 30; int mem[30][30]; int cut(int n, int m) { if(n == 1 &amp;&amp; m == 1) return 0; if(mem[n][m]) return mem[n][m]; int r1 = inf; for(int i = 1; i &lt; n; i++) r1 = min(r1, cut(i, m) + cut(n-i, m) + 1); int r2 = inf; for(int j = 1; j &lt; m; j++) r2 = min(r2, cut(n, j) + cut(n, m-j) + 1); return mem[n][m] = min(r1, r2); } int main() { printf(\"%d\\n\", 4 + cut(20, 22)); return 0; } 试题B: 灭鼠先锋我的思路这应该就是一个普通的0/1博弈（这个博弈的名字似乎叫sg博弈）状态一共就$2^8$种，一点也不多。最后答案应该是LLLV 我的代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int f[300]; int rev(int st) { if(f[st]) return f[st]; f[st] = -1; for(int i = 0; i &lt; 8; i++) { if(!(st &amp; (1 &lt;&lt; i))) { if(rev(st | (1 &lt;&lt; i)) == -1) { f[st] = 1; break; } } } if(f[st] != 1) for(int i = 0; i &lt; 7; i++) if(i != 3) { if(!(st &amp; (3 &lt;&lt; i))) { if(rev(st | (3 &lt;&lt; i)) == -1) { f[st] = 1; break; } } } return f[st]; } int main() { f[0xff] = 1; //这里取负是因为，先手已经下过了，所以就后手赢先手就输，后手输先手就赢 printf(\"%d\\n\", -rev(0b10000000)); printf(\"%d\\n\", -rev(0b11000000)); printf(\"%d\\n\", -rev(0b01000000)); printf(\"%d\\n\", -rev(0b01100000)); return 0; } 试题C: 求和我的思路签到题，预处理sum就可以了（而且这题还良心的不会爆long long），复杂度$O(n)$ 我的代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 2e5 + 10; int n, a[maxn]; long long sum_ = 0; long long ans = 0; int main() { scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); for(int i = 0; i &lt; n; i++) sum_ += a[i]; for(int i = 0; i &lt; n; i++) ans += a[i] * (sum_ - a[i]); ans /= 2; printf(\"%lld\\n\", ans); return 0; } 试题D: 选数异或我的思路这个题考场上想了好久好久，最后居然还是只写了一个$O(n^2m)$的暴力，只能得2分，我人傻了 之后突然发现可以离线……于是对每个询问的r排序，这个题就解决了 具体来说，就是开一个map&lt;int,int&gt; mp来存数字x出现的最晚的位置（由于$a_i\\leq 2^{20}$所以直接开数组也可以）再令int near为最近的可以满足要求的位置，初始化为0然后从0开始遍历整个数列，每次遍历时更新near = max(near, mp[a[i]^x])，然后更新mp[a[i]] = i，然后处理所有r == i的询问，使得他们的答案ans = (l &gt;= near) 我的代码#include &lt;map&gt; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define yesno(x) \\ do { \\ if(x) printf(\"yes\\n\"); \\ else printf(\"no\\n\"); \\ } while(0) const int maxn = 1e5 + 10; map&lt;int, int&gt; mp; int n, m, x, a[maxn]; struct Ques { int l, r, id; bool ans; }q[maxn]; bool cmp_1(const Ques&amp; p, const Ques&amp; q) { return p.r &lt; q.r; } bool cmp_2(const Ques&amp; p, const Ques&amp; q) { return p.id &lt; q.id; } int main() { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;x); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for(int i = 0; i &lt; m; i++) { scanf(\"%d%d\", &amp;q[i].l, &amp;q[i].r); q[i].id = i; } sort(q, q+m, cmp_1); int ptr = 0, near = 0; for(int i = 0; i &lt; m; i++) { while(ptr &lt;= q[i].r) { near = max(near, mp[a[ptr] ^ x]); mp[a[ptr]] = ptr; ptr++; } q[i].ans = (near &gt;= q[i].l); } sort(q, q+m, cmp_2); for(int i = 0; i &lt; m; i++) { yesno(q[i].ans); } return 0; } 试题E: 爬树的甲壳虫我的思路期望dp其实也不是dp就是一个单纯的递推式：$$E(k) = P(k)*E(0) + (1-P(k))*E(k+1) + 1$$显然要逆向计算。注意到逆向计算时E(0)是未知的，但是始终只会出现一次项不妨直接开一个结构体（或者pair）来表示期望，结构体中就存两个数：一个是E(0)的系数，还有一个是常数最后就递推得到关于E(0)的一个一次方程，就能求出E(0)了 另外就是常规的小费马定理求分数取模 我的代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int modp = 998244353; int qpow(int base, int exp) { if(!exp) return 1; if(exp &amp; 1) return base * 1ll * qpow(base * 1ll * base % modp, exp &gt;&gt; 1) % modp; return qpow(base * 1ll * base % modp, exp &gt;&gt; 1); } const int maxn = 1e5 + 10; int n, P[maxn]; struct ANS { int r, t; // r是系数，t是常数；为什么用这两个字母？我乱选的 ANS() {} ANS(int _r, int _t) { r = _r; t = _t; } ANS operator * (const int ot) const { return ANS(r * 1ll * ot % modp, t * 1ll * ot % modp); } ANS operator + (const ANS &amp;ot) const { return ANS((r + ot.r) % modp, (t + ot.t) % modp); } } ans[maxn]; int main() { scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) { int a, b; scanf(\"%d%d\", &amp;a, &amp;b); P[i] = a * 1ll * qpow(b, modp - 2) % modp; } ans[n] = ANS(0, 0); for(int k = n - 1; k &gt;= 0; k--) { ans[k] = ANS(P[k], 0) + ans[k+1] * ((1 - P[k] + modp) % modp) + ANS(0, 1); } printf(\"%lld\\n\", ans[0].t * 1ll * qpow((1 - ans[0].r + modp) % modp, modp - 2) % modp); return 0; } 试题F: 青蛙过河我的思路显然二分答案，关键是怎么进行check这里我是贪心做的，不知道对不对。也就是说每次都尽量往最远的地方跳 我的代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 1e5 + 10; int n, x, h[maxn], h_copy[maxn]; long long cnt[maxn]; inline bool check(int y) { for(int i = 1; i &lt; n; i++) h_copy[i] = h[i]; int far = n - 1; // 用来记录当前可以到达的最远的地方 for(int i = n - 1; i &gt; 0; i--) { cnt[i] = 0; // 考试的时候没写！我肯定寄了…… if(i + y &gt;= n) { cnt[i] = h_copy[i]; continue; } far = min(far, i + y); while(far &gt; i) { if(cnt[far] &lt;= h_copy[i]) { h_copy[i] -= cnt[far]; cnt[i] += cnt[far]; cnt[far] = 0; far--; } else { cnt[far] -= h_copy[i]; cnt[i] += h_copy[i]; h_copy[i] = 0; break; } } } cnt[0] = 0; for(int i = 1; i &lt;= y; i++) cnt[0] += cnt[i]; return cnt[0] &gt;= 2 * x; } int main() { scanf(\"%d%d\", &amp;n, &amp;x); for(int i = 1; i &lt; n; i++) scanf(\"%d\", &amp;h[i]); int l = 1, r = n; while(l != r) { int mid = l + r &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; } printf(\"%d\\n\", l); return 0; } 后记2022年4月9日 20:55 写这篇题解的时候发现F题忘记初始化肯定寄了，我瞬间裂开，所以后面的题就以后再说吧","categories":[{"name":"竞赛","slug":"竞赛","permalink":"https://toby-shi-cloud.github.io/categories/%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"算法","slug":"算法","permalink":"https://toby-shi-cloud.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://toby-shi-cloud.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"author":"TobyShi"}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://toby-shi-cloud.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"面向对象","slug":"面向对象","permalink":"https://toby-shi-cloud.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"Shell","slug":"Shell","permalink":"https://toby-shi-cloud.github.io/categories/Shell/"},{"name":"私有云","slug":"私有云","permalink":"https://toby-shi-cloud.github.io/categories/%E7%A7%81%E6%9C%89%E4%BA%91/"},{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"计算机组成","slug":"计算机组成","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"},{"name":"Swift编程","slug":"Swift编程","permalink":"https://toby-shi-cloud.github.io/categories/Swift%E7%BC%96%E7%A8%8B/"},{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/categories/%E8%84%9A%E6%9C%AC/"},{"name":"密码学","slug":"密码学","permalink":"https://toby-shi-cloud.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"竞赛","slug":"竞赛","permalink":"https://toby-shi-cloud.github.io/categories/%E7%AB%9E%E8%B5%9B/"},{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/categories/Python/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"OS","slug":"OS","permalink":"https://toby-shi-cloud.github.io/tags/OS/"},{"name":"OO","slug":"OO","permalink":"https://toby-shi-cloud.github.io/tags/OO/"},{"name":"Java","slug":"Java","permalink":"https://toby-shi-cloud.github.io/tags/Java/"},{"name":"Apple","slug":"Apple","permalink":"https://toby-shi-cloud.github.io/tags/Apple/"},{"name":"私有云","slug":"私有云","permalink":"https://toby-shi-cloud.github.io/tags/%E7%A7%81%E6%9C%89%E4%BA%91/"},{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"网页","slug":"网页","permalink":"https://toby-shi-cloud.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CO","slug":"CO","permalink":"https://toby-shi-cloud.github.io/tags/CO/"},{"name":"Swift","slug":"Swift","permalink":"https://toby-shi-cloud.github.io/tags/Swift/"},{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/tags/Python/"},{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"密码分析","slug":"密码分析","permalink":"https://toby-shi-cloud.github.io/tags/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"VScode","slug":"VScode","permalink":"https://toby-shi-cloud.github.io/tags/VScode/"},{"name":"wsl","slug":"wsl","permalink":"https://toby-shi-cloud.github.io/tags/wsl/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://toby-shi-cloud.github.io/tags/Codeforces/"},{"name":"算法","slug":"算法","permalink":"https://toby-shi-cloud.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://toby-shi-cloud.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"网络","slug":"网络","permalink":"https://toby-shi-cloud.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"server-client","slug":"server-client","permalink":"https://toby-shi-cloud.github.io/tags/server-client/"}]}