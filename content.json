{"meta":{"title":"TobyShiの博客","subtitle":"TobyShiの博客","description":null,"author":"TobyShi","url":"https://toby-shi-cloud.github.io","root":"/"},"pages":[{"title":"","date":"2022-06-14T07:18:32.138Z","updated":"2022-06-14T07:18:32.138Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://toby-shi-cloud.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-14T07:18:32.014Z","comments":true,"path":"404.html","permalink":"https://toby-shi-cloud.github.io/404.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-14T07:18:32.028Z","comments":true,"path":"List/index.html","permalink":"https://toby-shi-cloud.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"","date":"2022-06-14T07:18:32.141Z","updated":"2022-06-14T07:18:32.141Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://toby-shi-cloud.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-14T07:18:32.136Z","comments":true,"path":"about/index.html","permalink":"https://toby-shi-cloud.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-14T07:18:32.137Z","comments":true,"path":"archives/index.html","permalink":"https://toby-shi-cloud.github.io/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-06-14T07:18:32.139Z","comments":true,"path":"census/index.html","permalink":"https://toby-shi-cloud.github.io/census/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-14T07:18:32.138Z","comments":true,"path":"categories/index.html","permalink":"https://toby-shi-cloud.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-06-14T07:18:32.140Z","comments":true,"path":"friends/index.html","permalink":"https://toby-shi-cloud.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-14T07:18:32.141Z","comments":true,"path":"resource/index.html","permalink":"https://toby-shi-cloud.github.io/resource/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-06-14T10:00:00.000Z","updated":"2022-06-14T10:16:31.019Z","comments":true,"path":"contact/index.html","permalink":"https://toby-shi-cloud.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，一起交流学习！ 特别感谢 特别感谢本博客模板制作者：Luckey Luckeyの博客名称: Luckeyの博客 Luckeyの博客网址: http://www.luckyzmj.cn Luckeyの博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png Luckeyの博客介绍: The harder you work, the luckier you will be"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-14T07:18:32.144Z","comments":true,"path":"tags/index.html","permalink":"https://toby-shi-cloud.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-06-14T07:18:32.020Z","updated":"2022-06-14T07:18:32.020Z","comments":true,"path":"List/galleries/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-14T07:18:32.029Z","comments":true,"path":"List/music/index.html","permalink":"https://toby-shi-cloud.github.io/List/music/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-14T07:18:32.028Z","comments":true,"path":"List/movies/index.html","permalink":"https://toby-shi-cloud.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-14T07:18:32.029Z","comments":true,"path":"List/tools/index.html","permalink":"https://toby-shi-cloud.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-06-14T07:18:32.021Z","updated":"2022-06-14T07:18:32.021Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-06-14T07:18:32.022Z","updated":"2022-06-14T07:18:32.022Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-06-14T07:18:32.022Z","updated":"2022-06-14T07:18:32.022Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-06-14T07:18:32.023Z","updated":"2022-06-14T07:18:32.023Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-06-14T07:18:32.024Z","updated":"2022-06-14T07:18:32.024Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-06-14T07:18:32.024Z","updated":"2022-06-14T07:18:32.024Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-06-14T07:18:32.025Z","updated":"2022-06-14T07:18:32.025Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-06-14T07:18:32.025Z","updated":"2022-06-14T07:18:32.025Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-06-14T07:18:32.026Z","updated":"2022-06-14T07:18:32.026Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-06-14T07:18:32.027Z","updated":"2022-06-14T07:18:32.027Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-06-14T07:18:32.026Z","updated":"2022-06-14T07:18:32.026Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-06-14T07:18:32.027Z","updated":"2022-06-14T07:18:32.027Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"BUAA Tools 使用文档","slug":"BUAAToolsUsage","date":"2022-11-19T15:30:00.000Z","updated":"2022-11-26T11:51:16.722Z","comments":true,"path":"posts/buaatoolsusage.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/buaatoolsusage.html","excerpt":"","text":"前言本使用指南以 iPad 界面为主。在 iPhone 上使用体验略有不同。 界面登录界面如下图所示，登录界面简单而明显。输入您的统一身份认证的学号和密码即可登录。 Feature 对于密码错误和网络错误都会给予相应的提示。 可以使用 iCloud 钥匙串自动填充学号密码。 仅首次启动或手动退出登录后需要登录，再次启动 App 可以自动登录。 导航栏左侧导航栏会显示信息概览。默认顺序依次为 校园网流量，TD 次数，校园卡余额，健康打卡状态，核酸排队情况。 Feature 导航栏可以简单概览目前状态。 点击导航栏可以查看详细页面。 导航栏顺序可以设置。 详细视图大部分视图即为对应的官网。这里以点击每日健康打开为例。 Feature 会主动询问是否允许访问位置。 拥有与微信小程序或智慧北航一致的行为。 可以交互的真实网页。 设置界面可以调整视图顺序和对一些特定视图进行设置。设置界面由右上角任务图像唤出。 Feature 自由调整其中的任何设置。 醒目的退出登录标识。 可以取消设置。 其他 Feature 自由的在深色主题和浅色主题之间切换（跟随系统）。 自适应屏幕大小变化（支持台前调度的各个大小）。 可在 iPhone，iPad，以及 Mac 上运行。[^1] [^1]: 仅支持 iOS 16，iPadOS 16，或 macOS 13 及以上 从源代码安装 打开 Xcode 点击Xcode-Preferences或者使用快捷键command+,打开偏好设置，在 Accounts 中添加自己的 AppleID，添加成功后关闭偏好设置。 在左侧视图中点击App的名称，选中signing &amp; Capabilities，在 Signing 栏的 Development Team 中选中自己 AppleID 的名字。 鼠标悬停在中间正上方，会出现为什么构建应用程序，选中Any iOS Device，然后点击菜单栏Product-Archive。 在弹出菜单出选择 Distribute App，选择 Development，然后一路 Next 下去，就可以看到在相同目录下生成了一个文件夹，点开文件夹，就可以得到由你自己签名的 ipa 安装包。 自签安装包是可以安装使用的，但是有效期只有 7 天。因此可以考虑使用 AltStore 等自签工具来完成续签。AltStore 使用方法详见官网。 从 ipa 安装 安装前请确保您的设备在 iOS 16，iPadOS 16，或 macOS 13 及以上 从 GitHub 上下载 最新 ipa 文件，或者直接点击此链接下载 1.0 版本 推荐使用 AltSotre 侧载 记得定期重签名 Enjoy BUAA Tools 鸣谢特别感谢对本软件的提供建议或帮助的所有人。","categories":[{"name":"Swift编程","slug":"Swift编程","permalink":"https://toby-shi-cloud.github.io/categories/Swift%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://toby-shi-cloud.github.io/tags/Swift/"},{"name":"Apple","slug":"Apple","permalink":"https://toby-shi-cloud.github.io/tags/Apple/"}],"author":"Toby Shi"},{"title":"从教务网站上获取课表并导入iCloud日历","slug":"CDUTCMcalendar","date":"2022-10-14T20:30:00.000Z","updated":"2022-10-15T03:44:35.697Z","comments":true,"path":"posts/cdutcmcalendar.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/cdutcmcalendar.html","excerpt":"","text":"前言因为我家羽羽说她的课表一天一个样，每次都手动输入到日历中的话非常不方便，所以我打算帮她把课表从教务网站上爬出来，然后写在ics文件中，这样就可以一键导入了。 方案打开他们学校的教务网站，我就麻了，因为必须要输入验证码。这对自动化脚本来说是一个非常阴间的事情，所以考虑使用selenium，打开网页后，人工登录，程序检测到网页跳转后开始运行。 登录完成后就可以看到课表，默认是月课表，所以只需要让脚本自己翻页然后读取网页全部内容即可。通过F12，我们可以看到那些写着有课程信息的元素大致长什么样子，使用正则表达式即可爬取所有课程了。 使用在经历了漫长了写代码过程之后，终于到了运行的时候啦！看到一个程序能跑起来，真的是很开心的一件事！（大家也可以尝试复制下面的代码，自己运行试试看） 如果读者想要运行以下代码，需要进行下列步骤： 安装一个Python（这不是废话吗，建议是3.6以上，我自己用的3.10） 安装icalendar和selenium（在命令行执行pip install xxx） 如果你使用Chrome浏览器，请下载和你的Chrome匹配的chromedriver（见参考链接6），并为chromedriver添加环境变量，或放在脚本所在目录下。 如果你不使用Chrome浏览器，请自行搜索selenium如何使用你的浏览器（FireFox，Edge 和Safari等主流浏览器都是支持的，如果你使用其他浏览器，也可以尝试，因为它们大概率和Google Chrome使用同样的内核，只不过版本较老）另外，不要忘记更改chrome = Chrome()这条语句。 在脚本所在目录下打开命令行，输入python xxx即可运行（xxx是你的脚本名，通常你应该让后缀是.py）（通常安装python时会关联文件，所以双击运行也不是不可以） 日程会储存在cdutcm.ics中，许多日历App都支持.ics格式 配置更改有如下内容可能需要更改： 如果你不是使用的Chrome，更改chrome = Chrome()（第68行） 默认只会获取课程，而不会获取考试，若要获取考试请更改正则表达式中的上课任务（第32行） 默认是秋季学期课表，若要获取春季学期课表，更改while month != '八月'和while month != '二月'，交换八月金和二月的位置大概就可以了（第76和83行） 更改begin_date = datetime(2022, 8, 29, tzinfo=UTC8)中的2022, 8, 29为本学期开学第一周星期一的时间（第97行） 代码# coding=utf-8 import re from time import sleep from typing import Any import icalendar as ics from selenium.webdriver import Chrome from selenium.webdriver.common.by import By from datetime import datetime, timezone, timedelta UTC8 = timezone(timedelta(hours=8)) def create_event(name: Any, location: Any, dtstart: Any, dtend: Any, description: Any) -&gt; ics.Event: ''' create a single icalendar event :type of params: any Python native type or icalendar property type. ''' event = ics.Event() event.add('summary', name) event.add('location', location) event.add('dtstart', dtstart) event.add('dtend', dtend) event.add('description', description) return event def get_lesson_from_html(begin_date: datetime, html: str, begin_week: int = -1) -&gt; tuple[list[dict[str,str|datetime]],int]: REGEX = ( r'&lt;a class=\"fc-day-grid-event fc-h-event fc-event fc-start fc-end\" lay-tips=\"' r'&lt;table class=&amp;quot;kb-tips&amp;quot; border=&amp;quot;1&amp;quot;&gt;' r'&lt;tr&gt;&lt;th&gt;事件类型：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;上课任务&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'上课时间：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;(.*?)--(.*?)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'教学模式：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;.*?&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'教学形式：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;.*?&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'星期：&lt;/th&gt;&lt;td&gt;(\\d*?)&lt;/td&gt;&lt;th&gt;节次：&lt;/th&gt;&lt;td&gt;\\d*?&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;上课周次：&lt;/th&gt;&lt;td &gt;(\\d*?)&lt;/td&gt;&lt;th&gt;' r'课序号：&lt;/th&gt;&lt;td&gt;.*?&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'课程：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;\\[.*?\\]\\[.*?\\](.*?)\\[.*?\\]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'授课教师：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;(.*?)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'教学场地：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;(.*?)\\(?\\)?&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'上课班级：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;.*?&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'排课/上课：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;.*?&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;' r'授课内容：&lt;/th&gt;&lt;td colspan=&amp;quot;3&amp;quot;&gt;((.|\\n)*?)&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;\" style=\"background-color: rgb\\(\\d+, \\d+, \\d+\\);\"&gt;' ) end_week = 0 lessons : list[dict[str,str|datetime]] = [] for match in re.findall(REGEX, html): day = int(match[2]) - 1 week = int(match[3]) - 1 if week &lt;= begin_week: continue end_week = max(end_week, week) today = begin_date + timedelta(days=7 * week + day) start_t = [int(x) for x in match[0].split(':')] end_t = [int(x) for x in match[1].split(':')] dtstart = today + timedelta(hours=start_t[0], minutes=start_t[1], seconds=start_t[2]) dtend = today + timedelta(hours=end_t[0], minutes=end_t[1], seconds=end_t[2]) name = str(match[4]) teacher = str(match[5]) location = str(match[6]) content = str(match[7]) lessons.append({'课程':name, '教学场地':location, '开始时间':dtstart, '结束时间':dtend, '教师':teacher, '授课内容':content}) return (lessons, end_week) def get_lesson(begin_date: datetime) -&gt; list[dict[str,str|datetime]]: # 第一步获取网页元素 chrome = Chrome() chrome.get('http://jwweb.cdutcm.edu.cn') while chrome.current_url != 'https://jwweb.cdutcm.edu.cn/new/welcome.page': sleep(1) # 这里需要手动输入账号密码验证码！ sleep(3) # 等待加载 iframe = chrome.find_element(By.XPATH, '/html/body/div[3]/div/div/div[2]/div/div/iframe') chrome.switch_to.frame(iframe) month = chrome.find_element(By.XPATH, '/html/body/div[1]/div/div[1]/div/div/div/div[1]/div[3]/h2').get_attribute('textContent').split(' ')[1] while month != '八月': chrome.find_element(By.XPATH, '/html/body/div[1]/div/div[1]/div/div/div/div[1]/div[1]/div/button[1]').click() sleep(3) # 等待加载 month = chrome.find_element(By.XPATH, '/html/body/div[1]/div/div[1]/div/div/div/div[1]/div[3]/h2').get_attribute('textContent').split(' ')[1] begin_week = -1 lessons : list[dict[str,str|datetime]] = [] while month != '二月': html = chrome.page_source lessons_gets, begin_week = get_lesson_from_html(begin_date, html, begin_week) lessons += lessons_gets chrome.find_element(By.XPATH, '/html/body/div[1]/div/div[1]/div/div/div/div[1]/div[1]/div/button[2]').click() sleep(3) # 等待加载 month = chrome.find_element(By.XPATH, '/html/body/div[1]/div/div[1]/div/div/div/div[1]/div[3]/h2').get_attribute('textContent').split(' ')[1] return lessons if __name__ == '__main__': calendar = ics.Calendar() calendar.add('version', '2.0') begin_date = datetime(2022, 8, 29, tzinfo=UTC8) lessons = get_lesson(begin_date) for lesson in lessons: name = lesson['课程'] location = lesson['教学场地'] dtstart = lesson['开始时间'] dtend = lesson['结束时间'] description = '教师：' + str(lesson['教师']) + '\\n\\n授课内容：\\n' + str(lesson['授课内容']) event = create_event(name, location, dtstart, dtend, description) calendar.add_component(event) with open('cdutcm.ics', 'wb') as f: f.write(calendar.to_ical()) 参考链接 「Selenium」- 在页面中，点击按钮（或元素） 使用Python在Selenium WebDriver中获取WebElement的HTML源代码 ICS在线课表制作 ICS在线课表制作 源码 如果意外地从 iCloud 中删除了日历、书签或通讯录 chromedriver下载与安装方法，亲测可用","categories":[{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/categories/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/tags/Python/"}],"author":"TobyShi"},{"title":"CO review：P0","slug":"CO_P0","date":"2022-10-05T11:05:00.000Z","updated":"2022-10-14T20:29:12.446Z","comments":true,"path":"posts/co-p0.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/co-p0.html","excerpt":"","text":"L0 五人投票题目概述裁判组有一个组长和四个组员（组员编号依次为 2'b00,2'b01,2'b10,2'b11）。每个组员都可以赞成、反对或是弃权。组长还拥有屏蔽投票权：屏蔽一位组员的投票，无论该组员投什么票，都视为弃权。投票的输入信息和输入信号对应如下： 意义赞成反对弃权屏蔽投票组长2'b002'b012'b102'b11组员2'b002'b01, 2'b112'b10- 当赞成票大于反对票时，表决结果为通过；反之为不通过。 输入输出描述","categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}],"tags":[{"name":"CO","slug":"CO","permalink":"https://toby-shi-cloud.github.io/tags/CO/"}],"author":"TobyShi"},{"title":"使用junit4对java程序进行测试","slug":"JunitTestForObjectOriented","date":"2022-09-28T17:00:00.000Z","updated":"2022-10-04T08:57:52.649Z","comments":true,"path":"posts/junittestforobjectoriented.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/junittestforobjectoriented.html","excerpt":"","text":"前言总所周知测试是写程序必不可少的一项。对于IDEA和java来说，junit测试是一个比较好的选择。 安装junit首先在IDEA上安装junit的插件； 前往官方github下载junit； 在项目结构中添加junit依赖。 具体可以参考： IDEA中添加junit4的三种方法（详细步骤操作） IDEA中使用JUnit4单元测试 使用junitjunit最基础的使用，IDEA中使用JUnit4单元测试已经说的十分明白了，而且举的例子也非常出色，我在这里就不加赘述了。 大概来说，就是新建一个测试类，然后搞明白@Before，@After，@Test，assertEquals的基本意思就行了。 模拟输入和捕获输出上面junit的最基本的用法是测试方法或者类的行为是否正常，但是我们希望junit能够帮助我们测试样例数据，而我们的main方法的交互方式是输入和输出，而不是传参和返回，所以不能直接使用上面的方式。 因此我们通过输入输出重定向的方式来模拟输入和捕获输出。可以写以下代码： import org.junit.After; import org.junit.Before; import org.junit.Test; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.InputStream; import java.io.PrintStream; import static org.junit.Assert.assertEquals; public class SampleTest { private final InputStream systemIn = System.in; private final PrintStream systemOut = System.out; private ByteArrayInputStream testIn; private ByteArrayOutputStream testOut; @Before public void setUpOutput() { testOut = new ByteArrayOutputStream(); System.setOut(new PrintStream(testOut)); } private void provideInput(String data) { testIn = new ByteArrayInputStream(data.getBytes()); System.setIn(testIn); } private String getOutput() { return testOut.toString(); } @After public void restoreSystemInputOutput() { System.setIn(systemIn); System.setOut(systemOut); } @Test public void sample1() { final String testStringIn = \"\"\" 2021/7/1-Jack@JayChou :\"Hello!\";2021/7/3-JayChou@buaaer :\"Hahaha\"; 2021/7/5-JayChou@Mike :\"emmmm\"; 2021/7/8-JayChou@buaaer :\"Hahaha\"; 2021/7/8-JayChou:\"Hahaha\"; 2021/5/3-Mike:\"he@buaaer is unhappy\"; END_OF_MESSAGE qdate 2021/7/1 qsend \"JayChou\" qrecv \"buaaer\" \"\"\"; // 多行字符串，这里填样例输入 final String testStringOut = \"\"\" 2021/7/1-Jack@JayChou :\"Hello!\"; 2021/7/3-JayChou@buaaer :\"Hahaha\"; 2021/7/5-JayChou@Mike :\"emmmm\"; 2021/7/8-JayChou@buaaer :\"Hahaha\"; 2021/7/8-JayChou:\"Hahaha\"; 2021/7/3-JayChou@buaaer :\"Hahaha\"; 2021/7/8-JayChou@buaaer :\"Hahaha\"; 2021/5/3-Mike:\"he@buaaer is unhappy\"; \"\"\"; // 多行字符串，这里填样例输出 provideInput(testStringIn); MainClass.main(new String[0]); assertEquals(testStringOut, getOutput().replace(\"\\r\\n\", \"\\n\")); // 这里根据实际情况replace。一般来说是需要replace的 } } 文件读入以及多组数据有的时候，输入输出会特别的长，或者输入输出有很多组，使用上面这个死板的方法就会显得非常臃肿。所以我们需要进行文件读入。 文件读入使用BufferedReader和FileReader可以之间读取一个文件中的全部字符，并将其转化为String，具体代码如下： private String readFromFile(String fileName) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(fileName)); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { stringBuilder.append(line); stringBuilder.append('\\n'); } return stringBuilder.toString(); } 多组数据junit提供了一种运行多组测试的方式：Parameterized 具体来说，就是当你使用@RunWith (Parameterized.class)修饰class时，junit会首先调用被@Parameterized.Parameters修饰的static方法，这个方法必须返回一个Collection。然后junit会遍历这个Collection，把遍历到的值传入class的构造方法中，生成一个测试类的对象。然后再运行@Test方法。 完整代码这里我写了一种文件读入的方法，大家可以直接使用： import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import java.util.List; import java.util.HashMap; import java.util.ArrayList; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.InputStream; import java.io.PrintStream; import java.io.BufferedReader; import java.io.IOException; import java.io.FileReader; import java.io.File; import static org.junit.Assert.assertEquals; @RunWith (Parameterized.class) public class PublicTest // 类名根据需要重构 { private static final String PATH = \"./test/public_test\"; // 测试数据目录 private static final String SUFFIX_IN = \".in\"; // 测试点输入文件后缀 private static final String SUFFIX_OUT = \".out\"; // 测试点输出文件后缀 private final InputStream systemIn = System.in; private final PrintStream systemOut = System.out; private ByteArrayInputStream testIn; private ByteArrayOutputStream testOut; private final String inputFileName; private final String expectedFileName; public PublicTest(String input, String expected) { this.inputFileName = input; this.expectedFileName = expected; } @Before public void setUpOutput() { testOut = new ByteArrayOutputStream(); System.setOut(new PrintStream(testOut)); } private void provideInput(String data) { testIn = new ByteArrayInputStream(data.getBytes()); System.setIn(testIn); } private String getOutput() { return testOut.toString(); } @After public void restoreSystemInputOutput() { System.setIn(systemIn); System.setOut(systemOut); } private String readFromFile(String fileName) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(fileName)); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { stringBuilder.append(line); stringBuilder.append('\\n'); } return stringBuilder.toString(); } @Test (timeout = 10000) public void runTest() throws IOException { final String testStringIn = readFromFile(inputFileName); final String testStringOut = readFromFile(expectedFileName); provideInput(testStringIn); MainClass.main(new String[0]); assertEquals(testStringOut, getOutput().replace(\"\\r\\n\", \"\\n\")); } @Parameterized.Parameters public static List&lt;String[]&gt; getParams() { File file = new File(PATH); File[] fs = file.listFiles(); HashMap&lt;String, File&gt; fInMap = new HashMap&lt;&gt;(); HashMap&lt;String, File&gt; fOutMap = new HashMap&lt;&gt;(); assert fs != null; for (File f : fs) { String name = f.getName(); int index = name.lastIndexOf(\".\"); String prefix; String suffix; if (index == -1) { System.err.print(\"Warning: file \"); System.err.print(\"\\\"\" + PATH + \"/\" + f.getName() + \"\\\"\"); System.err.println(\" does NOT appear to be a test data.\"); continue; } prefix = name.substring(0, index); suffix = name.substring(index); if (suffix.equals(SUFFIX_IN)) { fInMap.put(prefix, f); } else if (suffix.equals(SUFFIX_OUT)) { fOutMap.put(prefix, f); } else { System.err.print(\"Warning: file \"); System.err.print(\"\\\"\" + PATH + \"/\" + f.getName() + \"\\\"\"); System.err.println(\" does NOT appear to be a test data.\"); } } ArrayList&lt;String[]&gt; testData = new ArrayList&lt;&gt;(); for (String name : fInMap.keySet()) { File in = fInMap.get(name); File out = fOutMap.get(name); if (out == null) { System.err.print(\"Warning: file \"); System.err.print(\"\\\"\" + PATH + \"/\" + name + SUFFIX_IN + \"\\\"\"); System.err.println(\" does NOT appear to have a corresponding out file.\"); continue; } String[] pair = { PATH + \"/\" + in.getName(), PATH + \"/\" + out.getName() }; testData.add(pair); } return testData; } } 测试结果测试结果如下： 细节注意测试是不能添加到平台上进行评测的（会CE），所以我们必须要采用git多分支的方式进行。 通常的做法是，我们首先master分支中创建README，然后commit，之后进行git checkout -b develop。一切改动都在develop分支进行。测试无误后，执行git checkout master以及git checkout develop src/*即可提交并推送到远程仓库。 后记从课程网站上下载数据非常麻烦，所以如果你有一个自动下载脚本的话…… 2022年10月2日 更新如果你运行测试出错了却找不到哪个文件出错了的话，可以在80行左右的位置，runTest方法里面，加入 System.err.println(\"File In: \" + inputFileName); System.err.println(\"File Ans: \" + expectedFileName); 这样就可以看见读入的文件是哪一个了，如下图所示： 2022年10月4日 更新之前的测试类只能测试一个文件夹下的数据，不能测试一个文件夹下的子文件夹下的数据，因此做出改进。 import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import java.util.List; import java.util.HashMap; import java.util.ArrayList; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.InputStream; import java.io.PrintStream; import java.io.BufferedReader; import java.io.IOException; import java.io.FileReader; import java.io.File; import static org.junit.Assert.assertEquals; @RunWith (Parameterized.class) public class InfiniteTest { private static final String PATH = \"./test\"; private static final String SUFFIX_IN = \".in\"; private static final String SUFFIX_OUT = \".out\"; private final InputStream systemIn = System.in; private final PrintStream systemOut = System.out; private ByteArrayInputStream testIn; private ByteArrayOutputStream testOut; private final String inputFileName; private final String expectedFileName; public InfiniteTest(String input, String expected) { this.inputFileName = input; this.expectedFileName = expected; } @Before public void setUpOutput() { testOut = new ByteArrayOutputStream(); System.setOut(new PrintStream(testOut)); } private void provideInput(String data) { testIn = new ByteArrayInputStream(data.getBytes()); System.setIn(testIn); } private String getOutput() { return testOut.toString(); } @After public void restoreSystemInputOutput() { System.setIn(systemIn); System.setOut(systemOut); } private String readFromFile(String fileName) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(fileName)); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { stringBuilder.append(line); stringBuilder.append('\\n'); } return stringBuilder.toString(); } @Test (timeout = 10000) public void runTest() throws IOException { System.err.println(\"The input file is \" + \"\\\"\" + inputFileName + \"\\\"\"); System.err.println(\"The answer file is \" + \"\\\"\" + expectedFileName + \"\\\"\"); final String testStringIn = readFromFile(inputFileName); final String testStringOut = readFromFile(expectedFileName); provideInput(testStringIn); MainClass.main(new String[0]); assertEquals(testStringOut, getOutput().replace(\"\\r\\n\", \"\\n\")); } private static final HashMap&lt;String, File&gt; fInMap = new HashMap&lt;&gt;(); private static final HashMap&lt;String, File&gt; fOutMap = new HashMap&lt;&gt;(); private static void getFiles(File directory) { assert directory != null; File[] files = directory.listFiles(); assert files != null; for (File f : files) { if (f.isDirectory()) { getFiles(f); continue; } String name = f.getPath(); int index = name.lastIndexOf(\".\"); String prefix; String suffix; if (index == -1) { System.err.print(\"Warning: file \"); System.err.print(\"\\\"\" + f.getPath() + \"\\\"\"); System.err.println(\" does NOT appear to be a test data.\"); continue; } prefix = name.substring(0, index); suffix = name.substring(index); if (suffix.equals(SUFFIX_IN)) { fInMap.put(prefix, f); } else if (suffix.equals(SUFFIX_OUT)) { fOutMap.put(prefix, f); } else { System.err.print(\"Warning: file \"); System.err.print(\"\\\"\" + f.getPath() + \"\\\"\"); System.err.println(\" does NOT appear to be a test data.\"); } } } @Parameterized.Parameters public static List&lt;String[]&gt; getParams() { getFiles(new File(PATH)); ArrayList&lt;String[]&gt; testData = new ArrayList&lt;&gt;(); for (String name : fInMap.keySet()) { File in = fInMap.get(name); File out = fOutMap.get(name); if (out == null) { System.err.print(\"Warning: file \"); System.err.print(\"\\\"\" + in.getPath() + \"\\\"\"); System.err.println(\" does NOT appear to have a corresponding out file.\"); continue; } String[] pair = { in.getPath(), out.getPath() }; testData.add(pair); } System.err.println(); return testData; } }","categories":[{"name":"面向对象","slug":"面向对象","permalink":"https://toby-shi-cloud.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"OO","slug":"OO","permalink":"https://toby-shi-cloud.github.io/tags/OO/"},{"name":"Java","slug":"Java","permalink":"https://toby-shi-cloud.github.io/tags/Java/"}],"author":"TobyShi"},{"title":"复现 A Tutorial on Linear and Differential Cryptanalysis中差分分析的例子","slug":"DifferentialCryptanalysis","date":"2022-09-23T10:30:00.000Z","updated":"2022-09-23T11:58:12.807Z","comments":true,"path":"posts/differentialcryptanalysis.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/differentialcryptanalysis.html","excerpt":"","text":"前言黑历史++😢😢😢 差分分析什么是差分分析呢？其实简单来说，就是考察明文的某一或某些位取反对密文的影响，所以这里的差分，实质就是异或的意思。其实感觉差分分析的过程和线性分析是基本一致的，所以这个博客我就写简单一点，实在记不住了还可以翻阅上一篇博客。虽然上一篇也不怎么详细（） Sbox拟合与线性分析一致，我们不得不对sbox进行拟合。同样的，对于输入的每一种可能的差分，我们穷举所有的输入1（输入2=输入1$\\oplus$输入差分）并记录由此带来的输出差分值（输出差分=输出1$\\oplus$输出2），计算出输入差分和输出差分对应的概率关系。通过16*16的256次计算，我们就可以整理出一张sbox的拟合表格。 子密钥分析同样的，我们选取概率较大的路径，可以得到明文对的一个差分和一个倒数第二轮输出的差分之间的概率，在论文中，选取的是$\\Delta P = [0000\\ 1011\\ 0000\\ 0000]$和$\\Delta U4 = [0000\\ 0110\\ 0000\\ 0110]$，概率是$\\frac{27}{1024}=0.0264$。 同样的我们穷举最后一轮相关联的密钥$k_2$和$k_4$，通过倒推得到$U4$，最后计算出当$\\Delta P$成立时$\\Delta U4$成立的概率即可。 由于我们选择的是高概率路径，所以最后成立概率最高的密钥就大概率是我们要找的密钥。 复现结果 其中子密钥用16进制表示，x表示未知（即和例子的路径无关）。 可见$k_2=2$且$k_4=4$的概率远超其他密钥组合，而且概率$0.0272863$与理论$\\frac{27}{1024}=0.0264$非常接近。 复现代码#include \"structure.hh\" // \\delta P = [0000 1011 0000 0000] // \\delta U4 = [0000 0110 0000 0110] const char* FileNamePlain = \"plaintexts.hex\"; const char* FileNameCipher = \"ciphertexts.hex\"; const char* FileNameCsv = \"diff.csv\"; ifstream fp, fc; ofstream fcsv; int pcPair[1&lt;&lt;16]; // use -1 stands for undefined const u16 deltaP = 0b0000101100000000; const u16 deltaU4 = 0b0000011000000110; inline u16 getU4(u16 _C, u16 key) { _C = key_mixing(_C, key); _C = substitution(_C, SBOX_INV); return _C; } int main() { fp.open(FileNamePlain, ios::binary | ios::in); fc.open(FileNameCipher, ios::binary | ios::in); memset(pcPair, 0xff, sizeof pcPair); int num = 0; for(;;) { u16 P, U; if(!fp.read((char*)&amp;P, 2)) break; if(!fc.read((char*)&amp;U, 2)) break; P = P &lt;&lt; 8 | P &gt;&gt; 8; U = U &lt;&lt; 8 | U &gt;&gt; 8; if(!~pcPair[P]) num++; pcPair[P] = U; // cerr &lt;&lt; hex &lt;&lt; P &lt;&lt; \"-&gt;\" &lt;&lt; U &lt;&lt; endl; // if(num == 100) break; } cerr &lt;&lt; \"num = \" &lt;&lt; num &lt;&lt; endl; // 有效明密文对个数（剔除重复） fp.close(); fc.close(); fcsv.open(FileNameCsv, ios::out); fcsv &lt;&lt; \"partial subkey\" &lt;&lt; \",\" &lt;&lt; \"prob\" &lt;&lt; endl; for(u16 k2 = 0; k2 &lt; 16; k2++) for(u16 k4 = 0; k4 &lt; 16; k4++) { int sum = 0, count = 0; u16 key = k2 &lt;&lt; 8 | k4; for(int i = 0; i &lt; 65536; i++) { if(pcPair[i] == -1) continue; if(pcPair[i^deltaP] == -1) continue; if(i &gt; (i ^ deltaP)) continue; // cerr &lt;&lt; (!(pcPair[i] == -1) &amp;&amp; !(pcPair[i^deltaP] == -1)) &lt;&lt; endl; sum++; if((getU4(pcPair[i],key) ^ getU4(pcPair[i^deltaP],key)) == deltaU4) count++; } double prob = count * 1.0 / sum; fcsv &lt;&lt; hex &lt;&lt; \"x\" &lt;&lt; k2 &lt;&lt; \"x\" &lt;&lt; k4 &lt;&lt; \",\" &lt;&lt; dec &lt;&lt; prob &lt;&lt; endl; if(!k2 &amp;&amp; !k4) cerr &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; endl; // 有效明密文对组的组数（剔除没有配对成组的） } fcsv.close(); return 0; } structure.hh是我自己写的一个头文件，里面是加密解密需要用到的函数以及Sbox和permutation连线的方式。由于加密解密以及分析都需要用到这些函数，所以就放在头文件里面了。 用cpp的原因是，bluebeen告诉我cpp比python快数十倍……python分析10万组明密文对要1分钟真的难受…… 因为差分分析需要符合要求的明密文对组，即明文需要满足$\\Delta P$的那个式子。所以是先把涉及到的明密文对存下来（代码里面是pcPair）然后在进行统计。 在进行差分分析的复现的时候，我突然想到一个问题，为什么论文上只用了1万对明密文对，而我用了10万对才能找出答案吗？我的复现究竟是出了什么样的问题呢？ 其实在上面的复现代码中，输出num和sum就已经揭晓了答案。根据输出，我的10万对明密文，只有num=5万的有效明密文对，然后再安装$\\Delta P$的要求配对后，只有sum=2万组。而论文直接说的就是1万组满足$\\Delta P$的明密文组。其实我也就用了两倍的数据而已。所以我的数据看起来比论文中要精确一些，但是也没有精确太多。 参考资料[1]Heys, Howard M . A Tutorial on Linear and Differential Cryptanalysis[J]. Cryptologia, 2002, 26(3):189-221.","categories":[{"name":"密码学","slug":"密码学","permalink":"https://toby-shi-cloud.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"密码分析","slug":"密码分析","permalink":"https://toby-shi-cloud.github.io/tags/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90/"}],"author":"TobyShi"},{"title":"复现 A Tutorial on Linear and Differential Cryptanalysis中线性分析的例子","slug":"LinearCryptanalysis","date":"2022-09-14T08:30:00.000Z","updated":"2022-09-23T11:57:49.044Z","comments":true,"path":"posts/linearcryptanalysis.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/linearcryptanalysis.html","excerpt":"","text":"前言这学期选了一门网安的科研课堂。第一节课就给了我一个下马威，直接阅读全英论文。好在我借助翻译读了一遍后，又听教授和同学们讲了一次，总算是把33页论文的第一部分，也就是Linear Cryptanalysis理解完了。 当然理解归一回事儿，实现是另一回事，所以昨天晚上（也就是9月13日下午），我就把论文中的例子基本复现出来了。 分组密码什么是分组密码？简而言之就是把数据分组，一组一组的加密。论文中的例子是一个非常简单的分组加密，数据每16bit为一组，采用的是SPN结构（即Substitution-Permutation Network）。这个加密会经过若干轮，每轮有如下步骤： Substitution 置换我们把16bit数据分成4bit一组，一共4组。将每组的4bit的值传入对应S-box中，S-box也会传出一个4bit的值。每个S-box的逻辑都可以查表得到。通常4个S-box应当不一样，但是作为例子，论文中选取了同样的S-box。其映射表如下： input 0 1 2 3 4 5 6 7 8 9 A B C D E F output E 4 D 1 2 F B 8 3 A 6 C 5 9 0 7 上表以16进制数表示4bit的值。 Permutation 排列排列就是一个连线的操作，当然也可以理解为一种映射。本步骤的输出就是输入的一种排列。下表是例子选用的排列： input 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 output 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16 上表中input=3, output=9表示输出中第9比特的值来自输入中第3比特的值。 Key Mixing 密钥加密所谓Key Mixing其实异常简单，就是给一个16bit的密钥，然后和16bit的输入进行异或，就得到了16bit的输出。 图示本图是从 A Tutorial on Linear and Differential Cryptanalysis 中摘下来的。 线性分析我原以为，我们可以直接从明密文对获取加密信息，并且破译密码。结果，我发现我们能做的不过是在Substitution和Permutation都已知的情况下去推测Subkey的值。但即便如此，也并非易事。 堆积引理$X_1,X_2,\\cdots,X_n$是二值分布，在它们相互独立的情况下，若$p_1=\\frac12+\\epsilon_1,\\cdots,p_n=\\frac12+\\epsilon_n$，则有：$$Pr(X_1 \\oplus \\cdots \\oplus X_n = 0) = \\frac12 + 2^{n-1}\\prod_{i=1}^{n}\\epsilon_i$$或者说：$$\\epsilon_{1,2,\\cdots,n} = 2^{n-1}\\prod_{i=1}^{n}\\epsilon_i$$我们称$\\epsilon$为bias，偏差，$\\epsilon=Pr-\\frac12$。 线性拟合S-box由于S-box是整个加密过程中唯一的非线性过程，也是本加密方法的安全性所在。为了破译密码，我们不得不对S-box进行线性拟合。 假设S-box的输入是$X_1,X_2,X_3,X_4$，输出是$Y_1,Y_2,Y_3,Y_4$，列出一组线性表达式，我们就可以算出输入随机的时候，该线性表达式成立的概率。譬如：$X_2 \\oplus X_3 = Y_1 \\oplus Y_3 \\oplus Y_4$，穷举后可知16个不同输入中有12个使得这个式子成立。则成立概率是$\\frac34$，偏差是$\\frac14$。 子密钥分析我们选取偏差较大的线性方程，然后模拟该方程所涉及到的输入的加密路劲，沿途应用堆积引理，最终可以得到一个明文和倒数第二轮的输出的一个线性表示的成立的概率的偏差的绝对值。 然后，穷举最后一个subkey的有涉及的位，根据密文逆推得到倒数第二轮输出，然后和明文一起，记录线性表达式成立的次数。选取很多组明文对（论文是1万组，我实测是10万组才能得到好的结果），计算线性表示成立概率。对于穷举到的每一个subkey，最后偏差绝对值最大的那一个就高概率是密钥，而且这个偏差和线性表达式的偏差的非常接近。 复现加密过程复现最开始是打算用Python的，后来发现Python位运算并不方便，所以就用C++了。贴个代码吧。 #include &lt;bitset&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;fstream&gt; #include &lt;sstream&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef unsigned char u8, u4; typedef unsigned short u16; const u4 sbox[] = { 0xE, 0x4, 0xD, 0x1, 0x2, 0xF, 0xB, 0x8, 0x3, 0xA, 0x6, 0xC, 0x5, 0x9, 0x0, 0x7, }; const u4 wire[] = { 0x0, 0x4, 0x8, 0xc, 0x1, 0x5, 0x9, 0xd, 0x2, 0x6, 0xa, 0xe, 0x3, 0x7, 0xb, 0xf, }; const u16 KEYS[] = { 0xed52, 0x3799, 0xac27, 0x47fc, 0x72b4, // 0xacbd, 密钥随便改 }; inline u16 permutation(u16); inline u16 substitution(u16); inline u16 key_mixing(u16, u16); inline u16 halfWordFunc(u16&amp;, const u16*, int); int main() { freopen(\"1.data.in\", \"rb\", stdin); freopen(\"1.data.out\", \"wb\", stdout); int ch1, ch2; while(~(ch1 = getchar())) { ch2 = getchar(); if(ch2 == EOF) ch2 = 0; u16 data = ch1 &lt;&lt; 8 | ch2; // 两个字节16bit为一组 halfWordFunc(data, KEYS, 4); ch1 = data &gt;&gt; 8; ch2 = data &amp; 0xff; putchar(ch1); putchar(ch2); } return 0; } inline u16 substitution(u16 data) { const u16 p1 = 0xf000, p2 = 0x0f00, p3 = 0x00f0, p4 = 0x000f; u16 d1 = (data &amp; p1) &gt;&gt; 12, d2 = (data &amp; p2) &gt;&gt; 8, d3 = (data &amp; p3) &gt;&gt; 4, d4 = data &amp; p4; d1 = sbox[d1] &lt;&lt; 12; d2 = sbox[d2] &lt;&lt; 8; d3 = sbox[d3] &lt;&lt; 4; d4 = sbox[d4]; return d1 | d2 | d3 | d4; } inline u16 permutation(u16 data) { bitset&lt;16&gt; bst = data, out; for(int i = 0; i &lt; 16; i++) { out[i] = bst[wire[i]]; } return (u16) out.to_ulong(); } inline u16 key_mixing(u16 data, u16 key) { return data ^ key; } inline u16 halfWordFunc(u16&amp; data, const u16* keys, int round) { for(int i = 1; i &lt; round; i++) { data = key_mixing(data, keys[i-1]); data = substitution(data); data = permutation(data); } data = key_mixing(data, keys[round-1]); data = substitution(data); data = key_mixing(data, keys[round]); return data; } 密码分析这次用的Python，虽然我还是觉得Python的位运算真的有些别扭…… import pandas as pd 'U4,6 ^ U4,8 ^ U4,14 ^ U4,16 ^ P5 ^ P7 ^ P8 = 0' SBOX = ( 0xE, 0x4, 0xD, 0x1, 0x2, 0xF, 0xB, 0x8, 0x3, 0xA, 0x6, 0xC, 0x5, 0x9, 0x0, 0x7, ) WIRE = ( 0x0, 0x4, 0x8, 0xc, 0x1, 0x5, 0x9, 0xd, 0x2, 0x6, 0xa, 0xe, 0x3, 0x7, 0xb, 0xf, ) INV_SBOX = ( 0xe, 0x3, 0x4, 0x8, 0x1, 0xc, 0xa, 0xf, 0x7, 0xd, 0x9, 0x6, 0xb, 0x2, 0x0, 0x5, ) '明文对个数' DATA_GROUP = 100000 if __name__ == '__main__': anlysis = pd.DataFrame(columns=['partial subkey', '|bias|']) # print(anlysis.info()) for k in range(256): fp = open('1.data.in', 'rb') fe = open('1.data.out', 'rb') k2 = k &gt;&gt; 4 k4 = k &amp; 0xf key = k2 &lt;&lt; 8 | k4 count_of_equal = 0 for i in range(DATA_GROUP): p = ord(fp.read(1)) &lt;&lt; 8 | ord(fp.read(1)) e = ord(fe.read(1)) &lt;&lt; 8 | ord(fe.read(1)) # print('%X-&gt;%X'%(p,e)) v = key ^ e u2 = INV_SBOX[(v&amp;0x0f00)&gt;&gt;8] u4 = INV_SBOX[(v&amp;0x000f)&gt;&gt;0] u_4_6 = (u2 &amp; 0b0100) &gt;&gt; 2 u_4_8 = (u2 &amp; 0b0001) &gt;&gt; 0 u_4_14 = (u4 &amp; 0b0100) &gt;&gt; 2 u_4_16 = (u4 &amp; 0b0001) &gt;&gt; 0 p_5 = (p &amp; 0x0800) &gt;&gt; 11 p_7 = (p &amp; 0x0200) &gt;&gt; 9 p_8 = (p &amp; 0x0100) &gt;&gt; 8 if u_4_14 ^ u_4_6 ^ u_4_8 ^ u_4_16 == p_5 ^ p_7 ^ p_8: count_of_equal += 1 anlysis = anlysis.append({'partial subkey':'%x %x'%(k2,k4), '|bias|':'%.04f'%(abs(count_of_equal - DATA_GROUP / 2) / DATA_GROUP)}, ignore_index=True) fp.close() fe.close() anlysis.to_csv('1.data.csv', index=False) 分析结果 可见第五轮subkey的第5-9bit是0b0010，第13-16bit是0b0100，还是十分准确的，而且bias是0.0308和论文给的理论值$\\frac1{32}=0.03125$还是十分接近的。 参考资料[1]Heys, Howard M . A Tutorial on Linear and Differential Cryptanalysis[J]. Cryptologia, 2002, 26(3):189-221.","categories":[{"name":"密码学","slug":"密码学","permalink":"https://toby-shi-cloud.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"密码分析","slug":"密码分析","permalink":"https://toby-shi-cloud.github.io/tags/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/tags/Python/"}],"author":"TobyShi"},{"title":"使用VScode进行Verilog仿真和波形查看","slug":"VerilogWithVScode","date":"2022-09-07T07:00:00.000Z","updated":"2022-09-28T17:14:41.608Z","comments":true,"path":"posts/verilogwithvscode.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/verilogwithvscode.html","excerpt":"","text":"前言计组课程官方推荐的Verilog仿真工具是ISE和VCS，评测机使用ISE。 但是在尝试在win11的wslg上安装ISE后，虽然成功了，但是难用的一批，而且还有bug，仿真总是失败等问题。而课程虚拟机里面的VCS按照课程组提供的方法，又无法生成波形文件，查阅资料后也一筹莫展，弄的我一头雾水。于是开始寻求其他工具。 在经过不同关键词检索以后，终于看到了本校学长的知乎专栏，推荐了一个VScode上进行Verilog仿真的方法！安装不仅非常简单，而且使用也很简单，爆杀20G的ISE和安装繁琐的VCS！而且是一个开源的，跨平台的软件，简直就是神一般的存在！ 下面的教程参考了学长的专栏 安装VScode不会吧不会吧，不会有人看这篇文章却没有安装VScode吧。 安装iVerilogiVerilog全称Icarus Verilog，官方下载方式在这里 安装的时候，基本上都可以随意，直接Next都行，不过记得添加PATH。就是一定要勾选“Add executable folders to the user PATH” 安装VScode插件你需要安装以下几个插件： Verilog-HDL/SystemVerilog/Bluespec SystemVerilog Verilog HDL Verilog Snippet WaveTrace 前三个插件，提供代码高亮，代码补全，一键运行等功能。 第四个插件，提供波形查看。（下载iVerilog的时候应该有下载GTKWave，你也可以用这个软件查看波形） 插件设置仅需要设置Verilog-HDL/SystemVerilog/Bluespec SystemVerilog插件 找到插件设置中的Verilog &gt; Linting: Linter 在下拉菜单中选中iverilog即可 使用写一端.v代码，然后写对应的testbench，然后在testbench里面，点击右上角的绿色的按钮，即可运行。 若想要生成波形文件，请在testbench中加上以下代码： initial begin $dumpfile(\"*.vcd\"); // * 是你希望产生的波形文件的名字 $dumpvars; end 注意：你必须在testbench的test运行结束之后，使用$finish;结束代码，否则波形文件不会结束，需要手动前往任务管理器，结束vvp.exe进程。 最后点开*.vcd文件就可以查看波形了（如果你下载了WaveTrace插件的话） testbench怎么写我就不教了吧，下面给一个测试代码吧。 示例代码// adder.v `timescale 1ns/1ps module adder ( input clk, input [31:0] in1, input [31:0] in2, output reg [31:0] out ); always @(posedge clk) begin out &lt;= in1 + in2; end endmodule // adder_tb.v `timescale 1ns/1ps `include \"adder.v\" module adder_tb; // Dump waveform to file (it would be impossible to view wavefrom without // this task) initial begin $dumpfile(\"adder_wave.vcd\"); $dumpvars(); end // Generate clock reg clk; initial clk = 0; always #10 clk = ~clk; // Input registers reg [31:0] a, b; wire [31:0] c; initial begin a = 0; b = 0; @(negedge clk); a = 32'h631; b = 341; @(negedge clk); $display(\"%d + %d = %d\\n\", a, b, c); a = 32'o1461; b = 0; @(negedge clk); $display(\"%d + %d = %d\\n\", a, b, c); #20; // Exit the simulation $finish; end // Device under test (our adder) adder dut(.clk(clk), .in1(a), .in2(b), .out(c)); endmodule 参考资料 https://zhuanlan.zhihu.com/p/414308549","categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}],"tags":[{"name":"CO","slug":"CO","permalink":"https://toby-shi-cloud.github.io/tags/CO/"},{"name":"VScode","slug":"VScode","permalink":"https://toby-shi-cloud.github.io/tags/VScode/"}],"author":"TobyShi"},{"title":"使用Xcode编译Swift App并分发到iPhone或iPad上","slug":"swift_xcode_ipa","date":"2022-08-30T06:00:00.000Z","updated":"2022-11-19T15:37:20.960Z","comments":true,"path":"posts/swift-xcode-ipa.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/swift-xcode-ipa.html","excerpt":"","text":"前言这学期成功选上了Swift程序设计这门课。虽然我还只会写Hello World，但是已经非常好奇如何将自己写的程序放在自己的iPhone中运行了，因此我们今天就来尝试一次。 代码Mac上的Xcode和iPad上的Playground差距还是有些大的。但是因为我的Mac是虚拟机，运行缓慢，所以我打算现在iPad上编写程序并测试运行。 由于我对Swift的了解还很少，所以我在网上下载了一个简单的程序作为测试。测试软件下载链接[1] 下载好后，在iPad的Playground中尝试导入，几乎都失败了。遂怀疑是版本问题。于是准备重新创建项目后复制粘贴源代码。粘贴好后会提示SwiftyJSON和Alamofire找不到，遂前往GitHub搜索，并在Playground的添加Swift软件包中粘贴链接导入软件包即可。省流：链接分别是https://github.com/SwiftyJSON/SwiftyJSON和https://github.com/Alamofire/Alamofire 点击运行，就能看到软件运行成功了。 分发由于iPad的Playground只能将应用发布到App Store，而这个需要用户成为Apple Developer Member，不仅需要验证和审核，还需要688元/年的会费，对学生来说没有必要，邃转向Xcode。 首先在Playground中将刚刚抄的App导出并存放在iCloud中（存什么地方不重要，方便导入电脑即可，也可以直接AirDrop）。随后打开Mac上的Xcode，打开项目，选择我们刚刚的导出的软件。项目导入后，Xcode会提示正在fetch SwiftyJSON和Alamofire，fetch结束后就可以command+R运行了。可见App在Simulator中运行状态也是正常的。 之后点击Xcode-Preferences或者使用快捷键command+,打开偏好设置，在Accounts中添加自己的AppleID，添加成功后关闭偏好设置。 在左侧视图中点击App的名称，选中signing &amp; Capabilities，在Signing栏的Development Team中选中自己AppleID的名字，在Bundle Identifier中填入应用唯一标识符，命名规范一般是com.AppName.DeveloperName 随后鼠标悬停在中间正上方，会出现为什么构建应用程序，选中Any iOS Device，然后点击菜单栏Product-Archive，编译成功后在Finder中打开文件夹，文件夹位置默认在~/Library/Developer/Xcode/Archives下的今天日期文件夹中（可在偏好设置的Location栏更改）。此可以看见一个扩展名为xcarchive的文件即说明编译成功。 最后，打开终端，cd到.xcarchive文件所在文件夹，输入以下命令：[2] xcodebuild -exportArchive -exportOptionsPlist Info.plist -archivePath *.xcarchive -exportPath myApp.ipa 其中Info.plist需要随便准备一个（如果你是直接在Xcode中创建的项目会附赠一个，你在项目文件中找到即可，如果是Playground创建的，则需要借用其他项目的），*.xcarchive为你的应用名称。在看到** EXPORT SUCCEEDED **后说明导出ipa成功。 会在当前文件夹下产生一个叫做myApp.ipa的文件夹，将其中的myApp.ipa文件拿出来，使用爱思助手就可以直接安装在iPad/iPhone中使用。[3] 注意：根据Apple官方的规定，免费用户只能将同一个程序分发给至多3个设备，且一次签名最多持续7天。 参考链接或注释 参考链接：https://sspai.com/post/70655 参考链接：https://www.jianshu.com/p/0171d6b49771 注释：由于Info.plist不匹配和免费签名的缘故，不能使用iTunes进行安装，只能使用第三方助手","categories":[{"name":"Swift编程","slug":"Swift编程","permalink":"https://toby-shi-cloud.github.io/categories/Swift%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://toby-shi-cloud.github.io/tags/Swift/"},{"name":"Apple","slug":"Apple","permalink":"https://toby-shi-cloud.github.io/tags/Apple/"}],"author":"Toby Shi"},{"title":"在WSL上安装ISE","slug":"installISEonWSL","date":"2022-08-07T18:00:00.000Z","updated":"2022-09-28T17:15:00.298Z","comments":true,"path":"posts/install-ise-on-wsl.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/install-ise-on-wsl.html","excerpt":"","text":"前言因为我们计组要使用到ISE，但是ISE和win11不相容，所以我就打算在wslg上安装ISE了。 安装过程 在官网下载Xilinx_ISE_DS_Lin_14.7_1015_1.tar:https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/vivado-design-tools/archive-ise.html 将压缩包解压（我是直接在Nautilus中双击解压的） cd到解压后的文件夹里面，通过ls可以看到如下内容 $ ls bin data idata labtools msg planahead_wp webpack xsetup common edk ise lib planahead sysgen xinfo 如果xsetup是可运行的，则直接sudo ./xsetup，否则先sudo chmod +x xsetup 如果安装报错： error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file 即缺少libncurses.so.5库文件，可以通过以下指令解决 $ sudo apt install apt-file $ sudo apt-file update $ sudo apt-file find libncurses.so.5 $ sudo apt install libncurses5 安装界面是图形界面，按照指引操作即可。全默认就行了，目录就在/opt/，Install cable drivers也不用安装 打开终端输入以下指令 $ cd /opt/Xilinx/14.7/ISE_DS $ ls EDK ISE PlanAhead SysGen Xilinx.lic common settings32.csh settings32.sh settings64.csh settings64.sh $ source settings64.sh . /opt/Xilinx/14.7/ISE_DS/common/.settings64.sh /opt/Xilinx/14.7/ISE_DS/common . /opt/Xilinx/14.7/ISE_DS/EDK/.settings64.sh /opt/Xilinx/14.7/ISE_DS/EDK . /opt/Xilinx/14.7/ISE_DS/PlanAhead/.settings64.sh /opt/Xilinx/14.7/ISE_DS/PlanAhead . /opt/Xilinx/14.7/ISE_DS/ISE/.settings64.sh /opt/Xilinx/14.7/ISE_DS/ISE $ ise 这里如果你的Ubuntu是32位的，请选择settings32.sh 至此ISE首次运行成功！ 打开后会提示没有License，那么我们直接需要在官网先申请到一个免费的License，然后在Help -&gt; Manage Licenses里面Load官网通过邮件发给你的Xilinx.lic即可 最后界面如下图： 运行注意到每次重启wsl后都必须重新输入第6步的指令非常麻烦，所以已有大佬写了脚本一键运行： 在任何地方新建文件，我选择的是/opt/Xilinx/14.7/ISE_DS/quickstart，内容如下： #!/bin/bash export LD_PRELOAD=/opt/Xilinx/usb-driver/libusb-driver.so ISE_DS_DIR=/opt/Xilinx/14.7/ISE_DS unset LD_PRELOAD export gmake=/usr/bin/make cd \"$ISE_DS_DIR\" source \"$ISE_DS_DIR\"/settings64.sh export LANG='' # reset locale to English to fix decimal/comma seperation \"$ISE_DS_DIR\"/ISE/bin/lin64/ise 并为脚本添加可执行权限： sudo chmod a+x /opt/Xilinx/14.7/ISE_DS/quickstart 在/usr/share/applications新建文件ISE.desktop，内容为： [Desktop Entry] Version=1.0 Name=ISE Exec=/opt/Xilinx/14.7/ISE_DS/quickstart Terminal=false Icon=/opt/Xilinx/14.7/ISE_DS/ISE/data/images/pn-ise.png Type=Application Categories=Development 其中Exec指向的就是上一步建立的脚本文件 之后可以使用gtk-launch ISE一键打开 还可以在Windows桌面创建快捷方式： 路径写wslg ~ -d Ubuntu20.04 gtk-launch ISE 不过这个其实是会自动添加到开始菜单的 后记由于ISE安装包巨大，如果保留非常占据空间，所以考虑删掉。但是删掉后并不能真正释放空间，这个时候需要使用磁盘压缩工具对wsl的虚拟磁盘进行压缩，方法如下： 以管理员身份运行powershell，并输入 PS C:\\Windows\\System32&gt; wsl --shutdown PS C:\\Windows\\System32&gt; diskpart DISKPART&gt; select vdisk file=\"D:\\WSL\\ext4.vhdx\" DISKPART&gt; attach vdisk readonly DISKPART&gt; compact vdisk DISKPART&gt; detach vdisk 其中file=后面是你的wsl虚拟磁盘的位置 关于驱动由于我还没有开始写任何一个测试程序，尚不知驱动是否正常，这里挖一个坑，改日再填。 参考链接 缺少libncurses.so.5怎么办：https://blog.csdn.net/qq_36393978/article/details/110948418 Ubuntu安装ISE教程：https://blog.csdn.net/weixin_43238031/article/details/89022601 Ubuntu安装ISE教程以及快捷启动脚本：https://blog.csdn.net/ixunmo/article/details/82194896 释放wsl占用空间：https://zhuanlan.zhihu.com/p/358528257 清理wsl磁盘占用：https://www.cnblogs.com/enrio/p/14222648.html","categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}],"tags":[{"name":"CO","slug":"CO","permalink":"https://toby-shi-cloud.github.io/tags/CO/"},{"name":"wsl","slug":"wsl","permalink":"https://toby-shi-cloud.github.io/tags/wsl/"}],"author":"Toby"},{"title":"将wsl迁移至D盘","slug":"moveWSLtoD","date":"2022-08-07T15:30:00.000Z","updated":"2022-09-28T17:14:49.584Z","comments":true,"path":"posts/movewsltod.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/movewsltod.html","excerpt":"","text":"前因因为下学期的计组课程需要用到ISE，然而ISE这样13年的软件和win11自然是不兼容了（经过网上大佬们的各种尝试，最终也只能安装到92%），所以在水群大佬的推荐下，我可以尝试使用WSLG（Windows Subsystem for Linux GUI）来运行ISE，于是我就先安装官网教程更新了wsl2，这个流程不太难，就不赘述了。 由于ISE体量巨大，所以不得不将WSL迁移到D盘以防止C盘爆炸。 过程迁移WSL需要使用工具LxRunOffline GitHub网址：https://github.com/DDoSolitary/LxRunOffline/releases如果迁移中遇到以下错误，则应该改用：https://ddosolitary-builds.sourceforge.io/LxRunOffline/LxRunOffline-v3.5.0-11-gfdab71a-msvc.zip [ERROR] Couldn't set the case sensitive attribute of the directory \"\\\\?\\C:\\Users\\toby2\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc\\LocalState\\\". Reason: Indicates that the directory trying to be deleted is not empty. 操作步骤注意：建议使用管理员身份运行powershell 查看已安装的子系统 ./LxRunOffline list 查看子系统所在目录 ./LxRunOffline get-dir -n [xxx] xxx是你在步骤1中查询到的子系统版本 迁移系统 ./LxRunOffline move -n [xxx] -d [ddd] xxx是你在步骤1中查询到的子系统版本 ddd是你期望移动到的路径 如果迁移系统中出现以下错误 [ERROR] The distro \"Ubuntu-20.04\" has running processes and can't be operated. \"wsl -t &lt;name&gt;\" or \"wsl --shutdown\" might help. 则使用快捷键Win+x再按g打开计算机管理重启服务LxssManager（也可以直接停止服务，迁移结束后再打开） 如果迁移后Ubuntu报错“拒绝访问” 使用下列指定为目录授权 icacls [ddd] /grant \"[user]:(OI)(CI)(F)\" ddd为移动后的路径 user为你的用户名 授权后建议重启LxssManager服务 Q&amp;A 如果Ubuntu报错“另一个程序正在使用此文件，进程无法访问” 以管理员身份运行以下指令 Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 然后按照要求重启电脑 造成此错误的原因估计为在未开启WSL的情况下使用资源管理器尝试打开WSL的磁盘镜像文件（.vhdx文件） 关于wslg的分辨率 目前wslg似乎只支持整数倍缩放，这非常不友好，但是可以手动启用非整数倍缩放 在wsl终端输入sudo vi /mnt/c/ProgramData/Microsoft/WSL/.wslgconfig新建一个文件（或者在Windows中找到C:\\ProgramData\\Microsoft\\WSL，并在其中新建文件.wslgconfig），文件内容如下： [system-distro-env] WESTON_RDP_DISABLE_FRACTIONAL_HI_DPI_SCALING=false 然后关闭wsl终端，打开powershell，输入wsl --shutdown即可 只不过150%缩放确实有点糊……","categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}],"tags":[{"name":"wsl","slug":"wsl","permalink":"https://toby-shi-cloud.github.io/tags/wsl/"}],"author":"Toby"},{"title":"CF R 809 (Div.2) 题解","slug":"CFR309","date":"2022-07-20T12:00:00.000Z","updated":"2022-07-21T16:10:20.663Z","comments":true,"path":"posts/codeforcesr809.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/codeforcesr809.html","excerpt":"","text":"比赛链接试题链接 官方题解 *注意：在本文中，题目大意没有还原题目背景，也没有细节说明，如果您没有看过题目，还请前往Codeforces官网看 A题题目大意给定长度为$n$且只包含$1$和$m$之间的正整数数列$a_1,a_2,\\cdots,a_n$，有一个长度为$m$的字符串$s$，初始时串$s$只包含字符B 接下来进行如下$n$次操作： 在第$i$次操作时$(1\\le i \\le n)$，你可以选择将$s$串的第$a_i$个字符或者第$(m+1-a_i)$个字符改成A。（注意，你可以对同一个位置进行若干次操作） 找到$n$次操作后，你能得到的字典序最小的串$s$ *本题有多组数据$(t\\le2000)$，对于每组数据$1\\le n,m \\le50$ 解析签到题。显然数列${a_n}$的顺序与答案没有关系，因此可以考虑贪心，每次操作都优先将靠前的位置换成A，如果靠前的位置已经被更换了，就换另一个，如果两个都被更换过当然这次操作无论如何都没有意义了。 代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 55; int n, m; int cnt[maxn]; char str[maxn]; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { memset(cnt, 0, sizeof cnt); memset(str, 'B', sizeof str); scanf(\"%d%d\", &amp;n, &amp;m); str[m] = 0; for(int i = 0; i &lt; n; i++) { int v; scanf(\"%d\", &amp;v); v = min(v, m - v + 1); // v和m-v+1的操作选择是一样的，所以就取小的存下来 cnt[v]++; // 这里我用的桶存ai } for(int i = 1; i &lt;= m; i++) // 实际上当i&gt;m/2时cnt[i]就恒为0了 { if(cnt[i]) str[i-1] = 'A'; // 优先把靠前的换为A if(cnt[i] &gt; 1) str[m - i] = 'A'; // 如果不止1次更换机会，就把靠后的也换掉 } puts(str); } return 0; } B题题目大意有一个长度为$n$的数列数列${c_i}$，其值为不超过$n$的正整数。 现在对每个$c_i$依次进行如下操作： 对$c_1$，你将它放在$(0,0)$点 对$c_i(2\\le i\\le n)$，记$c_{i-1}$放在了$(x,y)$点，则你可以将$c_i$放在$(x+1,y)$或$(x-1,y)$或$(x,y+1)$（但是不能放在$(x,y-1)$）当然前提是这些地方之前没有放置过其他的$c_i$ 若对于某个$(x,y)$和某个$s$，若$(x,y),(x,y+1),\\cdots,(x,y+s-1)$被放置了值相同的$c_i$，则定义这些点组成了一个“塔”。定义“塔”的高是$s$，“塔”被放置在了$(x,y)$处，“塔”的颜色为这些相同的$c_i$的值。 对于每一个不超过$n$的正整数$r$，独立的解决如下问题： 找到你能按规则构造出的，颜色为$r$​的，高度最高的“塔”。 *本题有多组数据$(t \\le 10^4)$，每组数据满足$n \\le 10^5$，对于全部数据$\\sum n \\le 2 \\cdot 10^5$ 解析注意到题目要求我们独立的处理每一个$r$而且只需要找出最高的“塔”，所以我们可以考虑对于固定的$r$，贪心的希望每个$r$都能刚好搭在上一个$r$上。抽象化的，记$c_i=c_j=r(i &lt; j)$，什么情况下$c_i$和$c_j$可以组成一个“塔”呢？ 进过简单的推理可以证明，当且仅当$(j-i)$为奇数时，$c_i$和$c_j$能构成一个“塔”。 必要性证明过程大致如下： 若$c_i$被放置在$(x,y)$处，则记$Q(c_i)=x+y$ 则根据题意有$Q(c_{i+1})=x+y\\pm1$，即$Q(c_{i+1}) \\equiv Q(c_i) + 1 \\ (mod\\ 2)$ 所以$Q(c_j) \\equiv Q(c_i) + j - i \\ (mod \\ 2)$ 因为$c_j$和$c_i$构成“塔”，所以$Q(c_j)-Q(c_i)=1$ 于是有$j-i \\equiv 1 \\ (mod \\ 2)$，即$(j-i)$是奇数 充分性证明略，因为只需要给出一个简单的构造，这里就留给读者吧~ 那么当$(j-i)$是偶数的时候会发生什么情况呢？由于$c_i$下面可能已经成塔了，但是$c_j$并没有，所以当出现$c_k=r$而且$(k-i)$是奇数时（此时显然$(k-j)$也是奇数）将$c_k$放在$c_i$的上面为“塔”填一层楼是更优的。 因此本题只需要记录第一个$c_i=r$的$i$值，然后之后一旦碰见$c_j=c_i$而且$(j-i)$是奇数时就ans++即可。 最后可以看出，对于不同的$r$，我们可以同时进行计算，至此本题解决。 代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 1e5 + 5; int n, c[maxn], cnt[maxn], lst[maxn]; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) { lst[i] = -1; cnt[i] = 0; } for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;c[i]); for(int i = 0; i &lt; n; i++) { if((i - lst[c[i]]) % 2 == 1 || lst[c[i]] == -1) cnt[c[i]]++; lst[c[i]] = i; } for(int i = 1; i &lt;= n; i++) { printf(\"%d \", cnt[i]); } puts(\"\"); } return 0; } C题题目大意给定长度为$n$的正整数列${h_i}$，你可以花费代价增大其中的值，每花费$1$点代价可以将一个$h_i$增大$1$。 描述$h_i$是“好看的”，当且仅当$i\\neq 1$且$i\\neq n$且$h_i &gt; h_{i-1}$且$h_i &gt; h_{i+1}$。 要求在保证整个数列“好看的”$h_i$最多的情况下花费的最小代价。 *本题有多组数据$(t \\le 10^4)$，对于每组数据$3 \\le n \\le 10^5$，$h_i \\le 10^9$，对于全部数据$\\sum n \\le 2 \\cdot 10^5$ 解析首先肯定要考虑如何让“好看的”$h_i$最多。根据题意，“好看的”$h_i$无法连续出现，也不能出现在收尾，所以必然可以使得而且最多只能使得$\\lfloor\\frac{n-1}{2}\\rfloor$个$h_i$成为“好看的”。而且当$n$是奇数时很容易解决，因为必然得是所有的$h_{2i}$都是“好看的”。所以接下来重点讨论当$n$是偶数的情况。 可以注意到，$n$是偶数时，必然存在一个$k$，使得$i&lt;k$时，当$i$是偶数时$h_i$是“好看的”，当$i&gt;k$时，当$i$是奇数时$h_i$是“好看的”。于是，我们可以考虑进行dp。 设dp[i]使得$h_i$是好看的前提下，保证前$i$个$h_i$中的“看好的”数最多，需要的最少花费，那么最终答案就是min(dp[n-2],dp[n-1])。下面考虑如何转移。进过我们之前的讨论，可以知道，当$i$是偶数时，前面一个好看的数必然是偶数，当$i$是奇数时则既可能是奇数有可能是偶数，于是转移方程如下： int w = max(h[i-1], h[i+1]) - h[i] + 1; // w就是变成“好看的”的代价 if(w &lt; 0) w = 0; if(i &amp; 1) dp[i] = min(dp[i-2], dp[i-3]) + w; else dp[i] = dp[i-2] + w; 最后需要注意一点，本题需要开long long 代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 1e5 + 5; int n, h[maxn]; long long ans, dp[maxn]; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { ans = 0; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;h[i]); if(n &amp; 1) { for(int i = 2; i &lt; n; i+=2) { int w = max(h[i-1], h[i+1]) - h[i] + 1; if(w &gt; 0) ans += w; } printf(\"%lld\\n\", ans); continue; } dp[0] = dp[1] = 0; for(int i = 2; i &lt; n; i++) { int w = max(h[i-1], h[i+1]) - h[i] + 1; if(w &lt; 0) w = 0; if(i &amp; 1) dp[i] = min(dp[i-2], dp[i-3]) + w; else dp[i] = dp[i-2] + w; } printf(\"%lld\\n\", min(dp[n-1], dp[n-2])); } return 0; } D题题目大意给定长度为$n$的正整数列${a_n}$以及正整数$k$，寻找一个长度为$n$，值不超过$k$的正整数列${p_n}$，使得下面这个式子的值最小$$\\max_{1 \\le i \\le n}(\\lfloor\\frac{a_i}{p_i}\\rfloor)-\\min_{1 \\le i \\le n}(\\lfloor\\frac{a_i}{p_i}\\rfloor)$$最后题目只要求输出上面这个式子可能的最小值，不需要输出对应${p_n}$ *本题分为D1和D2，仅仅是数据范围不同 *D1范围：有多组数据$(t \\le 100)$，对于每组数据$n,k,a_n \\le 3000$，且保证${a_n}$单调不减，且对于全部数据$\\sum n \\le 3000$ *D2范围：有多组数据$(t \\le 100)$，对于每组数据$n,k,a_n \\le 10^5$，且保证${a_n}$单调不减，且对于全部数据$\\sum n \\le 10^5$ 解析 1先考虑D1怎么做，这里根据范围可以猜想存在$O(n^2)$的做法可以通过D1。显然遍历所有的${p_n}$是非常不现实的，因为复杂度将达到$O(k^n)$，十分恐怖。 观察要求的式子，如果我们令$M=\\max_{1 \\le i \\le n}(\\lfloor\\frac{a_i}{p_i}\\rfloor)$以及$m=\\min_{1 \\le i \\le n}(\\lfloor\\frac{a_i}{p_i}\\rfloor)$，则我们可以考虑遍历$M$（从$a_n$遍历到$\\lfloor\\frac{a_n}{k}\\rfloor$），然后对于每个$M$尽可能的选取较大的$m$即可。具体做法如下： 对于固定$M$和每一个$a_i$，为了使得$m$最大，则必须让每个$\\lfloor\\frac{a_i}{p_i}\\rfloor$尽量大，即$p_i$尽量小，即有$\\lfloor\\frac{a_i}{p_i}\\rfloor \\le M$但是$\\lfloor\\frac{a_i}{p_i-1}\\rfloor &gt; M$，如果记$a_i = kM + r(0\\le r &lt; M)$可以解出$p_i = k (0 \\le r &lt; k)$或者$p_i = k + 1 (k \\le r &lt; M)$。借此我们就可以以$O(n^2)$的复杂度过D1。 代码1#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 3e3 + 5; const int inf = 1e9 + 7; int n, k, a[maxn]; int ans; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { scanf(\"%d%d\", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); if(a[n] / k == 0) { puts(\"0\"); continue; } ans = inf; for(int max_val = 3000; max_val &gt;= 1; max_val--) { int min_val = inf; for(int i = 1; i &lt;= n; i++) { int p = a[i] / max_val; if(p == 0 || a[i] / p &gt; max_val) p++; if(p &gt; k) p = k; if(a[i] / p &gt; max_val) { min_val = inf; break; } min_val = min(min_val, a[i] / p); } if(min_val &lt;= max_val) ans = min(ans, max_val - min_val); } printf(\"%d\\n\", ans); } return 0; } 解析2沿用D1的思路，但是我们希望可以在$O(log n)$的复杂度内找出给定$M$情况下的最大$m$。 要做到这一点，我们要先回过头来看看式子，$\\lfloor\\frac{a_i}{p_i}\\rfloor \\le M$但是$\\lfloor\\frac{a_i}{p_i-1}\\rfloor &gt; M$，但是这次我们不解出$p_i$而是反而解出$a_i$，于是有$(M+1)(p_i-1)\\le a_i &lt; (M+1)p_i$。由于对于相同的$p_i$当然是$a_i$越小才能影响到$m$的值，所以对于每一个$M$，遍历$p$（从1开始直到$(p+1)\\cdot(M+1)&gt;a_n$为止），然后对于每一个$p$，可以用二分的方式（因为$a_n$有序）找到第一个不小于$(M+1)(p_i-1)$的$a_i$，用$\\lfloor\\frac{a_i}{p}\\rfloor$更新$m$（取min）。 于是复杂度来到了$O(\\sum\\frac{n}{i}log n)$，可以证明$O(\\sum\\frac{n}{i})=O(nlogn)$所以总的复杂度是$O(nlog^2n)$。但是这个复杂度并不是最优的（虽然对于1e5的数据已经足够了）。我们可以考虑预处理而非每次都二分来寻找$a_i$，这使得复杂度降到$O(nlogn)$。 代码2#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 1e5 + 5; const int inf = 1e9 + 7; int n, k, a[maxn]; int ans, max_val, min_val; int great_min[maxn]; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { scanf(\"%d%d\", &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); if(a[n-1] / k == 0) { puts(\"0\"); continue; } n = unique(a, a + n) - a; // 去重，显然重复的ai对本题无影响，当然这个语句本来也不是必须的 for(int i = 0, *p = a; i &lt;= a[n-1]; i++) { if(*p &lt; i) p++; great_min[i] = *p; // 预处理，即great_min[x]表示不小于x的最小的ai } max_val = a[n-1], min_val = a[0]; ans = max_val - min_val; while(max_val &gt;= a[n-1] / k) { for(int i = 0; i * (max_val+1) &lt;= a[n-1]; i++) // 这里i其实是遍历的(p-1) { min_val = min(min_val, great_min[i*(max_val+1)] / (i+1)); } ans = min(ans, max_val - min_val); max_val--; } printf(\"%d\\n\", ans); } return 0; } E题题目大意给定一个$n$个点$m$条边的无向无权连通图，点编号从1到n，边编号从1到m。 给出$q$次询问，每次询问包括两个正整数$l$和$r$。你需要找到你一个最小的满足下列要求的$k$： 对任何满足$l \\le a \\le b \\le r$的点对$(a,b)$，点$a$和点$b$可以只使用前$k$条边（即编号从1到k的边）的情况下连通 *本题有多组数据$(t \\le 1000)$，对每个数据$n\\le10^5$，$m,q\\le2\\cdot10^5$，对全部数据$\\sum n\\le10^5$，$\\sum m,\\sum q\\le2\\cdot10^5$ 解析本题第一眼看的时候有一种二分答案+可持续化并查集的感觉。然而可惜的是，每次询问不是检查两个点是否连通，而是检查一个区间是否连通。那么提到区间，就可以想到一种做法是倍增。而且我们惊人的发现两个区间的合并是如此的简单，只要有公共点，两个区间合并就是对$k$取max。于是问题转化为如何求得每两个相邻点的$k$。 转化到这个地步了，当然可以直接二份答案+可持续化并查集，可是复杂度将来到3个log，而且写起来还很麻烦，根本用不着。于是考虑只使用普通的并查集，而且不用路径压缩，而是改为启发式合并的并查集，这样做的好处就是每加一条边的时候，都只检查小集合里面的所有点有没有和相邻的点相连。复杂度是$O(nlogn)$。 于是本题总复杂度为$O(nlogn+nlogn+qlogn)$即$O((n+q)logn)$ 代码#include &lt;vector&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 1e5 + 5; const int c_pow2[] = { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072 }; int n, m, q; int fa[maxn]; int ans[maxn][20]; vector&lt;int&gt; forest[maxn]; inline int c_log2(int x) { return upper_bound(c_pow2, c_pow2 + 18, x) - c_pow2 - 1; } int main() { int T; scanf(\"%d\", &amp;T); while(T--) { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i++) { fa[i] = i; ans[i][0] = -1; vector&lt;int&gt;({i}).swap(forest[i]); } for(int i = 1; i &lt;= m; i++) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if(fa[v] == fa[u]) continue; if(forest[fa[v]].size() &gt; forest[fa[u]].size()) swap(u, v); int fa_v = fa[v]; for(int x : forest[fa_v]) { fa[x] = fa[u]; forest[fa[u]].push_back(x); } for(int x : forest[fa_v]) { if(x != 1 &amp;&amp; ans[x-1][0] == -1 &amp;&amp; fa[x-1] == fa[x]) ans[x-1][0] = i; if(x != n &amp;&amp; ans[x][0] == -1 &amp;&amp; fa[x+1] == fa[x]) ans[x][0] = i; } vector&lt;int&gt;().swap(forest[fa_v]); } vector&lt;int&gt;().swap(forest[fa[1]]); for(int pk = 1; c_pow2[pk] &lt; n; pk++) { for(int i = 1; i &lt;= n; i++) { if(c_pow2[pk] + i &gt; n) break; ans[i][pk] = max(ans[i][pk-1], ans[i+c_pow2[pk-1]][pk-1]); } } while(q--) { int l, r; scanf(\"%d%d\", &amp;l, &amp;r); int pk = c_log2(r - l); printf(\"%d \", max(ans[l][pk], ans[r-c_pow2[pk]][pk])); } puts(\"\"); } return 0; }","categories":[{"name":"竞赛","slug":"竞赛","permalink":"https://toby-shi-cloud.github.io/categories/%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://toby-shi-cloud.github.io/tags/Codeforces/"},{"name":"算法","slug":"算法","permalink":"https://toby-shi-cloud.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"Toby Shi"},{"title":"学生评教自动化脚本","slug":"EvaluationAutomationScript","date":"2022-07-04T13:00:00.000Z","updated":"2022-07-28T16:18:36.387Z","comments":true,"path":"posts/evaluation-automation-script.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/evaluation-automation-script.html","excerpt":"","text":"脚本内容javascript:function ttj(){ firrr=window.top.document.getElementById(\"iframename\").contentWindow; firrr.alert=function(){return true}; firrr.confirm=function(){return true}; a=firrr.$(\"input[name^=tabmapzb]\"); b=firrr.$(\"span.yellow\"); if(a.length!==0){ a[1].click(); a[5].click(); a[10].click(); a[15].click(); a[20].click(); a[25].click(); }else{ b[1].firstElementChild.click() } var selections = firrr.document.getElementsByTagName(\"select\"); for(var i = 0 ; i&lt; selections.length; i++){ selections[i].value = \"1\"; } firrr.tj(); } firrr=window.top.document.getElementById(\"iframename\").contentWindow; setInterval(\"firrr.$.onload = ttj()\",1400); 使用方法 登录教务系统 请勿更改主题设置 在“教学评价”中找到“学生评教” 点击“开始评教”，进入下面这个界面 按F12打开控制台，并找到Console或者“控制台” 在控制台中粘贴代码并回车运行 评教全部完成后刷新网页即可 附录在附上一个可以提前下载课表的神奇代码 var ele = $(\"#iframename\").contents().find(\"#xnxq\"); for(let i=0;i&lt;4;i++){ if(ele.children().eq(i).text()==\"2022秋季\"){ console.log(\"发现目标，正在等待下载\"); ele[0].selectedIndex = i; break; } } document.getElementsByTagName(\"iframe\")[0].contentWindow.exportExcel();","categories":[{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/categories/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/tags/%E8%84%9A%E6%9C%AC/"}],"author":"Unknown"},{"title":"蓝桥杯2022决赛参赛记录","slug":"LanQiaoCup2022Final","date":"2022-06-18T13:50:00.000Z","updated":"2022-11-26T11:42:36.966Z","comments":true,"path":"posts/lanqiaocup2022final.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/lanqiaocup2022final.html","excerpt":"","text":"A 题：小蓝与钥匙问题描述 小蓝是幼儿园的老师，他的班上有 28 个孩子，今天他和孩子们一起进行了一个游戏。 小蓝所在的学校是寄宿制学校，28 个孩子分别有一个自己的房间，每个房间对应一把钥匙，每把钥匙只能打开自己的门。现在小蓝让这 28 个孩子分别将自己宿舍的钥匙上交，再把这 28 把钥匙随机打乱分给每个孩子一把钥匙，有$28! = 28\\times27\\times \\cdots \\times1 $种分配方案。小蓝想知道这些方案中，有多少种方案恰有一半的孩子被分到自己房间的钥匙（即有 14 个孩子分到的是自己房间的钥匙，有 14 个孩子分到的不是自己房间的钥匙）。 答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 考场思路显然这个题分为两步，一是有14个同学分到了自己的钥匙，二是剩下的14个同学都没有分到自己的钥匙，记方案数为$Q$，则有：$$Q = C_{28}^{14} \\cdot D_{14}$$其中$D_{14}$为14的全错位排列。全错位排列也称“欧拉装错信箱问题”，其计算可用容斥原理，公式如下：$$D_n = \\sum_{i=0}^{n} (-1)^i \\cdot C_n^i \\cdot (n-i)!$$或者：$$D_n = n! \\cdot \\sum_{i=0}^{n} \\frac{(-1)^i}{i!}$$于是有方案数$Q=1,286,583,532,342,313,400$ B 题：排列距离问题描述 小蓝最近迷上了全排列，现在他有一个长度为 17 的排列，里面包含的元素有：abcdefghijklnopqr，即 a 至 r 中除了 m 以外的所有小写字母，这 17个字母在任何一个排列中都恰好出现一次。前面几个排列依次是： 第 1 个排列为：abcdefghijklnopqr； 第 2 个排列为：abcdefghijklnoprq； 第 3 个排列为：abcdefghijklnoqpr； 第 4 个排列为：abcdefghijklnoqrp； 第 5 个排列为：abcdefghijklnorpq； 第 6 个排列为：abcdefghijklnorqp； 第 7 个排列为：abcdefghijklnpoqr； 第 8 个排列为：abcdefghijklnporq； 第 9 个排列为：abcdefghijklnpqor； 第 10 个排列为：abcdefghijklnpqro。 对于一个排列，有两种转移操作：1）转移到其下一个排列。如果当前排列已经是最后一个排列，那么下一个排列就是第一个排列。2）转移到其上一个排列。如果当前排列是第一个排列，那么上一个排列就是最后一个排列。小蓝现在有两个排列，分别为排列 A：aejcldbhpiogfqnkr，以及排列B：ncfjboqiealhkrpgd，他现在想知道，在只有上述两种转移操作的前提下，排列 A 最少转移多少次能得到排列 B。 答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 考场思路显然只要知道了排列A和排列B分别是第几个排列就可以了。 因此我们使用康托展开（Cantor expansion）就可以了。若记排列$\\lambda$为$a_1,a_2,a_3,\\dots,a_n$，则有：$$X_{\\lambda} = q_1 \\cdot (n-1)! + q_2 \\cdot (n-2)! + \\cdots + q_n \\cdot 0!$$其中$q_i$表示$a_i$在$a_i,a_{i+1},\\dots,a_n$中是第$q_i$小的数，则$X_\\lambda$表示排列$\\lambda$是第$X_\\lambda$个排列。（注：这里第几小的数和第几个排列都从0开始标号，计算会比较方便） 最后我的结果是：排列A的编号是$4,542,892,071,974$，排列B的编号是$254,081,962,595,831$，最终答案取$min{X_A - X_B + 19!, X_B - X_A} = 106,148,357,572,143$即可。 C 题：内存空间问题描述 小蓝最近总喜欢计算自己的代码中定义的变量占用了多少内存空间。 为了简化问题，变量的类型只有以下三种：int：整型变量，一个 int 型变量占用 4 Byte 的内存空间。long：长整型变量，一个 long 型变量占用 8 Byte 的内存空间。String：字符串变量，占用空间和字符串长度有关，设字符串长度为 L，则字符串占用 L Byte 的内存空间，如果字符串长度为 0 则占用 0 Byte 的内存空间。 定义变量的语句只有两种形式，第一种形式为：type var1=value1,var2=value2...;定义了若干个 type 类型变量 var1、var2、…，并且用 value1、value2…初始化，多个变量之间用’,’ 分隔，语句以’;’ 结尾，type 可能是 int、long 或 String。例如 int a=1,b=5,c=6; 占用空间为 12 Byte；long a=1,b=5; 占用空间为 16 Byte；String s1=””,s2=”hello”,s3=”world”; 占用空间为 10 Byte。 第二种形式为：type[] arr1=new type[size1],arr2=new type[size2]...;定义了若干 type 类型的一维数组变量 arr1、arr2…，且数组的大小为size1、size2…，多个变量之间用’,’ 进行分隔，语句以’;’ 结尾，type 只可能是 int 或 long。例如 int[] a1=new int[10]; 占用的内存空间为 40Byte；long[] a1=new long[10],a2=new long[10]; 占用的内存空间为160 Byte。 已知小蓝有 T 条定义变量的语句，请你帮他统计下一共占用了多少内存空间。结果的表示方式为：aGBbMBcKBdB，其中 a、b、c、d 为统计的结果，GB、MB、KB、B 为单位。优先用大的单位来表示，1GB=1024MB，1MB=1024KB，1KB=1024B，其中 B 表示 Byte。如果 a、b、c、d 中的某几个数字为 0，那么不必输出这几个数字及其单位。题目保证一行中只有一句定义变量的语句，且每条语句都满足题干中描述的定义格式，所有的变量名都是合法的且均不重复。题目中的数据很规整，和上述给出的例子类似，除了类型后面有一个空格，以及定义数组时 new 后面的一个空格之外，不会出现多余的空格。 输入格式 输入的第一行包含一个整数 T ，表示有 T 句变量定义的语句。接下来 T 行，每行包含一句变量定义语句。 输出格式 输出一行包含一个字符串，表示所有语句所占用空间的总大小。 测试样例 样例输入 样例输出 1long[] nums=new long[131072]; 1MB 4int a=0,b=0;long x=0,y=0;String s1=”hello”,s2=”world”;long[] arr1=new long[100000],arr2=new long[100000]; 1MB538KB546B 样例说明 样例 1，占用的空间为 131072 × 8 = 1048576 B，换算过后正好是 1MB，其它三个单位 GB、KB、B 前面的数字都为 0 ，所以不用输出。 样例 2，占用的空间为 4 × 2 + 8 × 2 + 10 + 8 × 100000 × 2 B，换算后是1MB538KB546B。 规模与约定 对于所有评测用例，1 ≤ T ≤ 10，每条变量定义语句的长度不会超过 1000。所有的变量名称长度不会超过 10，且都由小写字母和数字组成。对于整型变量，初始化的值均是在其表示范围内的十进制整数，初始化的值不会是变量。对于 String 类型的变量，初始化的内容长度不会超过 50，且内容仅包含小写字母和数字，初始化的值不会是变量。对于数组类型变量，数组的长度为一个整数，范围为：$[0, 2^{30}]$，数组的长度不会是变量。T 条语句定义的变量所占的内存空间总大小不会超过 1 GB，且大于 0 B。 考场思路这个题，怎么说呢，几乎就是纯模拟吧大概。 首先每行的首个字符串就是类型说明，然后对于不同的类型找不同的符号就可以了。 比如int和long型，就找有多少个“,”；数组就找“int[”和“long[”；字符串就找“””就可以了。 部分代码如下： void solve_int(const char* str) { while(*str) { if(*str == ',' || *str == ';') ans += 4; str++; } } void solve_int_arr(const char* str) { const char* tmp; // const char* lst = str + strlen(str); while((tmp = strstr(str, \"int[\")) != NULL) { tmp += 4; int num = 0; while(isdigit(*tmp)) { num = num * 10 + (*tmp - '0'); tmp++; } str = tmp; ans += 4 * num; } } void solve_long(const char* str) { while(*str) { if(*str == ',' || *str == ';') ans += 8; str++; } } void solve_long_arr(const char* str) { const char* tmp; // const char* lst = str + strlen(str); while((tmp = strstr(str, \"long[\")) != NULL) { tmp += 5; int num = 0; while(isdigit(*tmp)) { num = num * 10 + (*tmp - '0'); tmp++; } str = tmp; ans += 8 * num; } } void solve_String(const char* str) { const char* tmp; // const char* lst = str + strlen(str); while((tmp = strchr(str, '\\\"')) != NULL) { // fprintf(\"tmp=%s\\n\",tmp); tmp += 1; int num = 0; while(*tmp != '\\\"') { num++; tmp++; } str = tmp + 1; ans += num; } } D 题：最大公约数问题描述 给定一个数组，每次操作可以选择数组中任意两个相邻的元素 x, y 并将其中的一个元素替换为 gcd(x, y) ，其中 gcd(x, y) 表示 x 和 y 的最大公约数。 请问最少需要多少次操作才能让整个数组只含 1 。 输入格式 输入的第一行包含一个整数 n ，表示数组长度。 第二行包含 n 个整数 a1, a2, · · · , an，相邻两个整数之间用一个空格分隔。 输出格式 输出一行包含一个整数，表示最少操作次数。如果无论怎么操作都无法满足要求，输出 −1。 测试样例 样例输入 样例输出 34 6 9 4 规模与约定 对于 30% 的评测用例，$n ≤ 500 ，a_i ≤ 1000$；对于 50% 的评测用例，$n ≤ 5000 ，a_i ≤ 10^6$；对于所有评测用例，$1 ≤ n ≤ 100000 ，1 ≤ a_i ≤ 10^9$。 考场思路可以发现，如果数列中有一个数为1，那么问题就很好解决了：答案即为非1的个数。 因此本题的关键在于如何最快的弄出一个1。 由于题目只允许相邻的两个数取gcd，所以如果找到连续k个数gcd为1的话，就可以用k-1次操作把其中一个数换为1，因此答案为：n+k-2。（当然，如果这n个数的gcd为非1，就直接输出-1即可） 于是问题化为如何找到这个最小的k。 稍微暴力的做法是，首先求两个两个的gcd，然后求三个三个的gcd（可以发现，三个数的gcd就是相邻两个gcd的gcd），依次下去，每次gcd的数目减小1，于是时间复杂度是$O(\\sum_{i=1}^n i)$即$O(n^2)$（由于$a_i$并不大，所以gcd的复杂度（不超过$O(5 \\lg n)$，大约就是10倍左右）就忽略了）实现大致如下： void focus_solve() { int ans = n - 1; while(!flag) { n--; ans++; for(int i = 0; i &lt; n; i++) { num[i] = gcd(num[i], num[i+1]); if(num[i] == 1) {flag = true;break;} } } printf(\"%d\\n\", ans); } 至于100%的数据，我使用了倍增+二分，复杂度大概是$O(40nlogn)$（倍数是gcd的复杂度），复杂度上肯定是没有问题的。大致的想法就是先预处理出从数量任意一个数起，2的整次幂个数的gcd，这里复杂度就是$O(20nlogn)$。然后对上面说的k进行二分（k最大取n），每次check遍历起点，然后用预处理的数据计算出k个数的gcd，也是$O(20nlogn)$。代码大致如下： const int pow2[] = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072}; bool check(int x) { int logval = upper_bound(pow2, pow2 + 18, x) - pow2 - 1; // logval = log2(x)向下取整-1 for(int i = 0; i &lt; n - x + 1; i++) { int l = i, r = i + x; int _g = gcd(_gcd_2[l][logval], _gcd_2[r-pow2[logval]][logval]); // _gcd_2就是预处理数组 if(_g == 1) return true; } return false; } void solve() { int max_log = upper_bound(pow2, pow2 + 18, n) - pow2; for(int p = 0; p &lt; max_log; p++) for(int i = 0; i &lt; n; i++) { if(p == 0) _gcd_2[i][0] = num[i]; else if (i+pow2[p-1] &gt;= n) _gcd_2[i][p] = _gcd_2[i][p-1]; else _gcd_2[i][p] = gcd(_gcd_2[i][p-1], _gcd_2[i+pow2[p-1]][p-1]); } int L = 1, R = n; while(L != R) { int mid = L + R &gt;&gt; 1; if(check(mid)) R = mid; else L = mid + 1; } printf(\"%d\\n\", n + L - 2); } E 题：owo问题描述 小蓝很喜欢 owo ，他现在有一些字符串，他想将这些字符串拼接起来，使得最终得到的字符串中出现尽可能多的 owo 。 在计算数量时，允许字符重叠，即 owowo 计算为 2 个，owowowo 计算为3 个。 请算出最优情况下得到的字符串中有多少个 owo。 输入格式 输入的第一行包含一个整数 n ，表示小蓝拥有的字符串的数量。接下来 n 行，每行包含一个由小写英文字母组成的字符串 si 。 输出格式 输出 n 行，每行包含一个整数，表示前 i 个字符串在最优拼接方案中可以得到的 owo 的数量。 测试样例 样例输入 样例输出 3owowow 112 规模与约定 对于 10% 的评测用例，$n ≤ 10$；对于 40% 的评测用例，$n ≤ 300$；对于 60% 的评测用例，$n ≤ 5000$；对于所有评测用例，$1 ≤ n ≤ 10^6 ，1 ≤ |s_i| ，\\sum|s_i| ≤ 10^6$，其中 $|s_i|$表示字符串$s_i$的长度。 考场思路首先肯定要能计算出每个字符串内部的owo的个数，当然这个是比较好计算的，用kmp或者直接用两个flag就能搞定。 其实是最重要的，要考虑拼接，不过好在这个owo很短，可用的拼接方式并不多，大致应该只有如下三种： 以ow结尾+以o开头 以o结尾+以wo开头 以o结尾+单独一个字母w+以o开头 因此我们就统计上面这些可以拼接的字符串的数量就可以了。但是需要注意的是，如果一个字符串既以ow结尾又以o开头，虽然都要计数，但是不能自己和自己拼接在一起，不仅如此，字符串也不能拼接成环。但是这个我在考试的时候想的不多，就没有考虑完全，大概是寄了，因此就不放代码了，如何实现就留给读者思考吧。 F 题：环境治理问题描述 LQ 国拥有 n 个城市，从 0 到 n − 1 编号，这 n 个城市两两之间都有且仅有一条双向道路连接，这意味着任意两个城市之间都是可达的。每条道路都有一个属性 D ，表示这条道路的灰尘度。当从一个城市 A 前往另一个城市 B 时，可能存在多条路线，每条路线的灰尘度定义为这条路线所经过的所有道路的灰尘度之和，LQ 国的人都很讨厌灰尘，所以他们总会优先选择灰尘度最小的路线。 LQ 国很看重居民的出行环境，他们用一个指标 P 来衡量 LQ 国的出行环境，P 定义为：$$P = \\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1}d(i,j)$$其中 d(i, j) 表示城市 i 到城市 j 之间灰尘度最小的路线对应的灰尘度的值。 为了改善出行环境，每个城市都要有所作为，当某个城市进行道路改善时，会将与这个城市直接相连的所有道路的灰尘度都减少 1，但每条道路都有一个灰尘度的下限值 L，当灰尘度达到道路的下限值时，无论再怎么改善，道路的灰尘度也不会再减小了。 具体的计划是这样的：第 1 天，0 号城市对与其直接相连的道路环境进行改善；第 2 天，1 号城市对与其直接相连的道路环境进行改善；…第 n 天，n − 1 号城市对与其直接相连的道路环境进行改善；第 n + 1 天，0 号城市对与其直接相连的道路环境进行改善；第 n + 2 天，1 号城市对与其直接相连的道路环境进行改善；… LQ 国想要使得 P 指标满足 P ≤ Q。请问最少要经过多少天之后，P 指标可以满足 P ≤ Q。如果在初始时就已经满足条件，则输出 0 ；如果永远不可能满足，则输出 −1。 输入格式 输入的第一行包含两个整数$n, Q$，用一个空格分隔，分别表示城市个数和期望达到的$P$指标。 接下来$n$行，每行包含$n$个整数，相邻两个整数之间用一个空格分隔，其中第$i$行第$j$列的值$D_{ij}$ $(D_{ij} = D_{ji}, D_{ii} = 0)$表示城市$i$与城市$j$之间直接相连的那条道路的灰尘度。 接下来$n$行，每行包含$n$个整数，相邻两个整数之间用一个空格分隔，其中第$i$行第$j$列的值$L_{ij}$ $(L_{ij} = L_{ji}, L_{ii} = 0)$表示城市$i$与城市$j$之间直接相连的那条道路的灰尘度的下限值。 输出格式 输出一行包含一个整数表示答案。 测试样例 样例输入 样例输出 3 100 2 42 0 14 1 00 2 22 0 02 0 0 2 样例说明 初始时的图如下所示，每条边上的数字表示这条道路的灰尘度：此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：$$d(0, 0) = 0, d(0, 1) = 2, d(0, 2) = 3, \\d(1, 0) = 2, d(1, 1) = 0, d(1, 2) = 1, \\d(2, 0) = 3, d(2, 1) = 1, d(2, 2) = 0.$$初始时的 P 指标为 (2 + 3 + 1) × 2 = 12，不满足 P ≤ Q = 10；第一天，0 号城市进行道路改善，改善后的图示如下：注意到边 (0, 2) 的值减小了 1 ，但 (0, 1) 并没有减小，因为 L0,1 = 2 ，所以(0, 1) 的值不可以再减小了。此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：$$d(0, 0) = 0, d(0, 1) = 2, d(0, 2) = 3, \\d(1, 0) = 2, d(1, 1) = 0, d(1, 2) = 1, \\d(2, 0) = 3, d(2, 1) = 1, d(2, 2) = 0.$$此时 P 仍为 12。第二天，1 号城市进行道路改善，改善后的图示如下：此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：$$d(0, 0) = 0, d(0, 1) = 2, d(0, 2) = 2, \\d(1, 0) = 2, d(1, 1) = 0, d(1, 2) = 0, \\d(2, 0) = 2, d(2, 1) = 0, d(2, 2) = 0.$$此时的 P 指标为 (2 + 2) × 2 = 8 &lt; Q ，此时已经满足条件。所以答案是 2。 规模与约定 对于 30% 的评测用例，$1 ≤ n ≤ 10 ，0 ≤ L_{ij} ≤ D_{ij} ≤ 10$；对于 60% 的评测用例，$1 ≤ n ≤ 50 ，0 ≤ L_{ij} ≤ D_{ij} ≤ 100000$；对于所有评测用例，$1 ≤ n ≤ 100 ，0 ≤ L_{ij} ≤ D_{ij} ≤ 100000 ，0 ≤ Q ≤ 2^{31} − 1$。 考场思路不得不说这个题长到离谱（其实是样例解释长），所以我最后看的这个题。这个题暴力的话显然就是每天都用Floyd算法求一遍最短路，然后求一遍P就可以了，复杂度上是$O(day \\cdot n^3)$，其中Day是需要经历的天数，至于输出-1的情况，完全可以用$L_{ij}$作为边权跑一次Floyd就知道了。问题就是，这个复杂度是无法接受的，甚至连60%的数据都不能通过，只能拿到30%的分。 这里呢注意到数据规模中$n$是比较小的，但是$D-L$可能是比较大，所以考虑二分答案，理想中复杂度应该是$O(log(\\frac12n(D-L))\\cdot n^3)$，这样复杂度的话就很可以接受了。这里二分的话最大的天数应该是$\\frac12nD=5e6$。check函数的代码大概如下（复杂度是$O(n^2 + n^3)$）： bool check(int day) { int turn = day / n; // 每一轮，每条道路灰尘度下降2 day %= n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) { dis[i][j] = D[i][j] - 2 * turn; if(day &gt; i) dis[i][j]--; // 如果这一轮城市i还进行了清理 if(day &gt; j) dis[i][j]--; // 如果这一轮城市j还进行了清理 if(dis[i][j] &lt; L[i][j]) dis[i][j] = L[i][j]; // 注意灰尘度是有下限的 } floyd(); P = 0; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) P += dis[i][j]; if(P &lt;= Q) return 1; return 0; } G 题：选素数问题描述 小蓝有一个数 x，每次操作小蓝会选择一个小于 x 的素数 p，然后在 x 成为 p 的倍数前不断将 x 加 1，(如果 x 一开始就是 p 的倍数则 x 不变)。 小乔看到了小蓝进行了 2 次上述操作后得到的结果 n，他想知道 x 在一开始是多少。如果有多种可能，他想知道 x 一开始最小可以是多少，而如果不存在任何解，说明小乔看错了，此时请输出 −1。 输入格式 输入一行包含一个整数 n ，表示经过两次操作后 x 的值。 输出格式 输出一行包含一个整数表示 x 的初始值。如果有多个解，输出最小的。如果不存在解，请输出 −1 。 测试样例 样例输入 样例输出 22 8 规模与约定 对于 60% 的评测用例，$1 ≤ n ≤ 5000$；对于所有评测用例，$1 ≤ n ≤ 10^6$。 考场思路这个题的长度就和前面那个题形成了鲜明的对比😃。经过一番思考，可以发现，如果数$x=p_1^{k_1}p_2^{k_2}\\cdots p_m^{k_m}$且其中$p_1 &lt; p_2 &lt; \\cdots &lt; p_m$，则$x$的上一个数可能且只可能位于$[x-p_m+1,x-1]$中，且如果$x$是素数，这上一个数不存在。 发现这一点之后就可以做了，只需要先把$x$质因数分解，然后找出最大的素因子，得到只经过一轮的数，然后在把所有可能的数都再进行一次操作，就可以得到所有符合要求的原始数了。复杂度应该是$O(\\sum_{i=\\sqrt n}^{n} \\sqrt i)$，不过经过计算可知这个复杂度大约是$O(n^{\\frac32})$，其实是过不了全部数据的，但是由于大部分数不是质数，都拥有较小的质因子，所以分解质因数的复杂度应当小于$O(\\sqrt x)$，所以我大胆猜测是可以过的。 考试代码如下： unsigned solve(int x, int depth) { if(depth == 0) return x; if(x &lt;= 2) return (unsigned)-1; vector&lt;int&gt; prime_i; // 显然是没有必要的 int tmp = x; for(int i = 2; i * i &lt;= tmp; i++) { if(tmp % i == 0) { prime_i.push_back(i); while(tmp % i == 0) tmp /= i; } } if(tmp != 1 &amp;&amp; tmp != x) prime_i.push_back(tmp); // tmp==x说明是x质数 if(prime_i.empty()) return (unsigned)-1; int max_p = prime_i.back(); unsigned anss = (unsigned)-1; for(int i = 1; i &lt; max_p; i++) { anss = min(anss, solve(x - i, depth-1)); // 用unsigned其实就是为了取min方便 } return anss; } 主函数调用solve(n,2)然后把返回值转化为int即可。 未完待续……其实剩下的三个题我都不会了……😢","categories":[{"name":"竞赛","slug":"竞赛","permalink":"https://toby-shi-cloud.github.io/categories/%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"算法","slug":"算法","permalink":"https://toby-shi-cloud.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://toby-shi-cloud.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"author":"TobyShi"},{"title":"【Python】使用socket库实现server-client通讯的联机对战游戏（一）","slug":"Socket","date":"2022-06-16T13:30:00.000Z","updated":"2022-06-16T14:59:48.192Z","comments":true,"path":"posts/pythonsocket.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/pythonsocket.html","excerpt":"","text":"socket单对单通讯socket是Python内建库之一，用途就是网络通讯。作为实验，我们考虑两个Python程序之间的通讯，一个作为服务器，一个作为客户端，客户端向服务器发送一串字符，服务器收到后将原字符串大写后传回，直到客户端发送空信息，服务器退出。 服务器端代码： import socket ip_port = ('', 8888) # 这个tuple的第一项是ip地址，第二项是端口 s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 定义socket类型，网络通信，TCP s.bind(ip_port) # 套接字绑定ip和端口 s.listen(1) # 开始监听连接请求 conn, addr = s.accept() # 接受连接请求，conn是一个新的套接字，addr是客户端地址 conn.sendall('Hello from the server!'.encode('utf-8')) # 发送打招呼信息，并且用utf-8编码 while True: try: data = conn.recv(1024).decode('utf-8') # 接受数据并使用utf-8解码 if not data: break # 如果数据为空就退出 conn.sendall(data.upper().encode('utf-8')) # 把数据大写后返回 except Exception as e: # 如果数据传输出错 print(e) exit(1) conn.close() # 关闭套接字 客户端代码： import socket ip_port = ('localhost', 8888) # 服务器ip和端口 s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 定义socket类型，网络通信，TCP try: s.connect(ip_port) # 尝试连接服务器 except Exception as e: # 如果连接失败socket.socket.connect会抛出错误 print(e) exit(1) data = s.recv(1024).decode('utf-8') # 接受服务器的问候 print(data) while True: try: msg = input('&gt;&gt;&gt; ') # 此时用户可以在运行客户端的控制台中输入内容 s.sendall(msg.encode('utf-8')) # 将消息发送 if not msg: break # 如果数据为空就退出 data = s.recv(1024).decode('utf-8') # 接受服务器的结果 print(data) except Exception as e: # 如果数据传输出错 print(e) exit(1) s.close() # 关闭套接字 运行结果： socketserver多对一通讯由于我的目的是打算写一个联机对战游戏，那么一个服务器需要同时和多个（至少是两个）客户端建立连接。一个很容易想到的做法就是服务器多线程。好在Python已经帮我们封装好了多线程和socket库——socketserver库。 socketserver库的用法和socket几乎一模一样，而且由于只有服务器端需要多线程，所以只需要更改server.py即可。 下面是server.py的代码： import socketserver ip_port = ('', 10888) class MyServer(socketserver.BaseRequestHandler): def handle(self): # 重写RequestHandler中的handle方法用来处理请求 print(\"conn is :\", self.request) # conn print(\"addr is :\", self.client_address) # addr self.request.sendall('Hello from the server!'.encode('utf-8')) while True: # 处理方面的逻辑都是一样的 try: data = self.request.recv(1024).decode('utf-8') if not data: break self.request.sendall(data.upper().encode('utf-8')) except Exception as e: print(e) break print(\"disconnected with\", self.client_address) if __name__ == '__main__': s = socketserver.ThreadingTCPServer(ip_port, MyServer) # 建立TCP协议套接字 # 使用s.serve_forever()接受无穷次连接（需要按下Ctrl+C中断） # 也可以使用一次s.handle_request()接受一次连接 s.serve_forever() 运行结果： 服务器内部数据传输现在我们已经解决了服务器和客户端之间的数据传输问题了，但是这又引入了新的问题：服务器用多线程和客户端交流，但是socketserver封装的太好了，想要直接从外部操作各个线程显然不显示，那么如何进行服务器各个线程之间的交流呢？ 请听下回分解…… 😀","categories":[{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/tags/Python/"},{"name":"网络","slug":"网络","permalink":"https://toby-shi-cloud.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"server-client","slug":"server-client","permalink":"https://toby-shi-cloud.github.io/tags/server-client/"}],"author":"TobyShi"},{"title":"你好博客！Hello Blog!","slug":"HelloBlog","date":"2022-06-14T11:30:00.000Z","updated":"2022-07-20T12:03:43.586Z","comments":true,"path":"posts/helloblog.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/helloblog.html","excerpt":"","text":"01 从零开始搭建属于自己的博客具体操作见此博客 不过由于我之前弄过一半，所以这一步的操作就省了，因此这里就不记录了。 02 选择合适的好看的Theme经过许多次试错，最终看到了Luckey大佬的视频，十分羡慕，于是clone了他的博客. 03 博客个性化如果说前面的内容都是跟着教程动动手指就可以完成，那么这一步将会是最大的噩梦。 其中最大的问题就是：我压根没有学过前端，大佬的博客的复杂程度对于我来说简直难以想象。因此这里要特别感谢Luckey大佬的教程以及Matery主题的使用手册，中文文档真的对我这种英语白痴非常友好！ 然后我就开始看着各式各样的文档一通乱改，为了降低改动难度，我就把用不到的功能的入口删掉了，但是如果你手动输入争取的url的话其实依然可以看到Luckey大佬的很多让我大为震撼的功能，想看的朋友可以去他的博客欣赏欣赏。 我做的比较到大的改动就是升级了这个Theme使用的fontawesome的版本，不过其实只需要在官网下载一个zip然后把里面的东西全部覆盖到~\\themes\\matery\\source\\libs\\awesome就可以了。（这样做是因为只有新版才支持B站的图标，不过Gitee的图标仍然木有） 最后比较遗憾的是，不知道为什么我在“视频”栏中嵌入视频失败了，不知道是不是B站嵌入视频已经失效了。 04 Markdown公式测试$$ S_n = \\sum_{i=1}^{n} a_i $$$$ \\int \\cos(x) dx = \\sin(x) $$ 这是行内公式：$\\lim_{x\\rightarrow 0} \\frac{x}{\\sin x} = 1$ 经过测试，公式内换行不知道为什么没有得到支持。 05 在忙了一下午之后总之到晚上的时候我就已经开始写这篇HelloBlog了，还是很兴奋的，毕竟从未有过写前端的经历，然后几乎是从零开始学习搭建，所以真的非常感谢大佬们的帮助。因此如果有朝一日，我也有能力以后，也一定会向把知识分享出来，供大家学习和参考。 无限进步！","categories":[{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"TobyShi"},{"title":"蓝桥杯2022省赛参赛记录","slug":"LanQiaoCup2022Preliminary","date":"2022-04-09T13:00:00.000Z","updated":"2022-11-08T10:04:46.979Z","comments":true,"path":"posts/lanqiaocup2022preliminary.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/lanqiaocup2022preliminary.html","excerpt":"","text":"第十三届蓝桥杯大赛软件赛省赛C/C++ 大学 A 组本文其他链接CSDN 纪念我参加的第一次蓝桥杯 2022年4月9日 9:00 - 13:00这次蓝桥杯因为疫情，在线上举行 听学长学姐们说蓝桥杯又叫“送钱杯”，省一有手就行那我就在这里先求一个省一吧！2k 奖学金！求求了！ 序因为鄙人才学不高，所以这份题解中的解法难免有纰漏之处，还望各路神犇指出，鄙人将感激不尽。 题目链接题目pdf 试题A: 裁纸刀我的思路考虑记忆化搜索。后来听说怎么剪都是一样的？？？记int mem[n][m]为有$n$行$m$列个二维码时，需要剪多少次（不考虑边框）于是递归公式为$$mem[n][m] = \\min(\\min_{1 \\leq i \\leq n-1}(mem[i][m]+mem[n-i][m]+1), \\min_{1 \\leq i \\leq m-1}(mem[n][i]+mem[n][m-i]+1))$$最后答案是 $mem[20][22] + 4 = 443$ 我的代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int inf = 1 &lt;&lt; 30; int mem[30][30]; int cut(int n, int m) { if(n == 1 &amp;&amp; m == 1) return 0; if(mem[n][m]) return mem[n][m]; int r1 = inf; for(int i = 1; i &lt; n; i++) r1 = min(r1, cut(i, m) + cut(n-i, m) + 1); int r2 = inf; for(int j = 1; j &lt; m; j++) r2 = min(r2, cut(n, j) + cut(n, m-j) + 1); return mem[n][m] = min(r1, r2); } int main() { printf(\"%d\\n\", 4 + cut(20, 22)); return 0; } 试题B: 灭鼠先锋我的思路这应该就是一个普通的0/1博弈（这个博弈的名字似乎叫sg博弈）状态一共就$2^8$种，一点也不多。最后答案应该是LLLV 我的代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int f[300]; int rev(int st) { if(f[st]) return f[st]; f[st] = -1; for(int i = 0; i &lt; 8; i++) { if(!(st &amp; (1 &lt;&lt; i))) { if(rev(st | (1 &lt;&lt; i)) == -1) { f[st] = 1; break; } } } if(f[st] != 1) for(int i = 0; i &lt; 7; i++) if(i != 3) { if(!(st &amp; (3 &lt;&lt; i))) { if(rev(st | (3 &lt;&lt; i)) == -1) { f[st] = 1; break; } } } return f[st]; } int main() { f[0xff] = 1; //这里取负是因为，先手已经下过了，所以就后手赢先手就输，后手输先手就赢 printf(\"%d\\n\", -rev(0b10000000)); printf(\"%d\\n\", -rev(0b11000000)); printf(\"%d\\n\", -rev(0b01000000)); printf(\"%d\\n\", -rev(0b01100000)); return 0; } 试题C: 求和我的思路签到题，预处理sum就可以了（而且这题还良心的不会爆long long），复杂度$O(n)$ 我的代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 2e5 + 10; int n, a[maxn]; long long sum_ = 0; long long ans = 0; int main() { scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); for(int i = 0; i &lt; n; i++) sum_ += a[i]; for(int i = 0; i &lt; n; i++) ans += a[i] * (sum_ - a[i]); ans /= 2; printf(\"%lld\\n\", ans); return 0; } 试题D: 选数异或我的思路这个题考场上想了好久好久，最后居然还是只写了一个$O(n^2m)$的暴力，只能得2分，我人傻了 之后突然发现可以离线……于是对每个询问的r排序，这个题就解决了 具体来说，就是开一个map&lt;int,int&gt; mp来存数字x出现的最晚的位置（由于$a_i\\leq 2^{20}$所以直接开数组也可以）再令int near为最近的可以满足要求的位置，初始化为0然后从0开始遍历整个数列，每次遍历时更新near = max(near, mp[a[i]^x])，然后更新mp[a[i]] = i，然后处理所有r == i的询问，使得他们的答案ans = (l &gt;= near) 我的代码#include &lt;map&gt; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define yesno(x) \\ do { \\ if(x) printf(\"yes\\n\"); \\ else printf(\"no\\n\"); \\ } while(0) const int maxn = 1e5 + 10; map&lt;int, int&gt; mp; int n, m, x, a[maxn]; struct Ques { int l, r, id; bool ans; }q[maxn]; bool cmp_1(const Ques&amp; p, const Ques&amp; q) { return p.r &lt; q.r; } bool cmp_2(const Ques&amp; p, const Ques&amp; q) { return p.id &lt; q.id; } int main() { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;x); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for(int i = 0; i &lt; m; i++) { scanf(\"%d%d\", &amp;q[i].l, &amp;q[i].r); q[i].id = i; } sort(q, q+m, cmp_1); int ptr = 0, near = 0; for(int i = 0; i &lt; m; i++) { while(ptr &lt;= q[i].r) { near = max(near, mp[a[ptr] ^ x]); mp[a[ptr]] = ptr; ptr++; } q[i].ans = (near &gt;= q[i].l); } sort(q, q+m, cmp_2); for(int i = 0; i &lt; m; i++) { yesno(q[i].ans); } return 0; } 试题E: 爬树的甲壳虫我的思路期望dp其实也不是dp就是一个单纯的递推式：$$E(k) = P(k)*E(0) + (1-P(k))*E(k+1) + 1$$显然要逆向计算。注意到逆向计算时E(0)是未知的，但是始终只会出现一次项不妨直接开一个结构体（或者pair）来表示期望，结构体中就存两个数：一个是E(0)的系数，还有一个是常数最后就递推得到关于E(0)的一个一次方程，就能求出E(0)了 另外就是常规的小费马定理求分数取模 我的代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int modp = 998244353; int qpow(int base, int exp) { if(!exp) return 1; if(exp &amp; 1) return base * 1ll * qpow(base * 1ll * base % modp, exp &gt;&gt; 1) % modp; return qpow(base * 1ll * base % modp, exp &gt;&gt; 1); } const int maxn = 1e5 + 10; int n, P[maxn]; struct ANS { int r, t; // r是系数，t是常数；为什么用这两个字母？我乱选的 ANS() {} ANS(int _r, int _t) { r = _r; t = _t; } ANS operator * (const int ot) const { return ANS(r * 1ll * ot % modp, t * 1ll * ot % modp); } ANS operator + (const ANS &amp;ot) const { return ANS((r + ot.r) % modp, (t + ot.t) % modp); } } ans[maxn]; int main() { scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) { int a, b; scanf(\"%d%d\", &amp;a, &amp;b); P[i] = a * 1ll * qpow(b, modp - 2) % modp; } ans[n] = ANS(0, 0); for(int k = n - 1; k &gt;= 0; k--) { ans[k] = ANS(P[k], 0) + ans[k+1] * ((1 - P[k] + modp) % modp) + ANS(0, 1); } printf(\"%lld\\n\", ans[0].t * 1ll * qpow((1 - ans[0].r + modp) % modp, modp - 2) % modp); return 0; } 试题F: 青蛙过河我的思路显然二分答案，关键是怎么进行check这里我是贪心做的，不知道对不对。也就是说每次都尽量往最远的地方跳 我的代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 1e5 + 10; int n, x, h[maxn], h_copy[maxn]; long long cnt[maxn]; inline bool check(int y) { for(int i = 1; i &lt; n; i++) h_copy[i] = h[i]; int far = n - 1; // 用来记录当前可以到达的最远的地方 for(int i = n - 1; i &gt; 0; i--) { cnt[i] = 0; // 考试的时候没写！我肯定寄了…… if(i + y &gt;= n) { cnt[i] = h_copy[i]; continue; } far = min(far, i + y); while(far &gt; i) { if(cnt[far] &lt;= h_copy[i]) { h_copy[i] -= cnt[far]; cnt[i] += cnt[far]; cnt[far] = 0; far--; } else { cnt[far] -= h_copy[i]; cnt[i] += h_copy[i]; h_copy[i] = 0; break; } } } cnt[0] = 0; for(int i = 1; i &lt;= y; i++) cnt[0] += cnt[i]; return cnt[0] &gt;= 2 * x; } int main() { scanf(\"%d%d\", &amp;n, &amp;x); for(int i = 1; i &lt; n; i++) scanf(\"%d\", &amp;h[i]); int l = 1, r = n; while(l != r) { int mid = l + r &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; } printf(\"%d\\n\", l); return 0; } 后记2022年4月9日 20:55 写这篇题解的时候发现F题忘记初始化肯定寄了，我瞬间裂开，所以后面的题就以后再说吧","categories":[{"name":"竞赛","slug":"竞赛","permalink":"https://toby-shi-cloud.github.io/categories/%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"算法","slug":"算法","permalink":"https://toby-shi-cloud.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://toby-shi-cloud.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"author":"TobyShi"}],"categories":[{"name":"Swift编程","slug":"Swift编程","permalink":"https://toby-shi-cloud.github.io/categories/Swift%E7%BC%96%E7%A8%8B/"},{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/categories/%E8%84%9A%E6%9C%AC/"},{"name":"计算机组成","slug":"计算机组成","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"},{"name":"面向对象","slug":"面向对象","permalink":"https://toby-shi-cloud.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"密码学","slug":"密码学","permalink":"https://toby-shi-cloud.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"竞赛","slug":"竞赛","permalink":"https://toby-shi-cloud.github.io/categories/%E7%AB%9E%E8%B5%9B/"},{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/categories/Python/"},{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://toby-shi-cloud.github.io/tags/Swift/"},{"name":"Apple","slug":"Apple","permalink":"https://toby-shi-cloud.github.io/tags/Apple/"},{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/tags/Python/"},{"name":"CO","slug":"CO","permalink":"https://toby-shi-cloud.github.io/tags/CO/"},{"name":"OO","slug":"OO","permalink":"https://toby-shi-cloud.github.io/tags/OO/"},{"name":"Java","slug":"Java","permalink":"https://toby-shi-cloud.github.io/tags/Java/"},{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"密码分析","slug":"密码分析","permalink":"https://toby-shi-cloud.github.io/tags/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"VScode","slug":"VScode","permalink":"https://toby-shi-cloud.github.io/tags/VScode/"},{"name":"wsl","slug":"wsl","permalink":"https://toby-shi-cloud.github.io/tags/wsl/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://toby-shi-cloud.github.io/tags/Codeforces/"},{"name":"算法","slug":"算法","permalink":"https://toby-shi-cloud.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://toby-shi-cloud.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"网络","slug":"网络","permalink":"https://toby-shi-cloud.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"server-client","slug":"server-client","permalink":"https://toby-shi-cloud.github.io/tags/server-client/"},{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]}