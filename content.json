{"meta":{"title":"TobyShiの博客","subtitle":"TobyShiの博客","description":null,"author":"TobyShi","url":"https://toby-shi-cloud.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-14T07:18:32.014Z","comments":true,"path":"404.html","permalink":"https://toby-shi-cloud.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-06-14T07:18:32.138Z","updated":"2022-06-14T07:18:32.138Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://toby-shi-cloud.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2022-06-14T07:18:32.141Z","updated":"2022-06-14T07:18:32.141Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://toby-shi-cloud.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-14T07:18:32.028Z","comments":true,"path":"List/index.html","permalink":"https://toby-shi-cloud.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-14T07:18:32.136Z","comments":true,"path":"about/index.html","permalink":"https://toby-shi-cloud.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-14T07:18:32.137Z","comments":true,"path":"archives/index.html","permalink":"https://toby-shi-cloud.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-14T07:18:32.138Z","comments":true,"path":"categories/index.html","permalink":"https://toby-shi-cloud.github.io/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-06-14T07:18:32.139Z","comments":true,"path":"census/index.html","permalink":"https://toby-shi-cloud.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-06-14T10:00:00.000Z","updated":"2022-06-14T10:16:31.019Z","comments":true,"path":"contact/index.html","permalink":"https://toby-shi-cloud.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，一起交流学习！ 特别感谢 特别感谢本博客模板制作者：Luckey Luckeyの博客名称: Luckeyの博客 Luckeyの博客网址: http://www.luckyzmj.cn Luckeyの博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png Luckeyの博客介绍: The harder you work, the luckier you will be"},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-06-14T07:18:32.140Z","comments":true,"path":"friends/index.html","permalink":"https://toby-shi-cloud.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-14T07:18:32.141Z","comments":true,"path":"resource/index.html","permalink":"https://toby-shi-cloud.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-14T07:18:32.144Z","comments":true,"path":"tags/index.html","permalink":"https://toby-shi-cloud.github.io/tags/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-14T07:18:32.028Z","comments":true,"path":"List/movies/index.html","permalink":"https://toby-shi-cloud.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-14T07:18:32.029Z","comments":true,"path":"List/music/index.html","permalink":"https://toby-shi-cloud.github.io/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-06-14T07:18:32.020Z","updated":"2022-06-14T07:18:32.020Z","comments":true,"path":"List/galleries/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-14T07:18:32.029Z","comments":true,"path":"List/tools/index.html","permalink":"https://toby-shi-cloud.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-06-14T07:18:32.022Z","updated":"2022-06-14T07:18:32.022Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-06-14T07:18:32.022Z","updated":"2022-06-14T07:18:32.022Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-06-14T07:18:32.021Z","updated":"2022-06-14T07:18:32.021Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-06-14T07:18:32.023Z","updated":"2022-06-14T07:18:32.023Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-06-14T07:18:32.024Z","updated":"2022-06-14T07:18:32.024Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-06-14T07:18:32.025Z","updated":"2022-06-14T07:18:32.025Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-06-14T07:18:32.024Z","updated":"2022-06-14T07:18:32.024Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-06-14T07:18:32.025Z","updated":"2022-06-14T07:18:32.025Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-06-14T07:18:32.026Z","updated":"2022-06-14T07:18:32.026Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-06-14T07:18:32.027Z","updated":"2022-06-14T07:18:32.027Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-06-14T07:18:32.026Z","updated":"2022-06-14T07:18:32.026Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-06-14T07:18:32.027Z","updated":"2022-06-14T07:18:32.027Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"蓝桥杯2022决赛参赛记录","slug":"LanQiaoCup2022Final","date":"2022-06-18T13:50:00.000Z","updated":"2022-06-18T16:29:46.285Z","comments":true,"path":"posts/lanqiaocup2022final.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/lanqiaocup2022final.html","excerpt":"","text":"A 题：小蓝与钥匙问题描述 小蓝是幼儿园的老师，他的班上有 28 个孩子，今天他和孩子们一起进行了一个游戏。 小蓝所在的学校是寄宿制学校，28 个孩子分别有一个自己的房间，每个房间对应一把钥匙，每把钥匙只能打开自己的门。现在小蓝让这 28 个孩子分别将自己宿舍的钥匙上交，再把这 28 把钥匙随机打乱分给每个孩子一把钥匙，有$28! = 28\\times27\\times \\cdots \\times1 $种分配方案。小蓝想知道这些方案中，有多少种方案恰有一半的孩子被分到自己房间的钥匙（即有 14 个孩子分到的是自己房间的钥匙，有 14 个孩子分到的不是自己房间的钥匙）。 答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 考场思路显然这个题分为两步，一是有14个同学分到了自己的钥匙，二是剩下的14个同学都没有分到自己的钥匙，记方案数为$Q$，则有：$$Q = C_{28}^{14} \\cdot D_{14}$$其中$D_{14}$为14的全错位排列。全错位排列也称“欧拉装错信箱问题”，其计算可用容斥原理，公式如下：$$D_n = \\sum_{i=0}^{n} (-1)^i \\cdot C_n^i \\cdot (n-i)!$$或者：$$D_n = n! \\cdot \\sum_{i=0}^{n} \\frac{(-1)^i}{i!}$$于是有方案数$Q=1,286,583,532,342,313,400$ B 题：排列距离问题描述 小蓝最近迷上了全排列，现在他有一个长度为 17 的排列，里面包含的元素有：abcdefghijklnopqr，即 a 至 r 中除了 m 以外的所有小写字母，这 17个字母在任何一个排列中都恰好出现一次。前面几个排列依次是： 第 1 个排列为：abcdefghijklnopqr； 第 2 个排列为：abcdefghijklnoprq； 第 3 个排列为：abcdefghijklnoqpr； 第 4 个排列为：abcdefghijklnoqrp； 第 5 个排列为：abcdefghijklnorpq； 第 6 个排列为：abcdefghijklnorqp； 第 7 个排列为：abcdefghijklnpoqr； 第 8 个排列为：abcdefghijklnporq； 第 9 个排列为：abcdefghijklnpqor； 第 10 个排列为：abcdefghijklnpqro。 对于一个排列，有两种转移操作：1）转移到其下一个排列。如果当前排列已经是最后一个排列，那么下一个排列就是第一个排列。2）转移到其上一个排列。如果当前排列是第一个排列，那么上一个排列就是最后一个排列。小蓝现在有两个排列，分别为排列 A：aejcldbhpiogfqnkr，以及排列B：ncfjboqiealhkrpgd，他现在想知道，在只有上述两种转移操作的前提下，排列 A 最少转移多少次能得到排列 B。 答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 考场思路显然只要知道了排列A和排列B分别是第几个排列就可以了。 因此我们使用康托展开（Cantor expansion）就可以了。若记排列$\\lambda$为$a_1,a_2,a_3,\\dots,a_n$，则有：$$X_{\\lambda} = q_1 \\cdot (n-1)! + q_2 \\cdot (n-2)! + \\cdots + q_n \\cdot 0!$$其中$q_i$表示$a_i$在$a_i,a_{i+1},\\dots,a_n$中是第$q_i$小的数，则$X_\\lambda$表示排列$\\lambda$是第$X_\\lambda$个排列。（注：这里第几小的数和第几个排列都从0开始标号，计算会比较方便） 最后我的结果是：排列A的编号是$4,542,892,071,974$，排列B的编号是$254,081,962,595,831$，最终答案取$min{X_A - X_B + 19!, X_B - X_A} = 106,148,357,572,143$即可。 C 题：内存空间问题描述 小蓝最近总喜欢计算自己的代码中定义的变量占用了多少内存空间。 为了简化问题，变量的类型只有以下三种：int：整型变量，一个 int 型变量占用 4 Byte 的内存空间。long：长整型变量，一个 long 型变量占用 8 Byte 的内存空间。String：字符串变量，占用空间和字符串长度有关，设字符串长度为 L，则字符串占用 L Byte 的内存空间，如果字符串长度为 0 则占用 0 Byte 的内存空间。 定义变量的语句只有两种形式，第一种形式为：type var1=value1,var2=value2...;定义了若干个 type 类型变量 var1、var2、…，并且用 value1、value2…初始化，多个变量之间用’,’ 分隔，语句以’;’ 结尾，type 可能是 int、long 或 String。例如 int a=1,b=5,c=6; 占用空间为 12 Byte；long a=1,b=5; 占用空间为 16 Byte；String s1=””,s2=”hello”,s3=”world”; 占用空间为 10 Byte。 第二种形式为：type[] arr1=new type[size1],arr2=new type[size2]...;定义了若干 type 类型的一维数组变量 arr1、arr2…，且数组的大小为size1、size2…，多个变量之间用’,’ 进行分隔，语句以’;’ 结尾，type 只可能是 int 或 long。例如 int[] a1=new int[10]; 占用的内存空间为 40Byte；long[] a1=new long[10],a2=new long[10]; 占用的内存空间为160 Byte。 已知小蓝有 T 条定义变量的语句，请你帮他统计下一共占用了多少内存空间。结果的表示方式为：aGBbMBcKBdB，其中 a、b、c、d 为统计的结果，GB、MB、KB、B 为单位。优先用大的单位来表示，1GB=1024MB，1MB=1024KB，1KB=1024B，其中 B 表示 Byte。如果 a、b、c、d 中的某几个数字为 0，那么不必输出这几个数字及其单位。题目保证一行中只有一句定义变量的语句，且每条语句都满足题干中描述的定义格式，所有的变量名都是合法的且均不重复。题目中的数据很规整，和上述给出的例子类似，除了类型后面有一个空格，以及定义数组时 new 后面的一个空格之外，不会出现多余的空格。 输入格式 输入的第一行包含一个整数 T ，表示有 T 句变量定义的语句。接下来 T 行，每行包含一句变量定义语句。 输出格式 输出一行包含一个字符串，表示所有语句所占用空间的总大小。 测试样例 样例输入 样例输出 1long[] nums=new long[131072]; 1MB 4int a=0,b=0;long x=0,y=0;String s1=”hello”,s2=”world”;long[] arr1=new long[100000],arr2=new long[100000]; 1MB538KB546B 样例说明 样例 1，占用的空间为 131072 × 8 = 1048576 B，换算过后正好是 1MB，其它三个单位 GB、KB、B 前面的数字都为 0 ，所以不用输出。 样例 2，占用的空间为 4 × 2 + 8 × 2 + 10 + 8 × 100000 × 2 B，换算后是1MB538KB546B。 规模与约定 对于所有评测用例，1 ≤ T ≤ 10，每条变量定义语句的长度不会超过 1000。所有的变量名称长度不会超过 10，且都由小写字母和数字组成。对于整型变量，初始化的值均是在其表示范围内的十进制整数，初始化的值不会是变量。对于 String 类型的变量，初始化的内容长度不会超过 50，且内容仅包含小写字母和数字，初始化的值不会是变量。对于数组类型变量，数组的长度为一个整数，范围为：$[0, 2^{30}]$，数组的长度不会是变量。T 条语句定义的变量所占的内存空间总大小不会超过 1 GB，且大于 0 B。 考场思路这个题，怎么说呢，几乎就是纯模拟吧大概。 首先每行的首个字符串就是类型说明，然后对于不同的类型找不同的符号就可以了。 比如int和long型，就找有多少个“,”；数组就找“int[”和“long[”；字符串就找“””就可以了。 部分代码如下： void solve_int(const char* str) { while(*str) { if(*str == ',' || *str == ';') ans += 4; str++; } } void solve_int_arr(const char* str) { const char* tmp; // const char* lst = str + strlen(str); while((tmp = strstr(str, \"int[\")) != NULL) { tmp += 4; int num = 0; while(isdigit(*tmp)) { num = num * 10 + (*tmp - '0'); tmp++; } str = tmp; ans += 4 * num; } } void solve_long(const char* str) { while(*str) { if(*str == ',' || *str == ';') ans += 8; str++; } } void solve_long_arr(const char* str) { const char* tmp; // const char* lst = str + strlen(str); while((tmp = strstr(str, \"long[\")) != NULL) { tmp += 5; int num = 0; while(isdigit(*tmp)) { num = num * 10 + (*tmp - '0'); tmp++; } str = tmp; ans += 8 * num; } } void solve_String(const char* str) { const char* tmp; // const char* lst = str + strlen(str); while((tmp = strchr(str, '\\\"')) != NULL) { // fprintf(\"tmp=%s\\n\",tmp); tmp += 1; int num = 0; while(*tmp != '\\\"') { num++; tmp++; } str = tmp + 1; ans += num; } } D 题：最大公约数问题描述 给定一个数组，每次操作可以选择数组中任意两个相邻的元素 x, y 并将其中的一个元素替换为 gcd(x, y) ，其中 gcd(x, y) 表示 x 和 y 的最大公约数。 请问最少需要多少次操作才能让整个数组只含 1 。 输入格式 输入的第一行包含一个整数 n ，表示数组长度。 第二行包含 n 个整数 a1, a2, · · · , an，相邻两个整数之间用一个空格分隔。 输出格式 输出一行包含一个整数，表示最少操作次数。如果无论怎么操作都无法满足要求，输出 −1。 测试样例 样例输入 样例输出 34 6 9 4 规模与约定 对于 30% 的评测用例，$n ≤ 500 ，a_i ≤ 1000$；对于 50% 的评测用例，$n ≤ 5000 ，a_i ≤ 10^6$；对于所有评测用例，$1 ≤ n ≤ 100000 ，1 ≤ a_i ≤ 10^9$。 考场思路可以发现，如果数列中有一个数为1，那么问题就很好解决了：答案即为非1的个数。 因此本题的关键在于如何最快的弄出一个1。 由于题目只允许相邻的两个数取gcd，所以如果找到连续k个数gcd为1的话，就可以用k-1次操作把其中一个数换为1，因此答案为：n+k-2。（当然，如果这n个数的gcd为非1，就直接输出-1即可） 于是问题化为如何找到这个最小的k。 稍微暴力的做法是，首先求两个两个的gcd，然后求三个三个的gcd（可以发现，三个数的gcd就是相邻两个gcd的gcd），依次下去，每次gcd的数目减小1，于是时间复杂度是$O(\\sum_{i=1}^n i)$即$O(n^2)$（由于$a_i$并不大，所以gcd的复杂度（不超过$O(5 \\lg n)$，大约就是10倍左右）就忽略了）实现大致如下： void focus_solve() { int ans = n - 1; while(!flag) { n--; ans++; for(int i = 0; i &lt; n; i++) { num[i] = gcd(num[i], num[i+1]); if(num[i] == 1) {flag = true;break;} } } printf(\"%d\\n\", ans); } 至于100%的数据，我使用了倍增+二分，复杂度大概是$O(40nlogn)$（倍数是gcd的复杂度），复杂度上肯定是没有问题的。大致的想法就是先预处理出从数量任意一个数起，2的整次幂个数的gcd，这里复杂度就是$O(20nlogn)$。然后对上面说的k进行二分（k最大取n），每次check遍历起点，然后用预处理的数据计算出k个数的gcd，也是$O(20nlogn)$。代码大致如下： bool check(int x) { int logval = upper_bound(pow2, pow2 + 18, x) - pow2 - 1; // logval = log2(x)向下取整 for(int i = 0; i &lt; n - x + 1; i++) { int l = i, r = i + x; int _g = gcd(_gcd_2[l][logval], _gcd_2[r-pow2[logval]][logval]); // _gcd_2就是预处理数组 if(_g == 1) return true; } return false; } void solve() { int max_log = upper_bound(pow2, pow2 + 18, n) - pow2; for(int p = 0; p &lt; max_log; p++) for(int i = 0; i &lt; n; i++) { if(p == 0) _gcd_2[i][0] = num[i]; else if (i+pow2[p-1] &gt;= n) _gcd_2[i][p] = _gcd_2[i][p-1]; else _gcd_2[i][p] = gcd(_gcd_2[i][p-1], _gcd_2[i+pow2[p-1]][p-1]); } int L = 1, R = n; while(L != R) { int mid = L + R &gt;&gt; 1; if(check(mid)) R = mid; else L = mid + 1; } printf(\"%d\\n\", n + L - 2); } 未完待续……","categories":[{"name":"竞赛","slug":"竞赛","permalink":"https://toby-shi-cloud.github.io/categories/%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://toby-shi-cloud.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"算法","slug":"算法","permalink":"https://toby-shi-cloud.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"TobyShi"},{"title":"【Python】使用socket库实现server-client通讯的联机对战游戏（一）","slug":"Socket","date":"2022-06-16T13:30:00.000Z","updated":"2022-06-16T14:59:48.192Z","comments":true,"path":"posts/pythonsocket.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/pythonsocket.html","excerpt":"","text":"socket单对单通讯socket是Python内建库之一，用途就是网络通讯。作为实验，我们考虑两个Python程序之间的通讯，一个作为服务器，一个作为客户端，客户端向服务器发送一串字符，服务器收到后将原字符串大写后传回，直到客户端发送空信息，服务器退出。 服务器端代码： import socket ip_port = ('', 8888) # 这个tuple的第一项是ip地址，第二项是端口 s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 定义socket类型，网络通信，TCP s.bind(ip_port) # 套接字绑定ip和端口 s.listen(1) # 开始监听连接请求 conn, addr = s.accept() # 接受连接请求，conn是一个新的套接字，addr是客户端地址 conn.sendall('Hello from the server!'.encode('utf-8')) # 发送打招呼信息，并且用utf-8编码 while True: try: data = conn.recv(1024).decode('utf-8') # 接受数据并使用utf-8解码 if not data: break # 如果数据为空就退出 conn.sendall(data.upper().encode('utf-8')) # 把数据大写后返回 except Exception as e: # 如果数据传输出错 print(e) exit(1) conn.close() # 关闭套接字 客户端代码： import socket ip_port = ('localhost', 8888) # 服务器ip和端口 s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 定义socket类型，网络通信，TCP try: s.connect(ip_port) # 尝试连接服务器 except Exception as e: # 如果连接失败socket.socket.connect会抛出错误 print(e) exit(1) data = s.recv(1024).decode('utf-8') # 接受服务器的问候 print(data) while True: try: msg = input('&gt;&gt;&gt; ') # 此时用户可以在运行客户端的控制台中输入内容 s.sendall(msg.encode('utf-8')) # 将消息发送 if not msg: break # 如果数据为空就退出 data = s.recv(1024).decode('utf-8') # 接受服务器的结果 print(data) except Exception as e: # 如果数据传输出错 print(e) exit(1) s.close() # 关闭套接字 运行结果： socketserver多对一通讯由于我的目的是打算写一个联机对战游戏，那么一个服务器需要同时和多个（至少是两个）客户端建立连接。一个很容易想到的做法就是服务器多线程。好在Python已经帮我们封装好了多线程和socket库——socketserver库。 socketserver库的用法和socket几乎一模一样，而且由于只有服务器端需要多线程，所以只需要更改server.py即可。 下面是server.py的代码： import socketserver ip_port = ('', 10888) class MyServer(socketserver.BaseRequestHandler): def handle(self): # 重写RequestHandler中的handle方法用来处理请求 print(\"conn is :\", self.request) # conn print(\"addr is :\", self.client_address) # addr self.request.sendall('Hello from the server!'.encode('utf-8')) while True: # 处理方面的逻辑都是一样的 try: data = self.request.recv(1024).decode('utf-8') if not data: break self.request.sendall(data.upper().encode('utf-8')) except Exception as e: print(e) break print(\"disconnected with\", self.client_address) if __name__ == '__main__': s = socketserver.ThreadingTCPServer(ip_port, MyServer) # 建立TCP协议套接字 # 使用s.serve_forever()接受无穷次连接（需要按下Ctrl+C中断） # 也可以使用一次s.handle_request()接受一次连接 s.serve_forever() 运行结果： 服务器内部数据传输现在我们已经解决了服务器和客户端之间的数据传输问题了，但是这又引入了新的问题：服务器用多线程和客户端交流，但是socketserver封装的太好了，想要直接从外部操作各个线程显然不显示，那么如何进行服务器各个线程之间的交流呢？ 请听下回分解…… 😀","categories":[{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/tags/Python/"},{"name":"网络","slug":"网络","permalink":"https://toby-shi-cloud.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"server-client","slug":"server-client","permalink":"https://toby-shi-cloud.github.io/tags/server-client/"}],"author":"TobyShi"},{"title":"你好博客！Hello Blog!","slug":"HelloBlog","date":"2022-06-14T11:30:00.000Z","updated":"2022-06-14T12:29:45.505Z","comments":true,"path":"posts/helloblog.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/helloblog.html","excerpt":"","text":"01 从零开始搭建属于自己的博客具体操作见此博客 不过由于我之前弄过一半，所以这一步的操作就省了，因此这里就不记录了。 02 选择合适的好看的Theme经过许多次试错，最终看到了Luckey大佬的视频，十分羡慕，于是clone了他的博客. 03 博客个性化如果说前面的内容都是跟着教程动动手指就可以完成，那么这一步将会是最大的噩梦。 其中最大的问题就是：我压根没有学过前端，大佬的博客的复杂程度对于我来说简直难以想象。因此这里要特别感谢Luckey大佬的教程以及Matery主题的使用手册，中文文档真的对我这种英语白痴非常友好！ 然后我就开始看着各式各样的文档一通乱改，为了降低改动难度，我就把用不到的功能的入口删掉了，但是如果你手动输入争取的url的话其实依然可以看到Luckey大佬的很多让我大为震撼的功能，想看的朋友可以去他的博客欣赏欣赏。 我做的比较到大的改动就是升级了这个Theme使用的fontawesome的版本，不过其实只需要在官网下载一个zip然后把里面的东西全部覆盖到~\\themes\\matery\\source\\libs\\awesome就可以了。（这样做是因为只有新版才支持B站的图标，不过Gitee的图标仍然木有） 最后比较遗憾的是，不知道为什么我在“视频”栏中嵌入视频失败了，不知道是不是B站嵌入视频已经失效了。 04 Markdown公式测试$$ S_n = \\sum_{i=1}^{n} a_i $$$$ \\int \\cos(x) dx = \\sin(x) $$ 这是行内公式：$\\lim_{x\\rightarrow 0} \\frac{x}{\\sin x} = 1$ 经过测试，公式内换行不知道为什么没有得到支持。 05 在忙了一下午之后总之到晚上的时候我就已经开始写这篇HelloBlog了，还是很兴奋的，毕竟从未有过写前端的经历，然后几乎是从零开始学习搭建，所以真的非常感谢大佬们的帮助。因此如果有朝一日，我也有能力以后，也一定会向把知识分享出来，供大家学习和参考。 无限进步！","categories":[{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"TobyShi"}],"categories":[{"name":"竞赛","slug":"竞赛","permalink":"https://toby-shi-cloud.github.io/categories/%E7%AB%9E%E8%B5%9B/"},{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/categories/Python/"},{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://toby-shi-cloud.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"算法","slug":"算法","permalink":"https://toby-shi-cloud.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/tags/Python/"},{"name":"网络","slug":"网络","permalink":"https://toby-shi-cloud.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"server-client","slug":"server-client","permalink":"https://toby-shi-cloud.github.io/tags/server-client/"},{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]}