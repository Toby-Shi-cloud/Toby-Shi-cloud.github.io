{"meta":{"title":"TobyShiの博客","subtitle":"TobyShiの博客","description":null,"author":"TobyShi","url":"https://toby-shi-cloud.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-14T07:18:32.014Z","comments":true,"path":"404.html","permalink":"https://toby-shi-cloud.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-06-14T07:18:32.138Z","updated":"2022-06-14T07:18:32.138Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://toby-shi-cloud.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2022-06-14T07:18:32.141Z","updated":"2022-06-14T07:18:32.141Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://toby-shi-cloud.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-14T07:18:32.028Z","comments":true,"path":"List/index.html","permalink":"https://toby-shi-cloud.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-14T07:18:32.136Z","comments":true,"path":"about/index.html","permalink":"https://toby-shi-cloud.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-14T07:18:32.138Z","comments":true,"path":"categories/index.html","permalink":"https://toby-shi-cloud.github.io/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-06-14T07:18:32.139Z","comments":true,"path":"census/index.html","permalink":"https://toby-shi-cloud.github.io/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-06-14T07:18:32.140Z","comments":true,"path":"friends/index.html","permalink":"https://toby-shi-cloud.github.io/friends/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-06-14T07:18:32.137Z","comments":true,"path":"archives/index.html","permalink":"https://toby-shi-cloud.github.io/archives/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-14T07:18:32.141Z","comments":true,"path":"resource/index.html","permalink":"https://toby-shi-cloud.github.io/resource/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-06-14T10:00:00.000Z","updated":"2022-06-14T10:16:31.019Z","comments":true,"path":"contact/index.html","permalink":"https://toby-shi-cloud.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，一起交流学习！ 特别感谢 特别感谢本博客模板制作者：Luckey Luckeyの博客名称: Luckeyの博客 Luckeyの博客网址: http://www.luckyzmj.cn Luckeyの博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png Luckeyの博客介绍: The harder you work, the luckier you will be"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-14T07:18:32.144Z","comments":true,"path":"tags/index.html","permalink":"https://toby-shi-cloud.github.io/tags/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-14T07:18:32.029Z","comments":true,"path":"List/music/index.html","permalink":"https://toby-shi-cloud.github.io/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-06-14T07:18:32.029Z","comments":true,"path":"List/tools/index.html","permalink":"https://toby-shi-cloud.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-06-14T07:18:32.028Z","comments":true,"path":"List/movies/index.html","permalink":"https://toby-shi-cloud.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-06-14T07:18:32.020Z","updated":"2022-06-14T07:18:32.020Z","comments":true,"path":"List/galleries/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-06-14T07:18:32.022Z","updated":"2022-06-14T07:18:32.022Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-06-14T07:18:32.021Z","updated":"2022-06-14T07:18:32.021Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-06-14T07:18:32.022Z","updated":"2022-06-14T07:18:32.022Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-06-14T07:18:32.024Z","updated":"2022-06-14T07:18:32.024Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-06-14T07:18:32.024Z","updated":"2022-06-14T07:18:32.024Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-06-14T07:18:32.025Z","updated":"2022-06-14T07:18:32.025Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-06-14T07:18:32.023Z","updated":"2022-06-14T07:18:32.023Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-06-14T07:18:32.025Z","updated":"2022-06-14T07:18:32.025Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-06-14T07:18:32.027Z","updated":"2022-06-14T07:18:32.027Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-06-14T07:18:32.027Z","updated":"2022-06-14T07:18:32.027Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-06-14T07:18:32.026Z","updated":"2022-06-14T07:18:32.026Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-06-14T07:18:32.026Z","updated":"2022-06-14T07:18:32.026Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://toby-shi-cloud.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""}],"posts":[{"title":"使用VScode进行Verilog仿真和波形查看","slug":"VerilogWithVScode","date":"2022-09-07T07:00:00.000Z","updated":"2022-09-07T07:42:01.761Z","comments":true,"path":"posts/verilogwithvscode.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/verilogwithvscode.html","excerpt":"","text":"前言计组课程官方推荐的Verilog仿真工具是ISE和VCS，评测机使用ISE。 但是在尝试在win11的wslg上安装ISE后，虽然成功了，但是难用的一批，而且还有bug，仿真总是失败等问题。而课程虚拟机里面的VCS按照课程组提供的方法，又无法生成波形文件，查阅资料后也一筹莫展，弄的我一头雾水。于是开始寻求其他工具。 在经过不同关键词检索以后，终于看到了本校学长的知乎专栏，推荐了一个VScode上进行Verilog仿真的方法！安装不仅非常简单，而且使用也很简单，爆杀20G的ISE和安装繁琐的VCS！而且是一个开源的，跨平台的软件，简直就是神一般的存在！ 下面的教程参考了学长的专栏 安装VScode不会吧不会吧，不会有人看这篇文章却没有安装VScode吧。 安装iVerilogiVerilog全称Icarus Verilog，官方下载方式在这里 安装的时候，基本上都可以随意，直接Next都行，不过记得添加PATH。就是一定要勾选“Add executable folders to the user PATH” 安装VScode插件你需要安装以下几个插件： Verilog-HDL/SystemVerilog/Bluespec SystemVerilog Verilog HDL Verilog Snippet WaveTrace 前三个插件，提供代码高亮，代码补全，一键运行等功能。 第四个插件，提供波形查看。（下载iVerilog的时候应该有下载GTKWave，你也可以用这个软件查看波形） 插件设置仅需要设置Verilog-HDL/SystemVerilog/Bluespec SystemVerilog插件 找到插件设置中的Verilog &gt; Linting: Linter 在下拉菜单中选中iverilog即可 使用写一端.v代码，然后写对应的testbench，然后在testbench里面，点击右上角的绿色的按钮，即可运行。 若想要生成波形文件，请在testbench中加上以下代码： initial begin $dumpfile(\"*.vcd\"); // * 是你希望产生的波形文件的名字 $dumpvars; end 注意：你必须在testbench的test运行结束之后，使用$finish;结束代码，否则波形文件不会结束，需要手动前往任务管理器，结束vvp.exe进程。 最后点开*.vcd文件就可以查看波形了（如果你下载了WaveTrace插件的话） testbench怎么写我就不教了吧，下面给一个测试代码吧。 示例代码// adder.v `timescale 1ns/1ps module adder ( input clk, input [31:0] in1, input [31:0] in2, output reg [31:0] out ); always @(posedge clk) begin out &lt;= in1 + in2; end endmodule // adder_tb.v `timescale 1ns/1ps `include \"adder.v\" module adder_tb; // Dump waveform to file (it would be impossible to view wavefrom without // this task) initial begin $dumpfile(\"adder_wave.vcd\"); $dumpvars(); end // Generate clock reg clk; initial clk = 0; always #10 clk = ~clk; // Input registers reg [31:0] a, b; wire [31:0] c; initial begin a = 0; b = 0; @(negedge clk); a = 32'h631; b = 341; @(negedge clk); $display(\"%d + %d = %d\\n\", a, b, c); a = 32'o1461; b = 0; @(negedge clk); $display(\"%d + %d = %d\\n\", a, b, c); #20; // Exit the simulation $finish; end // Device under test (our adder) adder dut(.clk(clk), .in1(a), .in2(b), .out(c)); endmodule 参考资料 https://zhuanlan.zhihu.com/p/414308549","categories":[{"name":"计组","slug":"计组","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%BB%84/"}],"tags":[{"name":"CO","slug":"CO","permalink":"https://toby-shi-cloud.github.io/tags/CO/"},{"name":"VScode","slug":"VScode","permalink":"https://toby-shi-cloud.github.io/tags/VScode/"}],"author":"TobyShi"},{"title":"使用Xcode编译Swift App并分发到iPhone或iPad上","slug":"swift_xcode_ipa","date":"2022-08-30T06:00:00.000Z","updated":"2022-08-30T07:16:42.043Z","comments":true,"path":"posts/swift-xcode-ipa.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/swift-xcode-ipa.html","excerpt":"","text":"前言这学期成功选上了Swift程序设计这门课。虽然我还只会写Hello World，但是已经非常好奇如何将自己写的程序放在自己的iPhone中运行了，因此我们今天就来尝试一次。 代码Mac上的Xcode和iPad上的Playground差距还是有些大的。但是因为我的Mac是虚拟机，运行缓慢，所以我打算现在iPad上编写程序并测试运行。 由于我对Swift的了解还很少，所以我在网上下载了一个简单的程序作为测试。测试软件下载链接[1] 下载好后，在iPad的Playground中尝试导入，几乎都失败了。遂怀疑是版本问题。于是准备重新创建项目后复制粘贴源代码。粘贴好后会提示SwiftyJSON和Alamofire找不到，遂前往GitHub搜索，并在Playground的添加Swift软件包中粘贴链接导入软件包即可。省流：链接分别是https://github.com/SwiftyJSON/SwiftyJSON和https://github.com/Alamofire/Alamofire 点击运行，就能看到软件运行成功了。 分发由于iPad的Playground只能将应用发布到App Store，而这个需要用户成为Apple Developer Member，不仅需要验证和审核，还需要688元/年的会费，对学生来说没有必要，邃转向Xcode。 首先在Playground中将刚刚抄的App导出并存放在iCloud中（存什么地方不重要，方便导入电脑即可，也可以直接AirDrop）。随后打开Mac上的Xcode，打开项目，选择我们刚刚的导出的软件。项目导入后，Xcode会提示正在fetch SwiftyJSON和Alamofire，fetch结束后就可以command+R运行了。可见App在Simulator中运行状态也是正常的。 之后点击Xcode-Preferences或者使用快捷键command+,打开偏好设置，在Accounts中添加自己的AppleID，添加成功后关闭偏好设置。 在左侧视图中点击App的名称，选中signing &amp; Capabilities，在Signing栏的Development Team中选中自己AppleID的名字，在Bundle Identifier中填入应用唯一标识符，命名规范一般是com.AppName.DeveloperName 随后鼠标悬停在中间正上方，会出现为什么构建应用程序，选中Any iOS Device，然后点击菜单栏Product-Archive，编译成功后在Finder中打开文件夹，文件夹位置默认在~/Library/Developer/Xcode/Archives下的今天日期文件夹中（可在偏好设置的Location栏更改）。此可以看见一个扩展名为xcarchive的文件即说明编译成功。 最后，打开终端，cd到.xcarchive文件所在文件夹，输入以下命令：[2] xcodebuild -exportArchive -exportOptionsPlist Info.plist -archivePath *.xcarchive -exportPath myApp.ipa 其中Info.plist需要随便准备一个（如果你是直接在Xcode中创建的项目会附赠一个，你在项目文件中找到即可，如果是Playground创建的，则需要借用其他项目的），*.xcarchive为你的应用名称。在看到** EXPORT SUCCEEDED **后说明导出ipa成功。 会在当前文件夹下产生一个叫做myApp.ipa的文件夹，将其中的myApp.ipa文件拿出来，使用爱思助手就可以直接安装在iPad/iPhone中使用。[3] 注意：根据Apple官方的规定，免费用户只能将同一个程序分发给至多3个设备，且一次签名最多持续7天。 参考链接或注释 参考链接：https://sspai.com/post/70655 参考链接：https://www.jianshu.com/p/0171d6b49771 注释：由于Info.plist不匹配和免费签名的缘故，不能使用iTunes进行安装，只能使用第三方助手","categories":[{"name":"Swift编程","slug":"Swift编程","permalink":"https://toby-shi-cloud.github.io/categories/Swift%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://toby-shi-cloud.github.io/tags/Swift/"},{"name":"Apple","slug":"Apple","permalink":"https://toby-shi-cloud.github.io/tags/Apple/"}],"author":"Toby Shi"},{"title":"在WSL上安装ISE","slug":"installISEonWSL","date":"2022-08-07T18:00:00.000Z","updated":"2022-08-07T19:08:57.235Z","comments":true,"path":"posts/install-ise-on-wsl.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/install-ise-on-wsl.html","excerpt":"","text":"前言因为我们计组要使用到ISE，但是ISE和win11不相容，所以我就打算在wslg上安装ISE了。 安装过程 在官网下载Xilinx_ISE_DS_Lin_14.7_1015_1.tar:https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/vivado-design-tools/archive-ise.html 将压缩包解压（我是直接在Nautilus中双击解压的） cd到解压后的文件夹里面，通过ls可以看到如下内容 $ ls bin data idata labtools msg planahead_wp webpack xsetup common edk ise lib planahead sysgen xinfo 如果xsetup是可运行的，则直接sudo ./xsetup，否则先sudo chmod +x xsetup 如果安装报错： error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file 即缺少libncurses.so.5库文件，可以通过以下指令解决 $ sudo apt install apt-file $ sudo apt-file update $ sudo apt-file find libncurses.so.5 $ sudo apt install libncurses5 安装界面是图形界面，按照指引操作即可。全默认就行了，目录就在/opt/，Install cable drivers也不用安装 打开终端输入以下指令 $ cd /opt/Xilinx/14.7/ISE_DS $ ls EDK ISE PlanAhead SysGen Xilinx.lic common settings32.csh settings32.sh settings64.csh settings64.sh $ source settings64.sh . /opt/Xilinx/14.7/ISE_DS/common/.settings64.sh /opt/Xilinx/14.7/ISE_DS/common . /opt/Xilinx/14.7/ISE_DS/EDK/.settings64.sh /opt/Xilinx/14.7/ISE_DS/EDK . /opt/Xilinx/14.7/ISE_DS/PlanAhead/.settings64.sh /opt/Xilinx/14.7/ISE_DS/PlanAhead . /opt/Xilinx/14.7/ISE_DS/ISE/.settings64.sh /opt/Xilinx/14.7/ISE_DS/ISE $ ise 这里如果你的Ubuntu是32位的，请选择settings32.sh 至此ISE首次运行成功！ 打开后会提示没有License，那么我们直接需要在官网先申请到一个免费的License，然后在Help -&gt; Manage Licenses里面Load官网通过邮件发给你的Xilinx.lic即可 最后界面如下图： 运行注意到每次重启wsl后都必须重新输入第6步的指令非常麻烦，所以已有大佬写了脚本一键运行： 在任何地方新建文件，我选择的是/opt/Xilinx/14.7/ISE_DS/quickstart，内容如下： #!/bin/bash export LD_PRELOAD=/opt/Xilinx/usb-driver/libusb-driver.so ISE_DS_DIR=/opt/Xilinx/14.7/ISE_DS unset LD_PRELOAD export gmake=/usr/bin/make cd \"$ISE_DS_DIR\" source \"$ISE_DS_DIR\"/settings64.sh export LANG='' # reset locale to English to fix decimal/comma seperation \"$ISE_DS_DIR\"/ISE/bin/lin64/ise 并为脚本添加可执行权限： sudo chmod a+x /opt/Xilinx/14.7/ISE_DS/quickstart 在/usr/share/applications新建文件ISE.desktop，内容为： [Desktop Entry] Version=1.0 Name=ISE Exec=/opt/Xilinx/14.7/ISE_DS/quickstart Terminal=false Icon=/opt/Xilinx/14.7/ISE_DS/ISE/data/images/pn-ise.png Type=Application Categories=Development 其中Exec指向的就是上一步建立的脚本文件 之后可以使用gtk-launch ISE一键打开 还可以在Windows桌面创建快捷方式： 路径写wslg ~ -d Ubuntu20.04 gtk-launch ISE 不过这个其实是会自动添加到开始菜单的 后记由于ISE安装包巨大，如果保留非常占据空间，所以考虑删掉。但是删掉后并不能真正释放空间，这个时候需要使用磁盘压缩工具对wsl的虚拟磁盘进行压缩，方法如下： 以管理员身份运行powershell，并输入 PS C:\\Windows\\System32&gt; wsl --shutdown PS C:\\Windows\\System32&gt; diskpart DISKPART&gt; select vdisk file=\"D:\\WSL\\ext4.vhdx\" DISKPART&gt; attach vdisk readonly DISKPART&gt; compact vdisk DISKPART&gt; detach vdisk 其中file=后面是你的wsl虚拟磁盘的位置 关于驱动由于我还没有开始写任何一个测试程序，尚不知驱动是否正常，这里挖一个坑，改日再填。 参考链接 缺少libncurses.so.5怎么办：https://blog.csdn.net/qq_36393978/article/details/110948418 Ubuntu安装ISE教程：https://blog.csdn.net/weixin_43238031/article/details/89022601 Ubuntu安装ISE教程以及快捷启动脚本：https://blog.csdn.net/ixunmo/article/details/82194896 释放wsl占用空间：https://zhuanlan.zhihu.com/p/358528257 清理wsl磁盘占用：https://www.cnblogs.com/enrio/p/14222648.html","categories":[{"name":"计组","slug":"计组","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%BB%84/"}],"tags":[{"name":"wsl","slug":"wsl","permalink":"https://toby-shi-cloud.github.io/tags/wsl/"},{"name":"CO","slug":"CO","permalink":"https://toby-shi-cloud.github.io/tags/CO/"}],"author":"Toby"},{"title":"将wsl迁移至D盘","slug":"moveWSLtoD","date":"2022-08-07T15:30:00.000Z","updated":"2022-08-08T16:07:36.422Z","comments":true,"path":"posts/movewsltod.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/movewsltod.html","excerpt":"","text":"前因因为下学期的计组课程需要用到ISE，然而ISE这样13年的软件和win11自然是不兼容了（经过网上大佬们的各种尝试，最终也只能安装到92%），所以在水群大佬的推荐下，我可以尝试使用WSLG（Windows Subsystem for Linux GUI）来运行ISE，于是我就先安装官网教程更新了wsl2，这个流程不太难，就不赘述了。 由于ISE体量巨大，所以不得不将WSL迁移到D盘以防止C盘爆炸。 过程迁移WSL需要使用工具LxRunOffline GitHub网址：https://github.com/DDoSolitary/LxRunOffline/releases如果迁移中遇到以下错误，则应该改用：https://ddosolitary-builds.sourceforge.io/LxRunOffline/LxRunOffline-v3.5.0-11-gfdab71a-msvc.zip [ERROR] Couldn't set the case sensitive attribute of the directory \"\\\\?\\C:\\Users\\toby2\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc\\LocalState\\\". Reason: Indicates that the directory trying to be deleted is not empty. 操作步骤注意：建议使用管理员身份运行powershell 查看已安装的子系统 ./LxRunOffline list 查看子系统所在目录 ./LxRunOffline get-dir -n [xxx] xxx是你在步骤1中查询到的子系统版本 迁移系统 ./LxRunOffline move -n [xxx] -d [ddd] xxx是你在步骤1中查询到的子系统版本 ddd是你期望移动到的路径 如果迁移系统中出现以下错误 [ERROR] The distro \"Ubuntu-20.04\" has running processes and can't be operated. \"wsl -t &lt;name&gt;\" or \"wsl --shutdown\" might help. 则使用快捷键Win+x再按g打开计算机管理重启服务LxssManager（也可以直接停止服务，迁移结束后再打开） 如果迁移后Ubuntu报错“拒绝访问” 使用下列指定为目录授权 icacls [ddd] /grant \"[user]:(OI)(CI)(F)\" ddd为移动后的路径 user为你的用户名 授权后建议重启LxssManager服务 Q&amp;A 如果Ubuntu报错“另一个程序正在使用此文件，进程无法访问” 以管理员身份运行以下指令 Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 然后按照要求重启电脑 造成此错误的原因估计为在未开启WSL的情况下使用资源管理器尝试打开WSL的磁盘镜像文件（.vhdx文件） 关于wslg的分辨率 目前wslg似乎只支持整数倍缩放，这非常不友好，但是可以手动启用非整数倍缩放 在wsl终端输入sudo vi /mnt/c/ProgramData/Microsoft/WSL/.wslgconfig新建一个文件（或者在Windows中找到C:\\ProgramData\\Microsoft\\WSL，并在其中新建文件.wslgconfig），文件内容如下： [system-distro-env] WESTON_RDP_DISABLE_FRACTIONAL_HI_DPI_SCALING=false 然后关闭wsl终端，打开powershell，输入wsl --shutdown即可 只不过150%缩放确实有点糊……","categories":[{"name":"计组","slug":"计组","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%BB%84/"}],"tags":[{"name":"wsl","slug":"wsl","permalink":"https://toby-shi-cloud.github.io/tags/wsl/"}],"author":"Toby"},{"title":"CF R 809 (Div.2) 题解","slug":"CFR309","date":"2022-07-20T12:00:00.000Z","updated":"2022-07-21T16:10:20.663Z","comments":true,"path":"posts/codeforcesr809.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/codeforcesr809.html","excerpt":"","text":"比赛链接试题链接 官方题解 *注意：在本文中，题目大意没有还原题目背景，也没有细节说明，如果您没有看过题目，还请前往Codeforces官网看 A题题目大意给定长度为$n$且只包含$1$和$m$之间的正整数数列$a_1,a_2,\\cdots,a_n$，有一个长度为$m$的字符串$s$，初始时串$s$只包含字符B 接下来进行如下$n$次操作： 在第$i$次操作时$(1\\le i \\le n)$，你可以选择将$s$串的第$a_i$个字符或者第$(m+1-a_i)$个字符改成A。（注意，你可以对同一个位置进行若干次操作） 找到$n$次操作后，你能得到的字典序最小的串$s$ *本题有多组数据$(t\\le2000)$，对于每组数据$1\\le n,m \\le50$ 解析签到题。显然数列${a_n}$的顺序与答案没有关系，因此可以考虑贪心，每次操作都优先将靠前的位置换成A，如果靠前的位置已经被更换了，就换另一个，如果两个都被更换过当然这次操作无论如何都没有意义了。 代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 55; int n, m; int cnt[maxn]; char str[maxn]; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { memset(cnt, 0, sizeof cnt); memset(str, 'B', sizeof str); scanf(\"%d%d\", &amp;n, &amp;m); str[m] = 0; for(int i = 0; i &lt; n; i++) { int v; scanf(\"%d\", &amp;v); v = min(v, m - v + 1); // v和m-v+1的操作选择是一样的，所以就取小的存下来 cnt[v]++; // 这里我用的桶存ai } for(int i = 1; i &lt;= m; i++) // 实际上当i&gt;m/2时cnt[i]就恒为0了 { if(cnt[i]) str[i-1] = 'A'; // 优先把靠前的换为A if(cnt[i] &gt; 1) str[m - i] = 'A'; // 如果不止1次更换机会，就把靠后的也换掉 } puts(str); } return 0; } B题题目大意有一个长度为$n$的数列数列${c_i}$，其值为不超过$n$的正整数。 现在对每个$c_i$依次进行如下操作： 对$c_1$，你将它放在$(0,0)$点 对$c_i(2\\le i\\le n)$，记$c_{i-1}$放在了$(x,y)$点，则你可以将$c_i$放在$(x+1,y)$或$(x-1,y)$或$(x,y+1)$（但是不能放在$(x,y-1)$）当然前提是这些地方之前没有放置过其他的$c_i$ 若对于某个$(x,y)$和某个$s$，若$(x,y),(x,y+1),\\cdots,(x,y+s-1)$被放置了值相同的$c_i$，则定义这些点组成了一个“塔”。定义“塔”的高是$s$，“塔”被放置在了$(x,y)$处，“塔”的颜色为这些相同的$c_i$的值。 对于每一个不超过$n$的正整数$r$，独立的解决如下问题： 找到你能按规则构造出的，颜色为$r$​的，高度最高的“塔”。 *本题有多组数据$(t \\le 10^4)$，每组数据满足$n \\le 10^5$，对于全部数据$\\sum n \\le 2 \\cdot 10^5$ 解析注意到题目要求我们独立的处理每一个$r$而且只需要找出最高的“塔”，所以我们可以考虑对于固定的$r$，贪心的希望每个$r$都能刚好搭在上一个$r$上。抽象化的，记$c_i=c_j=r(i &lt; j)$，什么情况下$c_i$和$c_j$可以组成一个“塔”呢？ 进过简单的推理可以证明，当且仅当$(j-i)$为奇数时，$c_i$和$c_j$能构成一个“塔”。 必要性证明过程大致如下： 若$c_i$被放置在$(x,y)$处，则记$Q(c_i)=x+y$ 则根据题意有$Q(c_{i+1})=x+y\\pm1$，即$Q(c_{i+1}) \\equiv Q(c_i) + 1 \\ (mod\\ 2)$ 所以$Q(c_j) \\equiv Q(c_i) + j - i \\ (mod \\ 2)$ 因为$c_j$和$c_i$构成“塔”，所以$Q(c_j)-Q(c_i)=1$ 于是有$j-i \\equiv 1 \\ (mod \\ 2)$，即$(j-i)$是奇数 充分性证明略，因为只需要给出一个简单的构造，这里就留给读者吧~ 那么当$(j-i)$是偶数的时候会发生什么情况呢？由于$c_i$下面可能已经成塔了，但是$c_j$并没有，所以当出现$c_k=r$而且$(k-i)$是奇数时（此时显然$(k-j)$也是奇数）将$c_k$放在$c_i$的上面为“塔”填一层楼是更优的。 因此本题只需要记录第一个$c_i=r$的$i$值，然后之后一旦碰见$c_j=c_i$而且$(j-i)$是奇数时就ans++即可。 最后可以看出，对于不同的$r$，我们可以同时进行计算，至此本题解决。 代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 1e5 + 5; int n, c[maxn], cnt[maxn], lst[maxn]; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) { lst[i] = -1; cnt[i] = 0; } for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;c[i]); for(int i = 0; i &lt; n; i++) { if((i - lst[c[i]]) % 2 == 1 || lst[c[i]] == -1) cnt[c[i]]++; lst[c[i]] = i; } for(int i = 1; i &lt;= n; i++) { printf(\"%d \", cnt[i]); } puts(\"\"); } return 0; } C题题目大意给定长度为$n$的正整数列${h_i}$，你可以花费代价增大其中的值，每花费$1$点代价可以将一个$h_i$增大$1$。 描述$h_i$是“好看的”，当且仅当$i\\neq 1$且$i\\neq n$且$h_i &gt; h_{i-1}$且$h_i &gt; h_{i+1}$。 要求在保证整个数列“好看的”$h_i$最多的情况下花费的最小代价。 *本题有多组数据$(t \\le 10^4)$，对于每组数据$3 \\le n \\le 10^5$，$h_i \\le 10^9$，对于全部数据$\\sum n \\le 2 \\cdot 10^5$ 解析首先肯定要考虑如何让“好看的”$h_i$最多。根据题意，“好看的”$h_i$无法连续出现，也不能出现在收尾，所以必然可以使得而且最多只能使得$\\lfloor\\frac{n-1}{2}\\rfloor$个$h_i$成为“好看的”。而且当$n$是奇数时很容易解决，因为必然得是所有的$h_{2i}$都是“好看的”。所以接下来重点讨论当$n$是偶数的情况。 可以注意到，$n$是偶数时，必然存在一个$k$，使得$i&lt;k$时，当$i$是偶数时$h_i$是“好看的”，当$i&gt;k$时，当$i$是奇数时$h_i$是“好看的”。于是，我们可以考虑进行dp。 设dp[i]使得$h_i$是好看的前提下，保证前$i$个$h_i$中的“看好的”数最多，需要的最少花费，那么最终答案就是min(dp[n-2],dp[n-1])。下面考虑如何转移。进过我们之前的讨论，可以知道，当$i$是偶数时，前面一个好看的数必然是偶数，当$i$是奇数时则既可能是奇数有可能是偶数，于是转移方程如下： int w = max(h[i-1], h[i+1]) - h[i] + 1; // w就是变成“好看的”的代价 if(w &lt; 0) w = 0; if(i &amp; 1) dp[i] = min(dp[i-2], dp[i-3]) + w; else dp[i] = dp[i-2] + w; 最后需要注意一点，本题需要开long long 代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 1e5 + 5; int n, h[maxn]; long long ans, dp[maxn]; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { ans = 0; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;h[i]); if(n &amp; 1) { for(int i = 2; i &lt; n; i+=2) { int w = max(h[i-1], h[i+1]) - h[i] + 1; if(w &gt; 0) ans += w; } printf(\"%lld\\n\", ans); continue; } dp[0] = dp[1] = 0; for(int i = 2; i &lt; n; i++) { int w = max(h[i-1], h[i+1]) - h[i] + 1; if(w &lt; 0) w = 0; if(i &amp; 1) dp[i] = min(dp[i-2], dp[i-3]) + w; else dp[i] = dp[i-2] + w; } printf(\"%lld\\n\", min(dp[n-1], dp[n-2])); } return 0; } D题题目大意给定长度为$n$的正整数列${a_n}$以及正整数$k$，寻找一个长度为$n$，值不超过$k$的正整数列${p_n}$，使得下面这个式子的值最小$$\\max_{1 \\le i \\le n}(\\lfloor\\frac{a_i}{p_i}\\rfloor)-\\min_{1 \\le i \\le n}(\\lfloor\\frac{a_i}{p_i}\\rfloor)$$最后题目只要求输出上面这个式子可能的最小值，不需要输出对应${p_n}$ *本题分为D1和D2，仅仅是数据范围不同 *D1范围：有多组数据$(t \\le 100)$，对于每组数据$n,k,a_n \\le 3000$，且保证${a_n}$单调不减，且对于全部数据$\\sum n \\le 3000$ *D2范围：有多组数据$(t \\le 100)$，对于每组数据$n,k,a_n \\le 10^5$，且保证${a_n}$单调不减，且对于全部数据$\\sum n \\le 10^5$ 解析 1先考虑D1怎么做，这里根据范围可以猜想存在$O(n^2)$的做法可以通过D1。显然遍历所有的${p_n}$是非常不现实的，因为复杂度将达到$O(k^n)$，十分恐怖。 观察要求的式子，如果我们令$M=\\max_{1 \\le i \\le n}(\\lfloor\\frac{a_i}{p_i}\\rfloor)$以及$m=\\min_{1 \\le i \\le n}(\\lfloor\\frac{a_i}{p_i}\\rfloor)$，则我们可以考虑遍历$M$（从$a_n$遍历到$\\lfloor\\frac{a_n}{k}\\rfloor$），然后对于每个$M$尽可能的选取较大的$m$即可。具体做法如下： 对于固定$M$和每一个$a_i$，为了使得$m$最大，则必须让每个$\\lfloor\\frac{a_i}{p_i}\\rfloor$尽量大，即$p_i$尽量小，即有$\\lfloor\\frac{a_i}{p_i}\\rfloor \\le M$但是$\\lfloor\\frac{a_i}{p_i-1}\\rfloor &gt; M$，如果记$a_i = kM + r(0\\le r &lt; M)$可以解出$p_i = k (0 \\le r &lt; k)$或者$p_i = k + 1 (k \\le r &lt; M)$。借此我们就可以以$O(n^2)$的复杂度过D1。 代码1#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 3e3 + 5; const int inf = 1e9 + 7; int n, k, a[maxn]; int ans; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { scanf(\"%d%d\", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); if(a[n] / k == 0) { puts(\"0\"); continue; } ans = inf; for(int max_val = 3000; max_val &gt;= 1; max_val--) { int min_val = inf; for(int i = 1; i &lt;= n; i++) { int p = a[i] / max_val; if(p == 0 || a[i] / p &gt; max_val) p++; if(p &gt; k) p = k; if(a[i] / p &gt; max_val) { min_val = inf; break; } min_val = min(min_val, a[i] / p); } if(min_val &lt;= max_val) ans = min(ans, max_val - min_val); } printf(\"%d\\n\", ans); } return 0; } 解析2沿用D1的思路，但是我们希望可以在$O(log n)$的复杂度内找出给定$M$情况下的最大$m$。 要做到这一点，我们要先回过头来看看式子，$\\lfloor\\frac{a_i}{p_i}\\rfloor \\le M$但是$\\lfloor\\frac{a_i}{p_i-1}\\rfloor &gt; M$，但是这次我们不解出$p_i$而是反而解出$a_i$，于是有$(M+1)(p_i-1)\\le a_i &lt; (M+1)p_i$。由于对于相同的$p_i$当然是$a_i$越小才能影响到$m$的值，所以对于每一个$M$，遍历$p$（从1开始直到$(p+1)\\cdot(M+1)&gt;a_n$为止），然后对于每一个$p$，可以用二分的方式（因为$a_n$有序）找到第一个不小于$(M+1)(p_i-1)$的$a_i$，用$\\lfloor\\frac{a_i}{p}\\rfloor$更新$m$（取min）。 于是复杂度来到了$O(\\sum\\frac{n}{i}log n)$，可以证明$O(\\sum\\frac{n}{i})=O(nlogn)$所以总的复杂度是$O(nlog^2n)$。但是这个复杂度并不是最优的（虽然对于1e5的数据已经足够了）。我们可以考虑预处理而非每次都二分来寻找$a_i$，这使得复杂度降到$O(nlogn)$。 代码2#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 1e5 + 5; const int inf = 1e9 + 7; int n, k, a[maxn]; int ans, max_val, min_val; int great_min[maxn]; int main() { int T; scanf(\"%d\", &amp;T); while(T--) { scanf(\"%d%d\", &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); if(a[n-1] / k == 0) { puts(\"0\"); continue; } n = unique(a, a + n) - a; // 去重，显然重复的ai对本题无影响，当然这个语句本来也不是必须的 for(int i = 0, *p = a; i &lt;= a[n-1]; i++) { if(*p &lt; i) p++; great_min[i] = *p; // 预处理，即great_min[x]表示不小于x的最小的ai } max_val = a[n-1], min_val = a[0]; ans = max_val - min_val; while(max_val &gt;= a[n-1] / k) { for(int i = 0; i * (max_val+1) &lt;= a[n-1]; i++) // 这里i其实是遍历的(p-1) { min_val = min(min_val, great_min[i*(max_val+1)] / (i+1)); } ans = min(ans, max_val - min_val); max_val--; } printf(\"%d\\n\", ans); } return 0; } E题题目大意给定一个$n$个点$m$条边的无向无权连通图，点编号从1到n，边编号从1到m。 给出$q$次询问，每次询问包括两个正整数$l$和$r$。你需要找到你一个最小的满足下列要求的$k$： 对任何满足$l \\le a \\le b \\le r$的点对$(a,b)$，点$a$和点$b$可以只使用前$k$条边（即编号从1到k的边）的情况下连通 *本题有多组数据$(t \\le 1000)$，对每个数据$n\\le10^5$，$m,q\\le2\\cdot10^5$，对全部数据$\\sum n\\le10^5$，$\\sum m,\\sum q\\le2\\cdot10^5$ 解析本题第一眼看的时候有一种二分答案+可持续化并查集的感觉。然而可惜的是，每次询问不是检查两个点是否连通，而是检查一个区间是否连通。那么提到区间，就可以想到一种做法是倍增。而且我们惊人的发现两个区间的合并是如此的简单，只要有公共点，两个区间合并就是对$k$取max。于是问题转化为如何求得每两个相邻点的$k$。 转化到这个地步了，当然可以直接二份答案+可持续化并查集，可是复杂度将来到3个log，而且写起来还很麻烦，根本用不着。于是考虑只使用普通的并查集，而且不用路径压缩，而是改为启发式合并的并查集，这样做的好处就是每加一条边的时候，都只检查小集合里面的所有点有没有和相邻的点相连。复杂度是$O(nlogn)$。 于是本题总复杂度为$O(nlogn+nlogn+qlogn)$即$O((n+q)logn)$ 代码#include &lt;vector&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define debug(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; (x) &lt;&lt; endl const int maxn = 1e5 + 5; const int c_pow2[] = { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072 }; int n, m, q; int fa[maxn]; int ans[maxn][20]; vector&lt;int&gt; forest[maxn]; inline int c_log2(int x) { return upper_bound(c_pow2, c_pow2 + 18, x) - c_pow2 - 1; } int main() { int T; scanf(\"%d\", &amp;T); while(T--) { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i++) { fa[i] = i; ans[i][0] = -1; vector&lt;int&gt;({i}).swap(forest[i]); } for(int i = 1; i &lt;= m; i++) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if(fa[v] == fa[u]) continue; if(forest[fa[v]].size() &gt; forest[fa[u]].size()) swap(u, v); int fa_v = fa[v]; for(int x : forest[fa_v]) { fa[x] = fa[u]; forest[fa[u]].push_back(x); } for(int x : forest[fa_v]) { if(x != 1 &amp;&amp; ans[x-1][0] == -1 &amp;&amp; fa[x-1] == fa[x]) ans[x-1][0] = i; if(x != n &amp;&amp; ans[x][0] == -1 &amp;&amp; fa[x+1] == fa[x]) ans[x][0] = i; } vector&lt;int&gt;().swap(forest[fa_v]); } vector&lt;int&gt;().swap(forest[fa[1]]); for(int pk = 1; c_pow2[pk] &lt; n; pk++) { for(int i = 1; i &lt;= n; i++) { if(c_pow2[pk] + i &gt; n) break; ans[i][pk] = max(ans[i][pk-1], ans[i+c_pow2[pk-1]][pk-1]); } } while(q--) { int l, r; scanf(\"%d%d\", &amp;l, &amp;r); int pk = c_log2(r - l); printf(\"%d \", max(ans[l][pk], ans[r-c_pow2[pk]][pk])); } puts(\"\"); } return 0; }","categories":[{"name":"竞赛","slug":"竞赛","permalink":"https://toby-shi-cloud.github.io/categories/%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"算法","slug":"算法","permalink":"https://toby-shi-cloud.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://toby-shi-cloud.github.io/tags/Codeforces/"}],"author":"Toby Shi"},{"title":"学生评教自动化脚本","slug":"EvaluationAutomationScript","date":"2022-07-04T13:00:00.000Z","updated":"2022-07-28T16:18:36.387Z","comments":true,"path":"posts/evaluation-automation-script.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/evaluation-automation-script.html","excerpt":"","text":"脚本内容javascript:function ttj(){ firrr=window.top.document.getElementById(\"iframename\").contentWindow; firrr.alert=function(){return true}; firrr.confirm=function(){return true}; a=firrr.$(\"input[name^=tabmapzb]\"); b=firrr.$(\"span.yellow\"); if(a.length!==0){ a[1].click(); a[5].click(); a[10].click(); a[15].click(); a[20].click(); a[25].click(); }else{ b[1].firstElementChild.click() } var selections = firrr.document.getElementsByTagName(\"select\"); for(var i = 0 ; i&lt; selections.length; i++){ selections[i].value = \"1\"; } firrr.tj(); } firrr=window.top.document.getElementById(\"iframename\").contentWindow; setInterval(\"firrr.$.onload = ttj()\",1400); 使用方法 登录教务系统 请勿更改主题设置 在“教学评价”中找到“学生评教” 点击“开始评教”，进入下面这个界面 按F12打开控制台，并找到Console或者“控制台” 在控制台中粘贴代码并回车运行 评教全部完成后刷新网页即可 附录在附上一个可以提前下载课表的神奇代码 var ele = $(\"#iframename\").contents().find(\"#xnxq\"); for(let i=0;i&lt;4;i++){ if(ele.children().eq(i).text()==\"2022秋季\"){ console.log(\"发现目标，正在等待下载\"); ele[0].selectedIndex = i; break; } } document.getElementsByTagName(\"iframe\")[0].contentWindow.exportExcel();","categories":[{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/categories/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/tags/%E8%84%9A%E6%9C%AC/"}],"author":"Unknown"},{"title":"蓝桥杯2022决赛参赛记录","slug":"LanQiaoCup2022Final","date":"2022-06-18T13:50:00.000Z","updated":"2022-06-19T10:24:26.356Z","comments":true,"path":"posts/lanqiaocup2022final.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/lanqiaocup2022final.html","excerpt":"","text":"A 题：小蓝与钥匙问题描述 小蓝是幼儿园的老师，他的班上有 28 个孩子，今天他和孩子们一起进行了一个游戏。 小蓝所在的学校是寄宿制学校，28 个孩子分别有一个自己的房间，每个房间对应一把钥匙，每把钥匙只能打开自己的门。现在小蓝让这 28 个孩子分别将自己宿舍的钥匙上交，再把这 28 把钥匙随机打乱分给每个孩子一把钥匙，有$28! = 28\\times27\\times \\cdots \\times1 $种分配方案。小蓝想知道这些方案中，有多少种方案恰有一半的孩子被分到自己房间的钥匙（即有 14 个孩子分到的是自己房间的钥匙，有 14 个孩子分到的不是自己房间的钥匙）。 答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 考场思路显然这个题分为两步，一是有14个同学分到了自己的钥匙，二是剩下的14个同学都没有分到自己的钥匙，记方案数为$Q$，则有：$$Q = C_{28}^{14} \\cdot D_{14}$$其中$D_{14}$为14的全错位排列。全错位排列也称“欧拉装错信箱问题”，其计算可用容斥原理，公式如下：$$D_n = \\sum_{i=0}^{n} (-1)^i \\cdot C_n^i \\cdot (n-i)!$$或者：$$D_n = n! \\cdot \\sum_{i=0}^{n} \\frac{(-1)^i}{i!}$$于是有方案数$Q=1,286,583,532,342,313,400$ B 题：排列距离问题描述 小蓝最近迷上了全排列，现在他有一个长度为 17 的排列，里面包含的元素有：abcdefghijklnopqr，即 a 至 r 中除了 m 以外的所有小写字母，这 17个字母在任何一个排列中都恰好出现一次。前面几个排列依次是： 第 1 个排列为：abcdefghijklnopqr； 第 2 个排列为：abcdefghijklnoprq； 第 3 个排列为：abcdefghijklnoqpr； 第 4 个排列为：abcdefghijklnoqrp； 第 5 个排列为：abcdefghijklnorpq； 第 6 个排列为：abcdefghijklnorqp； 第 7 个排列为：abcdefghijklnpoqr； 第 8 个排列为：abcdefghijklnporq； 第 9 个排列为：abcdefghijklnpqor； 第 10 个排列为：abcdefghijklnpqro。 对于一个排列，有两种转移操作：1）转移到其下一个排列。如果当前排列已经是最后一个排列，那么下一个排列就是第一个排列。2）转移到其上一个排列。如果当前排列是第一个排列，那么上一个排列就是最后一个排列。小蓝现在有两个排列，分别为排列 A：aejcldbhpiogfqnkr，以及排列B：ncfjboqiealhkrpgd，他现在想知道，在只有上述两种转移操作的前提下，排列 A 最少转移多少次能得到排列 B。 答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 考场思路显然只要知道了排列A和排列B分别是第几个排列就可以了。 因此我们使用康托展开（Cantor expansion）就可以了。若记排列$\\lambda$为$a_1,a_2,a_3,\\dots,a_n$，则有：$$X_{\\lambda} = q_1 \\cdot (n-1)! + q_2 \\cdot (n-2)! + \\cdots + q_n \\cdot 0!$$其中$q_i$表示$a_i$在$a_i,a_{i+1},\\dots,a_n$中是第$q_i$小的数，则$X_\\lambda$表示排列$\\lambda$是第$X_\\lambda$个排列。（注：这里第几小的数和第几个排列都从0开始标号，计算会比较方便） 最后我的结果是：排列A的编号是$4,542,892,071,974$，排列B的编号是$254,081,962,595,831$，最终答案取$min{X_A - X_B + 19!, X_B - X_A} = 106,148,357,572,143$即可。 C 题：内存空间问题描述 小蓝最近总喜欢计算自己的代码中定义的变量占用了多少内存空间。 为了简化问题，变量的类型只有以下三种：int：整型变量，一个 int 型变量占用 4 Byte 的内存空间。long：长整型变量，一个 long 型变量占用 8 Byte 的内存空间。String：字符串变量，占用空间和字符串长度有关，设字符串长度为 L，则字符串占用 L Byte 的内存空间，如果字符串长度为 0 则占用 0 Byte 的内存空间。 定义变量的语句只有两种形式，第一种形式为：type var1=value1,var2=value2...;定义了若干个 type 类型变量 var1、var2、…，并且用 value1、value2…初始化，多个变量之间用’,’ 分隔，语句以’;’ 结尾，type 可能是 int、long 或 String。例如 int a=1,b=5,c=6; 占用空间为 12 Byte；long a=1,b=5; 占用空间为 16 Byte；String s1=””,s2=”hello”,s3=”world”; 占用空间为 10 Byte。 第二种形式为：type[] arr1=new type[size1],arr2=new type[size2]...;定义了若干 type 类型的一维数组变量 arr1、arr2…，且数组的大小为size1、size2…，多个变量之间用’,’ 进行分隔，语句以’;’ 结尾，type 只可能是 int 或 long。例如 int[] a1=new int[10]; 占用的内存空间为 40Byte；long[] a1=new long[10],a2=new long[10]; 占用的内存空间为160 Byte。 已知小蓝有 T 条定义变量的语句，请你帮他统计下一共占用了多少内存空间。结果的表示方式为：aGBbMBcKBdB，其中 a、b、c、d 为统计的结果，GB、MB、KB、B 为单位。优先用大的单位来表示，1GB=1024MB，1MB=1024KB，1KB=1024B，其中 B 表示 Byte。如果 a、b、c、d 中的某几个数字为 0，那么不必输出这几个数字及其单位。题目保证一行中只有一句定义变量的语句，且每条语句都满足题干中描述的定义格式，所有的变量名都是合法的且均不重复。题目中的数据很规整，和上述给出的例子类似，除了类型后面有一个空格，以及定义数组时 new 后面的一个空格之外，不会出现多余的空格。 输入格式 输入的第一行包含一个整数 T ，表示有 T 句变量定义的语句。接下来 T 行，每行包含一句变量定义语句。 输出格式 输出一行包含一个字符串，表示所有语句所占用空间的总大小。 测试样例 样例输入 样例输出 1long[] nums=new long[131072]; 1MB 4int a=0,b=0;long x=0,y=0;String s1=”hello”,s2=”world”;long[] arr1=new long[100000],arr2=new long[100000]; 1MB538KB546B 样例说明 样例 1，占用的空间为 131072 × 8 = 1048576 B，换算过后正好是 1MB，其它三个单位 GB、KB、B 前面的数字都为 0 ，所以不用输出。 样例 2，占用的空间为 4 × 2 + 8 × 2 + 10 + 8 × 100000 × 2 B，换算后是1MB538KB546B。 规模与约定 对于所有评测用例，1 ≤ T ≤ 10，每条变量定义语句的长度不会超过 1000。所有的变量名称长度不会超过 10，且都由小写字母和数字组成。对于整型变量，初始化的值均是在其表示范围内的十进制整数，初始化的值不会是变量。对于 String 类型的变量，初始化的内容长度不会超过 50，且内容仅包含小写字母和数字，初始化的值不会是变量。对于数组类型变量，数组的长度为一个整数，范围为：$[0, 2^{30}]$，数组的长度不会是变量。T 条语句定义的变量所占的内存空间总大小不会超过 1 GB，且大于 0 B。 考场思路这个题，怎么说呢，几乎就是纯模拟吧大概。 首先每行的首个字符串就是类型说明，然后对于不同的类型找不同的符号就可以了。 比如int和long型，就找有多少个“,”；数组就找“int[”和“long[”；字符串就找“””就可以了。 部分代码如下： void solve_int(const char* str) { while(*str) { if(*str == ',' || *str == ';') ans += 4; str++; } } void solve_int_arr(const char* str) { const char* tmp; // const char* lst = str + strlen(str); while((tmp = strstr(str, \"int[\")) != NULL) { tmp += 4; int num = 0; while(isdigit(*tmp)) { num = num * 10 + (*tmp - '0'); tmp++; } str = tmp; ans += 4 * num; } } void solve_long(const char* str) { while(*str) { if(*str == ',' || *str == ';') ans += 8; str++; } } void solve_long_arr(const char* str) { const char* tmp; // const char* lst = str + strlen(str); while((tmp = strstr(str, \"long[\")) != NULL) { tmp += 5; int num = 0; while(isdigit(*tmp)) { num = num * 10 + (*tmp - '0'); tmp++; } str = tmp; ans += 8 * num; } } void solve_String(const char* str) { const char* tmp; // const char* lst = str + strlen(str); while((tmp = strchr(str, '\\\"')) != NULL) { // fprintf(\"tmp=%s\\n\",tmp); tmp += 1; int num = 0; while(*tmp != '\\\"') { num++; tmp++; } str = tmp + 1; ans += num; } } D 题：最大公约数问题描述 给定一个数组，每次操作可以选择数组中任意两个相邻的元素 x, y 并将其中的一个元素替换为 gcd(x, y) ，其中 gcd(x, y) 表示 x 和 y 的最大公约数。 请问最少需要多少次操作才能让整个数组只含 1 。 输入格式 输入的第一行包含一个整数 n ，表示数组长度。 第二行包含 n 个整数 a1, a2, · · · , an，相邻两个整数之间用一个空格分隔。 输出格式 输出一行包含一个整数，表示最少操作次数。如果无论怎么操作都无法满足要求，输出 −1。 测试样例 样例输入 样例输出 34 6 9 4 规模与约定 对于 30% 的评测用例，$n ≤ 500 ，a_i ≤ 1000$；对于 50% 的评测用例，$n ≤ 5000 ，a_i ≤ 10^6$；对于所有评测用例，$1 ≤ n ≤ 100000 ，1 ≤ a_i ≤ 10^9$。 考场思路可以发现，如果数列中有一个数为1，那么问题就很好解决了：答案即为非1的个数。 因此本题的关键在于如何最快的弄出一个1。 由于题目只允许相邻的两个数取gcd，所以如果找到连续k个数gcd为1的话，就可以用k-1次操作把其中一个数换为1，因此答案为：n+k-2。（当然，如果这n个数的gcd为非1，就直接输出-1即可） 于是问题化为如何找到这个最小的k。 稍微暴力的做法是，首先求两个两个的gcd，然后求三个三个的gcd（可以发现，三个数的gcd就是相邻两个gcd的gcd），依次下去，每次gcd的数目减小1，于是时间复杂度是$O(\\sum_{i=1}^n i)$即$O(n^2)$（由于$a_i$并不大，所以gcd的复杂度（不超过$O(5 \\lg n)$，大约就是10倍左右）就忽略了）实现大致如下： void focus_solve() { int ans = n - 1; while(!flag) { n--; ans++; for(int i = 0; i &lt; n; i++) { num[i] = gcd(num[i], num[i+1]); if(num[i] == 1) {flag = true;break;} } } printf(\"%d\\n\", ans); } 至于100%的数据，我使用了倍增+二分，复杂度大概是$O(40nlogn)$（倍数是gcd的复杂度），复杂度上肯定是没有问题的。大致的想法就是先预处理出从数量任意一个数起，2的整次幂个数的gcd，这里复杂度就是$O(20nlogn)$。然后对上面说的k进行二分（k最大取n），每次check遍历起点，然后用预处理的数据计算出k个数的gcd，也是$O(20nlogn)$。代码大致如下： const int pow2[] = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072}; bool check(int x) { int logval = upper_bound(pow2, pow2 + 18, x) - pow2 - 1; // logval = log2(x)向下取整-1 for(int i = 0; i &lt; n - x + 1; i++) { int l = i, r = i + x; int _g = gcd(_gcd_2[l][logval], _gcd_2[r-pow2[logval]][logval]); // _gcd_2就是预处理数组 if(_g == 1) return true; } return false; } void solve() { int max_log = upper_bound(pow2, pow2 + 18, n) - pow2; for(int p = 0; p &lt; max_log; p++) for(int i = 0; i &lt; n; i++) { if(p == 0) _gcd_2[i][0] = num[i]; else if (i+pow2[p-1] &gt;= n) _gcd_2[i][p] = _gcd_2[i][p-1]; else _gcd_2[i][p] = gcd(_gcd_2[i][p-1], _gcd_2[i+pow2[p-1]][p-1]); } int L = 1, R = n; while(L != R) { int mid = L + R &gt;&gt; 1; if(check(mid)) R = mid; else L = mid + 1; } printf(\"%d\\n\", n + L - 2); } E 题：owo问题描述 小蓝很喜欢 owo ，他现在有一些字符串，他想将这些字符串拼接起来，使得最终得到的字符串中出现尽可能多的 owo 。 在计算数量时，允许字符重叠，即 owowo 计算为 2 个，owowowo 计算为3 个。 请算出最优情况下得到的字符串中有多少个 owo。 输入格式 输入的第一行包含一个整数 n ，表示小蓝拥有的字符串的数量。接下来 n 行，每行包含一个由小写英文字母组成的字符串 si 。 输出格式 输出 n 行，每行包含一个整数，表示前 i 个字符串在最优拼接方案中可以得到的 owo 的数量。 测试样例 样例输入 样例输出 3owowow 112 规模与约定 对于 10% 的评测用例，$n ≤ 10$；对于 40% 的评测用例，$n ≤ 300$；对于 60% 的评测用例，$n ≤ 5000$；对于所有评测用例，$1 ≤ n ≤ 10^6 ，1 ≤ |s_i| ，\\sum|s_i| ≤ 10^6$，其中 $|s_i|$表示字符串$s_i$的长度。 考场思路首先肯定要能计算出每个字符串内部的owo的个数，当然这个是比较好计算的，用kmp或者直接用两个flag就能搞定。 其实是最重要的，要考虑拼接，不过好在这个owo很短，可用的拼接方式并不多，大致应该只有如下三种： 以ow结尾+以o开头 以o结尾+以wo开头 以o结尾+单独一个字母w+以o开头 因此我们就统计上面这些可以拼接的字符串的数量就可以了。但是需要注意的是，如果一个字符串既以ow结尾又以o开头，虽然都要计数，但是不能自己和自己拼接在一起，不仅如此，字符串也不能拼接成环。但是这个我在考试的时候想的不多，就没有考虑完全，大概是寄了，因此就不放代码了，如何实现就留给读者思考吧。 F 题：环境治理问题描述 LQ 国拥有 n 个城市，从 0 到 n − 1 编号，这 n 个城市两两之间都有且仅有一条双向道路连接，这意味着任意两个城市之间都是可达的。每条道路都有一个属性 D ，表示这条道路的灰尘度。当从一个城市 A 前往另一个城市 B 时，可能存在多条路线，每条路线的灰尘度定义为这条路线所经过的所有道路的灰尘度之和，LQ 国的人都很讨厌灰尘，所以他们总会优先选择灰尘度最小的路线。 LQ 国很看重居民的出行环境，他们用一个指标 P 来衡量 LQ 国的出行环境，P 定义为：$$P = \\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1}d(i,j)$$其中 d(i, j) 表示城市 i 到城市 j 之间灰尘度最小的路线对应的灰尘度的值。 为了改善出行环境，每个城市都要有所作为，当某个城市进行道路改善时，会将与这个城市直接相连的所有道路的灰尘度都减少 1，但每条道路都有一个灰尘度的下限值 L，当灰尘度达到道路的下限值时，无论再怎么改善，道路的灰尘度也不会再减小了。 具体的计划是这样的：第 1 天，0 号城市对与其直接相连的道路环境进行改善；第 2 天，1 号城市对与其直接相连的道路环境进行改善；…第 n 天，n − 1 号城市对与其直接相连的道路环境进行改善；第 n + 1 天，0 号城市对与其直接相连的道路环境进行改善；第 n + 2 天，1 号城市对与其直接相连的道路环境进行改善；… LQ 国想要使得 P 指标满足 P ≤ Q。请问最少要经过多少天之后，P 指标可以满足 P ≤ Q。如果在初始时就已经满足条件，则输出 0 ；如果永远不可能满足，则输出 −1。 输入格式 输入的第一行包含两个整数$n, Q$，用一个空格分隔，分别表示城市个数和期望达到的$P$指标。 接下来$n$行，每行包含$n$个整数，相邻两个整数之间用一个空格分隔，其中第$i$行第$j$列的值$D_{ij}$ $(D_{ij} = D_{ji}, D_{ii} = 0)$表示城市$i$与城市$j$之间直接相连的那条道路的灰尘度。 接下来$n$行，每行包含$n$个整数，相邻两个整数之间用一个空格分隔，其中第$i$行第$j$列的值$L_{ij}$ $(L_{ij} = L_{ji}, L_{ii} = 0)$表示城市$i$与城市$j$之间直接相连的那条道路的灰尘度的下限值。 输出格式 输出一行包含一个整数表示答案。 测试样例 样例输入 样例输出 3 100 2 42 0 14 1 00 2 22 0 02 0 0 2 样例说明 初始时的图如下所示，每条边上的数字表示这条道路的灰尘度：此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：$$d(0, 0) = 0, d(0, 1) = 2, d(0, 2) = 3, \\d(1, 0) = 2, d(1, 1) = 0, d(1, 2) = 1, \\d(2, 0) = 3, d(2, 1) = 1, d(2, 2) = 0.$$初始时的 P 指标为 (2 + 3 + 1) × 2 = 12，不满足 P ≤ Q = 10；第一天，0 号城市进行道路改善，改善后的图示如下：注意到边 (0, 2) 的值减小了 1 ，但 (0, 1) 并没有减小，因为 L0,1 = 2 ，所以(0, 1) 的值不可以再减小了。此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：$$d(0, 0) = 0, d(0, 1) = 2, d(0, 2) = 3, \\d(1, 0) = 2, d(1, 1) = 0, d(1, 2) = 1, \\d(2, 0) = 3, d(2, 1) = 1, d(2, 2) = 0.$$此时 P 仍为 12。第二天，1 号城市进行道路改善，改善后的图示如下：此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：$$d(0, 0) = 0, d(0, 1) = 2, d(0, 2) = 2, \\d(1, 0) = 2, d(1, 1) = 0, d(1, 2) = 0, \\d(2, 0) = 2, d(2, 1) = 0, d(2, 2) = 0.$$此时的 P 指标为 (2 + 2) × 2 = 8 &lt; Q ，此时已经满足条件。所以答案是 2。 规模与约定 对于 30% 的评测用例，$1 ≤ n ≤ 10 ，0 ≤ L_{ij} ≤ D_{ij} ≤ 10$；对于 60% 的评测用例，$1 ≤ n ≤ 50 ，0 ≤ L_{ij} ≤ D_{ij} ≤ 100000$；对于所有评测用例，$1 ≤ n ≤ 100 ，0 ≤ L_{ij} ≤ D_{ij} ≤ 100000 ，0 ≤ Q ≤ 2^{31} − 1$。 考场思路不得不说这个题长到离谱（其实是样例解释长），所以我最后看的这个题。这个题暴力的话显然就是每天都用Floyd算法求一遍最短路，然后求一遍P就可以了，复杂度上是$O(day \\cdot n^3)$，其中Day是需要经历的天数，至于输出-1的情况，完全可以用$L_{ij}$作为边权跑一次Floyd就知道了。问题就是，这个复杂度是无法接受的，甚至连60%的数据都不能通过，只能拿到30%的分。 这里呢注意到数据规模中$n$是比较小的，但是$D-L$可能是比较大，所以考虑二分答案，理想中复杂度应该是$O(log(\\frac12n(D-L))\\cdot n^3)$，这样复杂度的话就很可以接受了。这里二分的话最大的天数应该是$\\frac12nD=5e6$。check函数的代码大概如下（复杂度是$O(n^2 + n^3)$）： bool check(int day) { int turn = day / n; // 每一轮，每条道路灰尘度下降2 day %= n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) { dis[i][j] = D[i][j] - 2 * turn; if(day &gt; i) dis[i][j]--; // 如果这一轮城市i还进行了清理 if(day &gt; j) dis[i][j]--; // 如果这一轮城市j还进行了清理 if(dis[i][j] &lt; L[i][j]) dis[i][j] = L[i][j]; // 注意灰尘度是有下限的 } floyd(); P = 0; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) P += dis[i][j]; if(P &lt;= Q) return 1; return 0; } G 题：选素数问题描述 小蓝有一个数 x，每次操作小蓝会选择一个小于 x 的素数 p，然后在 x 成为 p 的倍数前不断将 x 加 1，(如果 x 一开始就是 p 的倍数则 x 不变)。 小乔看到了小蓝进行了 2 次上述操作后得到的结果 n，他想知道 x 在一开始是多少。如果有多种可能，他想知道 x 一开始最小可以是多少，而如果不存在任何解，说明小乔看错了，此时请输出 −1。 输入格式 输入一行包含一个整数 n ，表示经过两次操作后 x 的值。 输出格式 输出一行包含一个整数表示 x 的初始值。如果有多个解，输出最小的。如果不存在解，请输出 −1 。 测试样例 样例输入 样例输出 22 8 规模与约定 对于 60% 的评测用例，$1 ≤ n ≤ 5000$；对于所有评测用例，$1 ≤ n ≤ 10^6$。 考场思路这个题的长度就和前面那个题形成了鲜明的对比😃。经过一番思考，可以发现，如果数$x=p_1^{k_1}p_2^{k_2}\\cdots p_m^{k_m}$且其中$p_1 &lt; p_2 &lt; \\cdots &lt; p_m$，则$x$的上一个数可能且只可能位于$[x-p_m+1,x-1]$中，且如果$x$是素数，这上一个数不存在。 发现这一点之后就可以做了，只需要先把$x$质因数分解，然后找出最大的素因子，得到只经过一轮的数，然后在把所有可能的数都再进行一次操作，就可以得到所有符合要求的原始数了。复杂度应该是$O(\\sum_{i=\\sqrt n}^{n} \\sqrt i)$，不过经过计算可知这个复杂度大约是$O(n^{\\frac32})$，其实是过不了全部数据的，但是由于大部分数不是质数，都拥有较小的质因子，所以分解质因数的复杂度应当小于$O(\\sqrt x)$，所以我大胆猜测是可以过的。 考试代码如下： unsigned solve(int x, int depth) { if(depth == 0) return x; if(x &lt;= 2) return (unsigned)-1; vector&lt;int&gt; prime_i; // 显然是没有必要的 int tmp = x; for(int i = 2; i * i &lt;= tmp; i++) { if(tmp % i == 0) { prime_i.push_back(i); while(tmp % i == 0) tmp /= i; } } if(tmp != 1 &amp;&amp; tmp != x) prime_i.push_back(tmp); // tmp==x说明是x质数 if(prime_i.empty()) return (unsigned)-1; int max_p = prime_i.back(); unsigned anss = (unsigned)-1; for(int i = 1; i &lt; max_p; i++) { anss = min(anss, solve(x - i, depth-1)); // 用unsigned其实就是为了取min方便 } return anss; } 主函数调用solve(n,2)然后把返回值转化为int即可。 未完待续……其实剩下的三个题我都不会了……😢","categories":[{"name":"竞赛","slug":"竞赛","permalink":"https://toby-shi-cloud.github.io/categories/%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://toby-shi-cloud.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"算法","slug":"算法","permalink":"https://toby-shi-cloud.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"TobyShi"},{"title":"【Python】使用socket库实现server-client通讯的联机对战游戏（一）","slug":"Socket","date":"2022-06-16T13:30:00.000Z","updated":"2022-06-16T14:59:48.192Z","comments":true,"path":"posts/pythonsocket.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/pythonsocket.html","excerpt":"","text":"socket单对单通讯socket是Python内建库之一，用途就是网络通讯。作为实验，我们考虑两个Python程序之间的通讯，一个作为服务器，一个作为客户端，客户端向服务器发送一串字符，服务器收到后将原字符串大写后传回，直到客户端发送空信息，服务器退出。 服务器端代码： import socket ip_port = ('', 8888) # 这个tuple的第一项是ip地址，第二项是端口 s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 定义socket类型，网络通信，TCP s.bind(ip_port) # 套接字绑定ip和端口 s.listen(1) # 开始监听连接请求 conn, addr = s.accept() # 接受连接请求，conn是一个新的套接字，addr是客户端地址 conn.sendall('Hello from the server!'.encode('utf-8')) # 发送打招呼信息，并且用utf-8编码 while True: try: data = conn.recv(1024).decode('utf-8') # 接受数据并使用utf-8解码 if not data: break # 如果数据为空就退出 conn.sendall(data.upper().encode('utf-8')) # 把数据大写后返回 except Exception as e: # 如果数据传输出错 print(e) exit(1) conn.close() # 关闭套接字 客户端代码： import socket ip_port = ('localhost', 8888) # 服务器ip和端口 s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 定义socket类型，网络通信，TCP try: s.connect(ip_port) # 尝试连接服务器 except Exception as e: # 如果连接失败socket.socket.connect会抛出错误 print(e) exit(1) data = s.recv(1024).decode('utf-8') # 接受服务器的问候 print(data) while True: try: msg = input('&gt;&gt;&gt; ') # 此时用户可以在运行客户端的控制台中输入内容 s.sendall(msg.encode('utf-8')) # 将消息发送 if not msg: break # 如果数据为空就退出 data = s.recv(1024).decode('utf-8') # 接受服务器的结果 print(data) except Exception as e: # 如果数据传输出错 print(e) exit(1) s.close() # 关闭套接字 运行结果： socketserver多对一通讯由于我的目的是打算写一个联机对战游戏，那么一个服务器需要同时和多个（至少是两个）客户端建立连接。一个很容易想到的做法就是服务器多线程。好在Python已经帮我们封装好了多线程和socket库——socketserver库。 socketserver库的用法和socket几乎一模一样，而且由于只有服务器端需要多线程，所以只需要更改server.py即可。 下面是server.py的代码： import socketserver ip_port = ('', 10888) class MyServer(socketserver.BaseRequestHandler): def handle(self): # 重写RequestHandler中的handle方法用来处理请求 print(\"conn is :\", self.request) # conn print(\"addr is :\", self.client_address) # addr self.request.sendall('Hello from the server!'.encode('utf-8')) while True: # 处理方面的逻辑都是一样的 try: data = self.request.recv(1024).decode('utf-8') if not data: break self.request.sendall(data.upper().encode('utf-8')) except Exception as e: print(e) break print(\"disconnected with\", self.client_address) if __name__ == '__main__': s = socketserver.ThreadingTCPServer(ip_port, MyServer) # 建立TCP协议套接字 # 使用s.serve_forever()接受无穷次连接（需要按下Ctrl+C中断） # 也可以使用一次s.handle_request()接受一次连接 s.serve_forever() 运行结果： 服务器内部数据传输现在我们已经解决了服务器和客户端之间的数据传输问题了，但是这又引入了新的问题：服务器用多线程和客户端交流，但是socketserver封装的太好了，想要直接从外部操作各个线程显然不显示，那么如何进行服务器各个线程之间的交流呢？ 请听下回分解…… 😀","categories":[{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/tags/Python/"},{"name":"网络","slug":"网络","permalink":"https://toby-shi-cloud.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"server-client","slug":"server-client","permalink":"https://toby-shi-cloud.github.io/tags/server-client/"}],"author":"TobyShi"},{"title":"你好博客！Hello Blog!","slug":"HelloBlog","date":"2022-06-14T11:30:00.000Z","updated":"2022-07-20T12:03:43.586Z","comments":true,"path":"posts/helloblog.html","link":"","permalink":"https://toby-shi-cloud.github.io/posts/helloblog.html","excerpt":"","text":"01 从零开始搭建属于自己的博客具体操作见此博客 不过由于我之前弄过一半，所以这一步的操作就省了，因此这里就不记录了。 02 选择合适的好看的Theme经过许多次试错，最终看到了Luckey大佬的视频，十分羡慕，于是clone了他的博客. 03 博客个性化如果说前面的内容都是跟着教程动动手指就可以完成，那么这一步将会是最大的噩梦。 其中最大的问题就是：我压根没有学过前端，大佬的博客的复杂程度对于我来说简直难以想象。因此这里要特别感谢Luckey大佬的教程以及Matery主题的使用手册，中文文档真的对我这种英语白痴非常友好！ 然后我就开始看着各式各样的文档一通乱改，为了降低改动难度，我就把用不到的功能的入口删掉了，但是如果你手动输入争取的url的话其实依然可以看到Luckey大佬的很多让我大为震撼的功能，想看的朋友可以去他的博客欣赏欣赏。 我做的比较到大的改动就是升级了这个Theme使用的fontawesome的版本，不过其实只需要在官网下载一个zip然后把里面的东西全部覆盖到~\\themes\\matery\\source\\libs\\awesome就可以了。（这样做是因为只有新版才支持B站的图标，不过Gitee的图标仍然木有） 最后比较遗憾的是，不知道为什么我在“视频”栏中嵌入视频失败了，不知道是不是B站嵌入视频已经失效了。 04 Markdown公式测试$$ S_n = \\sum_{i=1}^{n} a_i $$$$ \\int \\cos(x) dx = \\sin(x) $$ 这是行内公式：$\\lim_{x\\rightarrow 0} \\frac{x}{\\sin x} = 1$ 经过测试，公式内换行不知道为什么没有得到支持。 05 在忙了一下午之后总之到晚上的时候我就已经开始写这篇HelloBlog了，还是很兴奋的，毕竟从未有过写前端的经历，然后几乎是从零开始学习搭建，所以真的非常感谢大佬们的帮助。因此如果有朝一日，我也有能力以后，也一定会向把知识分享出来，供大家学习和参考。 无限进步！","categories":[{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"TobyShi"}],"categories":[{"name":"计组","slug":"计组","permalink":"https://toby-shi-cloud.github.io/categories/%E8%AE%A1%E7%BB%84/"},{"name":"Swift编程","slug":"Swift编程","permalink":"https://toby-shi-cloud.github.io/categories/Swift%E7%BC%96%E7%A8%8B/"},{"name":"竞赛","slug":"竞赛","permalink":"https://toby-shi-cloud.github.io/categories/%E7%AB%9E%E8%B5%9B/"},{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/categories/%E8%84%9A%E6%9C%AC/"},{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/categories/Python/"},{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"CO","slug":"CO","permalink":"https://toby-shi-cloud.github.io/tags/CO/"},{"name":"VScode","slug":"VScode","permalink":"https://toby-shi-cloud.github.io/tags/VScode/"},{"name":"Swift","slug":"Swift","permalink":"https://toby-shi-cloud.github.io/tags/Swift/"},{"name":"Apple","slug":"Apple","permalink":"https://toby-shi-cloud.github.io/tags/Apple/"},{"name":"wsl","slug":"wsl","permalink":"https://toby-shi-cloud.github.io/tags/wsl/"},{"name":"C/C++","slug":"C-C","permalink":"https://toby-shi-cloud.github.io/tags/C-C/"},{"name":"算法","slug":"算法","permalink":"https://toby-shi-cloud.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://toby-shi-cloud.github.io/tags/Codeforces/"},{"name":"脚本","slug":"脚本","permalink":"https://toby-shi-cloud.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://toby-shi-cloud.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"Python","slug":"Python","permalink":"https://toby-shi-cloud.github.io/tags/Python/"},{"name":"网络","slug":"网络","permalink":"https://toby-shi-cloud.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"server-client","slug":"server-client","permalink":"https://toby-shi-cloud.github.io/tags/server-client/"},{"name":"博客","slug":"博客","permalink":"https://toby-shi-cloud.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]}